===/image_renderer.txt===
===/cargo.toml===
[package]
name = "image_renderer"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
volare_engine_layout = { path = "../volare_engine_layout" }
image = "0.23"
imageproc = "0.22"
rusttype = "0.9"
bresenham = "0.1.1"
base64 = "0.21"

[lib]
name = "image_renderer"
path = "src/lib.rs"
===/src/lib.rs===
use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};
use bresenham::Bresenham;
use image::{DynamicImage, GenericImageView, Rgba, RgbaImage};
use imageproc::drawing::{draw_filled_rect_mut, draw_hollow_rect_mut, draw_text_mut};
use imageproc::rect::Rect;
use rusttype::{Font, Scale};
use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use volare_engine_layout::Float;

use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, Fill, Renderer,
    RendererError,
};

/**
 * This is the PNG renderer. It will render the diagram to a PNG stream.
 */

pub struct PNGRenderer;

impl<W: Write> Renderer<W> for PNGRenderer {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError> {
        let root_size = session.get_size(diagram_node.entity_id.clone());

        // Use a scaling factor for higher resolution output but don't scale too much
        // 1.5 is a good balance between quality and maintaining layout proportions
        // TODO: Esto debe ser un parametro?
        let scaling_factor = 1.5;

        // Calculate image dimensions with scaling
        let width = ((root_size.0 * scaling_factor).ceil() as u32).max(200);
        let height = ((root_size.1 * scaling_factor).ceil() as u32).max(200);

        // Debug output
        println!("Creating PNG image with dimensions: {}x{}", width, height);

        // Create an image with a white background
        let mut imgbuf = RgbaImage::from_fn(width, height, |_, _| Rgba([255, 255, 255, 255]));

        // Draw a border to see image bounds (for debugging)
        let border_color = Rgba([200, 200, 200, 255]);
        for x in 0..width {
            imgbuf.put_pixel(x, 0, border_color);
            imgbuf.put_pixel(x, height - 1, border_color);
        }
        for y in 0..height {
            imgbuf.put_pixel(0, y, border_color);
            imgbuf.put_pixel(width - 1, y, border_color);
        }

        // Pass scaling factor to the render function
        render_node(
            diagram_node,
            session,
            &mut imgbuf,
            (0.0, 0.0),
            scaling_factor,
        );

        // Write the PNG image to the stream
        let encoder = image::png::PngEncoder::new(stream);
        encoder
            .encode(
                imgbuf.as_raw(),
                imgbuf.width(),
                imgbuf.height(),
                image::ColorType::Rgba8,
            )
            .map_err(|e| RendererError::new(&e.to_string()))?;

        Ok(())
    }
}

// Render a node and its children
fn render_node(
    node: &DiagramTreeNode,
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    parent_offset: (Float, Float),
    scale: Float,
) {
    let entity_id = node.entity_id.clone();
    let pos = session.get_position(entity_id.clone());

    // Calculate absolute position by adding parent offset, then apply scaling
    let abs_pos = (
        (parent_offset.0 + pos.0) * scale,
        (parent_offset.1 + pos.1) * scale,
    );

    // Debug output to track node positioning
    let size = session.get_size(entity_id.clone());
    println!(
        "Rendering node type: {:?}, id: {}, pos: ({:.1}, {:.1}), size: ({:.1}, {:.1})",
        node.entity_type,
        entity_id.clone(),
        abs_pos.0,
        abs_pos.1,
        size.0,
        size.1
    );

    match node.entity_type {
        EntityType::GroupShape => {
            render_group(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::BoxShape => {
            render_box(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::TextShape => {
            render_text(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::VerticalStackShape => {
            render_vertical_stack(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::HorizontalStackShape => {
            render_horizontal_stack(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::ImageShape => {
            render_image(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::TableShape => {
            // Get table properties
            let table_shape = session.get_table(entity_id.clone());
            let size = session.get_size(entity_id.clone());

            // Apply scaling factor to dimensions
            let width = (size.0 * scale).ceil() as u32;
            let height = (size.1 * scale).ceil() as u32;
            let x = abs_pos.0.round() as i32;
            let y = abs_pos.1.round() as i32;

            if x >= 0
                && y >= 0
                && width > 0
                && height > 0
                && x + width as i32 <= imgbuf.width() as i32
                && y + height as i32 <= imgbuf.height() as i32
            {
                // Draw table outer border with specified color
                let border_color = parse_color(&table_shape.table_options.border_color);
                let border_width = (table_shape.table_options.border_width as f32 * scale) as u32;

                // Draw outer border (make it thicker for visibility)
                let rect = Rect::at(x, y).of_size(width, height);
                for i in 0..border_width {
                    if i < border_width {
                        let inner_rect = Rect::at(x + i as i32, y + i as i32)
                            .of_size(width - 2 * i, height - 2 * i);
                        draw_hollow_rect_mut(imgbuf, inner_rect, border_color);
                    }
                }

                // Draw header area
                let header_rect = session.get_size(table_shape.header_rect.clone());
                let header_height = (header_rect.1 * scale).ceil() as u32;
                if header_height > 0 {
                    // Get the exact header color from the options
                    let header_fill_color =
                        parse_color(&table_shape.table_options.header_fill_color);

                    // Debug print the header color
                    println!(
                        "Table header color: {}",
                        table_shape.table_options.header_fill_color
                    );

                    // Fill the header area
                    let header_rect = Rect::at(x, y).of_size(width, header_height);
                    draw_filled_rect_mut(imgbuf, header_rect, header_fill_color);
                    draw_hollow_rect_mut(imgbuf, header_rect, border_color);
                }

                // Use the predefined grid lines from the table
                // This uses the actual table_shape.col_lines and table_shape.row_lines
                // instead of trying to infer them from child positions

                // Draw column lines (vertical dividers)
                for col_line_id in &table_shape.col_lines {
                    // Get the position of this column line
                    let line_pos = session.get_position(col_line_id.clone());
                    let line_size = session.get_size(col_line_id.clone());

                    // Calculate the absolute x position with scaling
                    let line_x = (abs_pos.0 + line_pos.0 * scale as f32).round() as i32;

                    // Only draw if the line is within the image bounds
                    if line_x >= 0 && line_x < imgbuf.width() as i32 {
                        // Draw a vertical line from top to bottom of table
                        for i in 0..height {
                            let y_pos = y + i as i32;
                            if y_pos >= 0 && y_pos < imgbuf.height() as i32 {
                                imgbuf.put_pixel(line_x as u32, y_pos as u32, border_color);
                            }
                        }
                    }
                }

                // Draw row lines (horizontal dividers)
                for row_line_id in &table_shape.row_lines {
                    // Get the position of this row line
                    let line_pos = session.get_position(row_line_id.clone());
                    let line_size = session.get_size(row_line_id.clone());

                    // Calculate the absolute y position with scaling
                    let line_y = (abs_pos.1 + line_pos.1 * scale as f32).round() as i32;

                    // Only draw if the line is within the image bounds
                    if line_y >= 0 && line_y < imgbuf.height() as i32 {
                        // Draw a horizontal line from left to right of table
                        for i in 0..width {
                            let x_pos = x + i as i32;
                            if x_pos >= 0 && x_pos < imgbuf.width() as i32 {
                                imgbuf.put_pixel(x_pos as u32, line_y as u32, border_color);
                            }
                        }
                    }
                }

                // Render children (cells)
                for child in node.children.iter() {
                    render_node(child, session, imgbuf, abs_pos, scale);
                }
            }
        }
        EntityType::EllipseShape => {
            // Get ellipse properties
            let ellipse_shape = session.get_ellipse(entity_id.clone());
            let size = session.get_size(entity_id.clone());

            // Apply scaling factor to dimensions
            let width = (size.0 * scale).ceil() as u32;
            let height = (size.1 * scale).ceil() as u32;
            let x = abs_pos.0.round() as i32;
            let y = abs_pos.1.round() as i32;

            if x >= 0
                && y >= 0
                && width > 0
                && height > 0
                && x + width as i32 <= imgbuf.width() as i32
                && y + height as i32 <= imgbuf.height() as i32
            {
                // Get colors from the ellipse properties
                let fill_color = parse_color(&ellipse_shape.ellipse_options.fill_color);
                let stroke_color = parse_color(&ellipse_shape.ellipse_options.stroke_color);

                // Calculate center coordinates
                let center_x = x + (width / 2) as i32;
                let center_y = y + (height / 2) as i32;
                let radius_x = (width / 2) as i32;
                let radius_y = (height / 2) as i32;

                // Draw filled ellipse first, using floating point for more accurate ellipse equation
                for py in y..y + height as i32 {
                    if py < 0 || py >= imgbuf.height() as i32 {
                        continue; // Skip if outside vertical bounds
                    }

                    for px in x..x + width as i32 {
                        if px < 0 || px >= imgbuf.width() as i32 {
                            continue; // Skip if outside horizontal bounds
                        }

                        // Calculate if this pixel is inside the ellipse using floating point
                        // for higher precision: (x/a)² + (y/b)² <= 1
                        let dx = (px - center_x) as f32;
                        let dy = (py - center_y) as f32;
                        let rx = radius_x as f32;
                        let ry = radius_y as f32;

                        let eq_value = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry);

                        if eq_value <= 1.0 {
                            imgbuf.put_pixel(px as u32, py as u32, fill_color);
                        }
                    }
                }

                // Draw the ellipse border using a modified Bresenham algorithm for smoother outlines
                // This implementation gives much higher quality anti-aliased edges
                draw_anti_aliased_ellipse(
                    imgbuf,
                    center_x,
                    center_y,
                    radius_x,
                    radius_y,
                    stroke_color,
                    (ellipse_shape.ellipse_options.stroke_width * scale as f32) as f32,
                );
            }
        }
        EntityType::PolyLine => {
            render_polyline(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::FreeContainer => {
            render_free_container(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }

        EntityType::ArcShape => {
            render_arc(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }

        // For this initial implementation, we'll skip other shapes
        _ => {}
    }
}
// Fixed render_arc function for image_renderer/src/lib.rs

fn render_arc(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    use std::f32::consts::PI;

    let arc_shape = session.get_arc(entity_id.clone());
    let size = session.get_size(entity_id.clone());

    // Apply scaling factor to dimensions
    let scaled_radius = arc_shape.radius * scale;

    // FIXED: Use the arc's center coordinates directly, don't add pos again
    // The pos parameter already positions this arc correctly via the transform system
    let center_x = (arc_shape.center.0 * scale) as i32;
    let center_y = (arc_shape.center.1 * scale) as i32;

    // Get colors
    let stroke_color = parse_color(&arc_shape.arc_options.stroke_color);
    let fill_color = parse_color(&arc_shape.arc_options.fill_color);
    let stroke_width = arc_shape.arc_options.stroke_width * scale;

    // Get normalized angles and convert to radians
    let (start_angle, end_angle) = arc_shape.normalize_angles();
    let start_rad = start_angle * PI / 180.0;
    let end_rad = end_angle * PI / 180.0;

    // For filled arcs, we need to fill the sector
    if arc_shape.arc_options.filled {
        render_filled_arc_sector(
            imgbuf,
            center_x,
            center_y,
            scaled_radius,
            start_rad,
            end_rad,
            fill_color,
            stroke_color,
            stroke_width,
        );
    } else {
        // For unfilled arcs, just draw the arc curve
        render_arc_curve(
            imgbuf,
            center_x,
            center_y,
            scaled_radius,
            start_rad,
            end_rad,
            stroke_color,
            stroke_width,
        );
    }
}

// Helper function to render a filled arc sector (pie slice)
fn render_filled_arc_sector(
    imgbuf: &mut RgbaImage,
    center_x: i32,
    center_y: i32,
    radius: Float,
    start_rad: Float,
    end_rad: Float,
    fill_color: Rgba<u8>,
    stroke_color: Rgba<u8>,
    stroke_width: Float,
) {
    let radius_i = radius as i32;

    // Fill the sector by checking each pixel in the bounding box
    for y in (center_y - radius_i)..=(center_y + radius_i) {
        for x in (center_x - radius_i)..=(center_x + radius_i) {
            if x >= 0 && x < imgbuf.width() as i32 && y >= 0 && y < imgbuf.height() as i32 {
                let dx = (x - center_x) as Float;
                let dy = (y - center_y) as Float;
                let distance = (dx * dx + dy * dy).sqrt();

                if distance <= radius {
                    // Calculate angle of this pixel
                    let angle = dy.atan2(dx);
                    let angle_deg = angle * 180.0 / std::f32::consts::PI;
                    let normalized_angle = if angle_deg < 0.0 {
                        angle_deg + 360.0
                    } else {
                        angle_deg
                    };

                    // Check if this angle is within our arc
                    let start_deg = start_rad * 180.0 / std::f32::consts::PI;
                    let end_deg = end_rad * 180.0 / std::f32::consts::PI;

                    let angle_in_arc = if end_deg > start_deg {
                        normalized_angle >= start_deg && normalized_angle <= end_deg
                    } else {
                        normalized_angle >= start_deg || normalized_angle <= end_deg
                    };

                    if angle_in_arc {
                        imgbuf.put_pixel(x as u32, y as u32, fill_color);
                    }
                }
            }
        }
    }

    // Draw the arc outline
    render_arc_curve(
        imgbuf,
        center_x,
        center_y,
        radius,
        start_rad,
        end_rad,
        stroke_color,
        stroke_width,
    );

    // Draw lines from center to arc endpoints for filled sectors
    let start_x = center_x + (radius * start_rad.cos()) as i32;
    let start_y = center_y + (radius * start_rad.sin()) as i32;
    let end_x = center_x + (radius * end_rad.cos()) as i32;
    let end_y = center_y + (radius * end_rad.sin()) as i32;

    draw_anti_aliased_line(
        imgbuf,
        center_x,
        center_y,
        start_x,
        start_y,
        stroke_color,
        stroke_width,
    );
    draw_anti_aliased_line(
        imgbuf,
        center_x,
        center_y,
        end_x,
        end_y,
        stroke_color,
        stroke_width,
    );
}

// Helper function to render just the arc curve
fn render_arc_curve(
    imgbuf: &mut RgbaImage,
    center_x: i32,
    center_y: i32,
    radius: Float,
    start_rad: Float,
    end_rad: Float,
    stroke_color: Rgba<u8>,
    stroke_width: Float,
) {
    // Calculate the angle step based on radius for smooth curves
    let num_steps = (radius * 2.0).max(60.0) as i32; // More steps for larger arcs
    let angle_range = if end_rad > start_rad {
        end_rad - start_rad
    } else {
        (2.0 * std::f32::consts::PI) - start_rad + end_rad
    };

    let angle_step = angle_range / num_steps as Float;

    let mut prev_x = center_x + (radius * start_rad.cos()) as i32;
    let mut prev_y = center_y + (radius * start_rad.sin()) as i32;

    for i in 1..=num_steps {
        let current_angle = if end_rad > start_rad {
            start_rad + angle_step * i as Float
        } else {
            let angle = start_rad + angle_step * i as Float;
            if angle > 2.0 * std::f32::consts::PI {
                angle - 2.0 * std::f32::consts::PI
            } else {
                angle
            }
        };

        let current_x = center_x + (radius * current_angle.cos()) as i32;
        let current_y = center_y + (radius * current_angle.sin()) as i32;

        draw_anti_aliased_line(
            imgbuf,
            prev_x,
            prev_y,
            current_x,
            current_y,
            stroke_color,
            stroke_width,
        );

        prev_x = current_x;
        prev_y = current_y;
    }
}

fn render_group(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    _entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    for child in node.children.iter() {
        render_node(child, session, imgbuf, pos, scale);
    }
}

fn render_box(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    let size = session.get_size(entity_id.clone());
    let box_shape = session.get_box(node.entity_id.clone());

    // Convert to i32 for drawing functions with scaling
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    // Safety check to avoid drawing outside the image bounds
    if x < 0
        || y < 0
        || width == 0
        || height == 0
        || x + width as i32 > imgbuf.width() as i32
        || y + height as i32 > imgbuf.height() as i32
    {
        // Skip this box if it's outside the bounds
        return;
    }

    let rect = Rect::at(x, y).of_size(width, height);

    // Handle fill color
    match &box_shape.box_options.fill_color {
        Fill::Color(color) => {
            let rgba = parse_color(color);
            draw_filled_rect_mut(imgbuf, rect, rgba);
        }
        // For now, we'll just use a default color for gradients
        _ => {
            draw_filled_rect_mut(imgbuf, rect, Rgba([255, 255, 255, 255]));
        }
    }

    // Draw border/stroke with scaled width
    let stroke_color = parse_color(&box_shape.box_options.stroke_color);
    let stroke_width = (box_shape.box_options.stroke_width * scale).ceil() as u32;

    // Draw border with proper thickness
    for i in 0..stroke_width {
        if i < stroke_width {
            let inner_rect =
                Rect::at(x + i as i32, y + i as i32).of_size(width - 2 * i, height - 2 * i);
            draw_hollow_rect_mut(imgbuf, inner_rect, stroke_color);
        }
    }

    // Render children inside the box, accounting for padding
    for child in node.children.iter() {
        let child_id = child.entity_id.clone();
        let child_pos = session.get_position(child_id.clone());

        // Instead of trying to be clever about nested transforms, let's use the simplest
        // and most direct approach: manually handle rendering the text here

        // Log child details
        println!(
            "Rendering box child: id={}, type={:?}, box_pos=({:.1},{:.1}), child_pos=({:.1},{:.1})",
            child_id.clone(),
            child.entity_type,
            pos.0,
            pos.1,
            child_pos.0,
            child_pos.1
        );

        // Get absolute position for child relative to box
        let abs_x = (pos.0 + child_pos.0 * scale).round() as i32;
        let abs_y = (pos.1 + child_pos.1 * scale).round() as i32;

        // Calculate absolute position without any scaling
        let adjusted_parent_offset = (pos.0 / scale, pos.1 / scale);

        // Log the adjusted values
        println!(
            "  Using adjusted_parent_offset=({:.1},{:.1})",
            adjusted_parent_offset.0, adjusted_parent_offset.1
        );

        // Render the child with the adjusted parent offset
        // TODO: Centering logic for elems inside box
        render_node(child, session, imgbuf, adjusted_parent_offset, scale);
    }
}

fn render_text(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Get the text and render it directly
    let text_shape = session.get_text(entity_id.clone());
    //get size
    let size = session.get_size(entity_id.clone());
    //TODO: dynamically load the font data!
    //let font_data = include_bytes!("../../demo/assets/Roboto-Regular.ttf");
    let font_data = include_bytes!("../../demo/assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    // Convert text color string to RGBA
    let text_color = parse_color(&text_shape.text_options.text_color);
    println!(
        "  Text: '{}', color: {}, pos: ({}, {})",
        text_shape.text, text_shape.text_options.text_color, pos.0, pos.1
    );

    // Render text directly
    // let dpi = 120.0;
    // let dpi_scale_factor = dpi / 72.0;
    // let font_size = text_shape.text_options.font_size * dpi_scale_factor;

    let font_size = text_shape.text_options.font_size;
    let font_scale = Scale::uniform(font_size * scale as f32);

    // Render each line - use position data from layout engine
    // but adjust line spacing if needed for better aesthetics
    let line_count = text_shape.lines.len();
    let line_spacing_factor = if line_count > 1 { 0.6 } else { 1.0 }; // Further reduce spacing for multi-line text in boxes

    for (i, line_id) in text_shape.lines.iter().enumerate() {
        let line = session.get_text_line(line_id.clone());
        let lineSize = session.get_size(line_id.clone());
        let line_pos = session.get_position(line_id.clone());

        // Calculate base position without any margins yet
        let base_x = (pos.0 * scale) as i32 + (line_pos.0 * scale).round() as i32;

        // For multi-line text, calculate position with adjusted spacing
        let y_pos = if i == 0 {
            // First line uses original position
            line_pos.1
        } else {
            // Subsequent lines use compressed spacing
            let prev_line_pos = session.get_position(text_shape.lines[i - 1].clone());
            prev_line_pos.1 + (line_pos.1 - prev_line_pos.1) * line_spacing_factor
        };

        let line_y = pos.0 as i32 + (y_pos * scale).round() as i32;

        // Calculate the actual rendered text width using font metrics
        // for precise centering
        //let rendered_width = get_text_width(&line.text, &font, font_scale);
        let rendered_width = lineSize.0;
        // Calculate the left-side bearing (space before the first glyph)
        // This is needed because RustType positioning doesn't always start exactly at the x position we provide
        let first_char_glyph = font
            .glyph(line.text.chars().next().unwrap_or(' '))
            .scaled(font_scale)
            .positioned(rusttype::point(0.0, 0.0));

        let left_bearing = if let Some(bb) = first_char_glyph.pixel_bounding_box() {
            bb.min.x
        } else {
            0
        };

        // Center the text horizontally within the box
        // Adjust for the bounding box left side offset
        let centered_x =
            base_x + ((lineSize.0 as f32 - rendered_width as f32) / 2.0) as i32 - left_bearing;

        // Draw the text with centered position
        draw_high_quality_text(
            imgbuf,
            &line.text,
            centered_x,
            line_y,
            &font,
            font_scale,
            text_color,
            size.0 as i32, // Use box width as max width
        );
    }
}

// Draw text with higher quality anti-aliasing
fn draw_high_quality_text(
    imgbuf: &mut RgbaImage,
    text: &str,
    x: i32,
    y: i32,
    font: &Font,
    scale: Scale,
    color: Rgba<u8>,
    _max_width: i32, // We keep this parameter for API compatibility but don't use it
) {
    // Calculate the vertical metrics once
    let v_metrics = font.v_metrics(scale);
    let offset_y = v_metrics.ascent;

    // Layout the glyphs in the text with proper positioning
    let mut caret = rusttype::point(0.0, offset_y);
    let mut last_glyph_id = None;
    let mut glyphs: Vec<rusttype::PositionedGlyph> = Vec::new();

    // Process each character for proper kerning and positioning
    for c in text.chars() {
        // Create the glyph
        let base_glyph = font.glyph(c);

        // Apply kerning if we have a previous glyph
        if let Some(previous) = last_glyph_id {
            caret.x += font.pair_kerning(scale, previous, base_glyph.id());
        }

        last_glyph_id = Some(base_glyph.id());

        // Get the advance width before we consume the glyph with scaled()
        let advance_width = base_glyph.scaled(scale).h_metrics().advance_width;

        // Position the glyph and add it to our collection
        // We need to create the glyph again since scaled() consumes it
        let positioned_glyph = font.glyph(c).scaled(scale).positioned(caret);
        glyphs.push(positioned_glyph);

        // Advance the caret using our saved advance_width
        caret.x += advance_width;
    }

    // Draw each glyph with anti-aliasing
    for glyph in &glyphs {
        if let Some(bounding_box) = glyph.pixel_bounding_box() {
            // Draw the glyph into the image
            glyph.draw(|gx, gy, glyph_opacity| {
                // Map to actual screen position
                let px = x + bounding_box.min.x + gx as i32;
                let py = y + bounding_box.min.y + gy as i32;

                // Only draw if inside image bounds
                if px >= 0 && px < imgbuf.width() as i32 && py >= 0 && py < imgbuf.height() as i32 {
                    // Create a color with adjusted alpha for anti-aliasing
                    let alpha = (glyph_opacity * color[3] as f32) as u8;
                    let antialiased_color = Rgba([color[0], color[1], color[2], alpha]);

                    // Blend with existing pixels for smoother rendering
                    blend_pixel(imgbuf, px, py, antialiased_color, glyph_opacity);
                }
            });
        }
    }
}

fn render_vertical_stack(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Draw a debug rectangle to show the stack bounds
    let size = session.get_size(entity_id.clone());
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    if x >= 0
        && y >= 0
        && width > 0
        && height > 0
        && x + width as i32 <= imgbuf.width() as i32
        && y + height as i32 <= imgbuf.height() as i32
    {
        let rect = Rect::at(x, y).of_size(width, height);
        draw_hollow_rect_mut(imgbuf, rect, Rgba([0, 0, 255, 128]));
    }

    // Render children
    for child in node.children.iter() {
        render_node(child, session, imgbuf, pos, scale);
    }
}

fn render_horizontal_stack(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Draw a debug rectangle to show the stack bounds
    let size = session.get_size(entity_id.clone());
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    if x >= 0
        && y >= 0
        && width > 0
        && height > 0
        && x + width as i32 <= imgbuf.width() as i32
        && y + height as i32 <= imgbuf.height() as i32
    {
        let rect = Rect::at(x, y).of_size(width, height);
        draw_hollow_rect_mut(imgbuf, rect, Rgba([0, 255, 0, 128]));
    }

    // Render children
    for child in node.children.iter() {
        render_node(child, session, imgbuf, pos, scale);
    }
}

fn render_polyline(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    _node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Get polyline properties
    let polyline = session.get_polyline(entity_id.clone());
    let stroke_color = parse_color(&polyline.line_options.stroke_color);
    let stroke_width = (polyline.line_options.stroke_width * scale) as f32;

    // Need at least 2 points to draw a line
    if polyline.points.len() < 2 {
        return;
    }

    // Calculate absolute position with scaling
    let abs_x = pos.0;
    let abs_y = pos.1;

    // Draw line segments connecting all points
    for i in 0..polyline.points.len() - 1 {
        let (x1, y1) = polyline.points[i];
        let (x2, y2) = polyline.points[i + 1];

        // Apply scaling and offset
        let x1_scaled = (abs_x + x1 * scale) as i32;
        let y1_scaled = (abs_y + y1 * scale) as i32;
        let x2_scaled = (abs_x + x2 * scale) as i32;
        let y2_scaled = (abs_y + y2 * scale) as i32;

        // Draw an anti-aliased line with proper thickness
        draw_anti_aliased_line(
            imgbuf,
            x1_scaled,
            y1_scaled,
            x2_scaled,
            y2_scaled,
            stroke_color,
            stroke_width,
        );
    }

    // If it's a closed path (first point == last point), we're already done
    // Otherwise, check if the polyline should be closed by connecting last point to first
    if polyline.points.len() > 2 && polyline.points[0] != polyline.points[polyline.points.len() - 1]
    {
        // If user wants a closed shape (determined by checking if the first and last points are close enough)
        // This is just a heuristic - future implementations could add an explicit "closed" property
        let first = polyline.points[0];
        let last = polyline.points[polyline.points.len() - 1];
        let distance = ((first.0 - last.0).powi(2) + (first.1 - last.1).powi(2)).sqrt();

        // If points are very close, consider it a closed shape (like a polygon)
        if distance < 5.0 {
            // Apply scaling and offset
            let x1_scaled = (abs_x + last.0 * scale) as i32;
            let y1_scaled = (abs_y + last.1 * scale) as i32;
            let x2_scaled = (abs_x + first.0 * scale) as i32;
            let y2_scaled = (abs_y + first.1 * scale) as i32;

            // Draw the closing line
            draw_anti_aliased_line(
                imgbuf,
                x1_scaled,
                y1_scaled,
                x2_scaled,
                y2_scaled,
                stroke_color,
                stroke_width,
            );
        }
    }
}

fn render_free_container(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Log debug information
    println!("==================================================");
    println!(
        "Rendering FreeContainer: id={}, pos=({:.1}, {:.1})",
        entity_id.clone(),
        pos.0,
        pos.1
    );

    // Unscale the position (since render_node applies scaling for us)
    let container_pos = session.get_position(entity_id.clone());
    let size = session.get_size(entity_id.clone());

    // Convert to i32 for drawing functions with scaling
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    println!("FreeContainer size: {}x{}", width, height);
    println!("FreeContainer absolute position: x={}, y={}", x, y);

    // Get the container object
    let container = session.get_free_container(entity_id.clone());

    // Draw the container background first if specified
    if let Some(bg_color) = &container.background_color {
        let fill_color = parse_color(bg_color);
        let rect = Rect::at(x, y).of_size(width, height);
        draw_filled_rect_mut(imgbuf, rect, fill_color);
        println!("Drew container background with color: {}", bg_color);
    }

    // Draw the container border if specified
    if let Some(border_color) = &container.border_color {
        if container.border_width > 0.0 {
            let stroke_color = parse_color(border_color);
            let stroke_width = (container.border_width * scale).ceil() as u32;

            // Draw border with proper thickness
            for i in 0..stroke_width {
                if i < stroke_width {
                    let inner_rect =
                        Rect::at(x + i as i32, y + i as i32).of_size(width - 2 * i, height - 2 * i);
                    draw_hollow_rect_mut(imgbuf, inner_rect, stroke_color);
                }
            }
            println!("Drew container border with color: {}", border_color);
        }
    }

    // Log the children counts
    println!(
        "Container has {} stored positions and {} children in tree",
        container.children.len(),
        node.children.len()
    );

    // Create a mapping from child entity IDs to their positions
    let mut child_positions = std::collections::HashMap::new();
    for (child_id, position) in &container.children {
        child_positions.insert(child_id.clone(), *position);
    }

    // Debug output of all children
    for (i, child) in node.children.iter().enumerate() {
        let child_id = child.entity_id.clone();
        if let Some(rel_pos) = child_positions.get(&child_id) {
            println!(
                "Child[{}]: id={}, type={:?}, stored_pos=({:.1},{:.1})",
                i, child_id, child.entity_type, rel_pos.0, rel_pos.1
            );
        } else {
            println!(
                "Child[{}]: id={}, type={:?}, NO STORED POSITION",
                i, child_id, child.entity_type
            );
        }
    }

    // Render each child with its calculated position
    for (i, child_node) in node.children.iter().enumerate() {
        let child_id = child_node.entity_id.clone();

        // Get the child's position relative to the container from the stored mapping
        if let Some(rel_pos) = child_positions.get(&child_id) {
            // Child is in the FreeContainer's children map

            // For debugging, get the child's size
            let child_size = session.get_size(child_id.clone());
            println!(
                "Child[{}]: id={}, size=({:.1},{:.1})",
                i,
                child_id.clone(),
                child_size.0,
                child_size.1
            );

            // The key fix: since render_node applies pos and scaling again,
            // we need to provide a corrected parent_offset that when combined with
            // the child's position and scaled will result in the correct absolute position

            // Get the child's original position in the session
            let original_child_pos = session.get_position(child_id.clone());

            // Calculate the expected final position we want
            let desired_final_pos = (pos.0 + rel_pos.0 * scale, pos.1 + rel_pos.1 * scale);

            // Calculate the parent_offset that will give us this position after render_node applies
            // its own calculation: abs_pos = (parent_offset + pos) * scale
            // So we need: parent_offset = desired_final_pos / scale - pos
            let adjusted_parent_offset = (
                desired_final_pos.0 / scale - original_child_pos.0,
                desired_final_pos.1 / scale - original_child_pos.1,
            );

            println!("Rendering child[{}]: desired_pos=({:.1},{:.1}), original_pos=({:.1},{:.1}), rel_pos=({:.1},{:.1})", 
                i, desired_final_pos.0, desired_final_pos.1, original_child_pos.0, original_child_pos.1, rel_pos.0, rel_pos.1);
            println!(
                "  Using adjusted_parent_offset=({:.1},{:.1})",
                adjusted_parent_offset.0, adjusted_parent_offset.1
            );

            render_node(child_node, session, imgbuf, adjusted_parent_offset, scale);
        } else {
            // Child doesn't have a stored position
            println!(
                "WARNING: Child[{}] id={} has no stored position in FreeContainer!",
                i, child_id
            );

            // For children without explicit positions in the container, we'll use their
            // original positions from the session, which might be relative to the container
            let child_pos = session.get_position(child_id);

            // Calculate the desired final position
            let desired_final_pos = (pos.0 + child_pos.0 * scale, pos.1 + child_pos.1 * scale);

            // The same adjustment as above for children with stored positions
            let adjusted_parent_offset = (
                desired_final_pos.0 / scale - child_pos.0,
                desired_final_pos.1 / scale - child_pos.1,
            );

            // Log the calculated position
            println!("Child[{}] with no stored position: desired_pos=({:.1},{:.1}), original_pos=({:.1},{:.1})", 
                     i, desired_final_pos.0, desired_final_pos.1, child_pos.0, child_pos.1);
            println!(
                "  Using adjusted_parent_offset=({:.1},{:.1})",
                adjusted_parent_offset.0, adjusted_parent_offset.1
            );

            // Render the child with the adjusted parent offset
            render_node(child_node, session, imgbuf, adjusted_parent_offset, scale);
        }
    }

    println!("==================================================");
}

fn render_image(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    _node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Get image properties
    let image_shape = session.get_image(entity_id.clone());
    let size = session.get_size(entity_id.clone());

    // Apply scaling factor to dimensions
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;

    // Skip if outside bounds
    if x < 0
        || y < 0
        || width == 0
        || height == 0
        || x + width as i32 > imgbuf.width() as i32
        || y + height as i32 > imgbuf.height() as i32
    {
        println!("Image outside bounds, skipping");
        return;
    }

    // Load the image either from file or base64 data
    let loaded_img = if let Some(file_path) = &image_shape.file_path {
        // Load image from file
        println!("Loading image from file: {}", file_path);
        match load_image_from_file(file_path) {
            Ok(img) => img,
            Err(e) => {
                println!("Error loading image from file: {}", e);
                // Return with a placeholder or error indicator
                draw_placeholder_image(imgbuf, x, y, width, height);
                return;
            }
        }
    } else if !image_shape.image.is_empty() {
        // Load image from base64 data
        println!("Loading image from base64 data");
        match load_image_from_base64(&image_shape.image) {
            Ok(img) => img,
            Err(e) => {
                println!("Error loading image from base64: {}", e);
                // Return with a placeholder or error indicator
                draw_placeholder_image(imgbuf, x, y, width, height);
                return;
            }
        }
    } else {
        println!("No image data or file path provided");
        // Draw an empty placeholder if no source is provided
        draw_placeholder_image(imgbuf, x, y, width, height);
        return;
    };

    // Resize the image to fit the allocated space while maintaining aspect ratio
    let resized_img = loaded_img.resize_exact(width, height, image::imageops::FilterType::Lanczos3);

    // Convert the image to an RgbaImage
    let img_rgba = resized_img.to_rgba8();

    // Draw the image onto our output buffer at the specified position
    for (ix, iy, pixel) in img_rgba.enumerate_pixels() {
        let dest_x = x + ix as i32;
        let dest_y = y + iy as i32;

        // Only draw within bounds
        if dest_x >= 0
            && dest_x < imgbuf.width() as i32
            && dest_y >= 0
            && dest_y < imgbuf.height() as i32
        {
            imgbuf.put_pixel(dest_x as u32, dest_y as u32, *pixel);
        }
    }

    // Draw a thin border around the image for visual clarity
    let border_color = Rgba([80, 80, 80, 255]);
    let rect = Rect::at(x, y).of_size(width, height);
    draw_hollow_rect_mut(imgbuf, rect, border_color);
}

// Helper function to load an image from a file
fn load_image_from_file(file_path: &str) -> Result<DynamicImage, String> {
    let path = Path::new(file_path);
    if !path.exists() {
        return Err(format!("File not found: {}", file_path));
    }

    match image::open(path) {
        Ok(img) => Ok(img),
        Err(e) => Err(format!("Failed to load image: {}", e)),
    }
}

// Helper function to load an image from base64 data
fn load_image_from_base64(base64_str: &str) -> Result<DynamicImage, String> {
    // Decode base64 string to bytes
    let img_data = match BASE64.decode(base64_str) {
        Ok(data) => data,
        Err(e) => return Err(format!("Failed to decode base64: {}", e)),
    };

    // Load image from memory
    match image::load_from_memory(&img_data) {
        Ok(img) => Ok(img),
        Err(e) => Err(format!("Failed to load image from memory: {}", e)),
    }
}

// Draw a placeholder for missing or error images
fn draw_placeholder_image(imgbuf: &mut RgbaImage, x: i32, y: i32, width: u32, height: u32) {
    // Fill with light gray
    let fill_color = Rgba([220, 220, 220, 255]);
    let rect = Rect::at(x, y).of_size(width, height);
    draw_filled_rect_mut(imgbuf, rect, fill_color);

    // Draw border
    let border_color = Rgba([150, 150, 150, 255]);
    draw_hollow_rect_mut(imgbuf, rect, border_color);

    // Draw an X from corner to corner
    if width > 10 && height > 10 {
        // Draw diagonal lines for the X
        for i in 0..width.min(height) {
            let ix = x + i as i32;
            let iy = y + i as i32;
            if ix < imgbuf.width() as i32 && iy < imgbuf.height() as i32 {
                imgbuf.put_pixel(ix as u32, iy as u32, Rgba([100, 100, 100, 255]));
            }

            let ix2 = x + i as i32;
            let iy2 = y + (height - i - 1) as i32;
            if ix2 < imgbuf.width() as i32 && iy2 >= 0 && iy2 < imgbuf.height() as i32 {
                imgbuf.put_pixel(ix2 as u32, iy2 as u32, Rgba([100, 100, 100, 255]));
            }
        }
    }
}

// Helper function to convert color string to Rgba
fn parse_color(color_str: &str) -> Rgba<u8> {
    match color_str.to_lowercase().as_str() {
        "black" => Rgba([0, 0, 0, 255]),
        "white" => Rgba([255, 255, 255, 255]),
        "red" => Rgba([255, 0, 0, 255]),
        "green" => Rgba([0, 255, 0, 255]),
        "blue" => Rgba([0, 0, 255, 255]),
        "yellow" => Rgba([255, 255, 0, 255]),
        "gray" | "grey" => Rgba([128, 128, 128, 255]),
        "lightgray" | "lightgrey" | "light gray" | "light grey" => Rgba([200, 200, 200, 255]),
        "darkgray" | "darkgrey" | "dark gray" | "dark grey" => Rgba([80, 80, 80, 255]),
        "orange" => Rgba([255, 165, 0, 255]),
        "purple" => Rgba([128, 0, 128, 255]),
        "brown" => Rgba([165, 42, 42, 255]),
        "cyan" => Rgba([0, 255, 255, 255]),
        "magenta" | "pink" => Rgba([255, 0, 255, 255]),
        _ => {
            println!("Parsing color: {}", color_str);
            // Handle hex color strings like "#RRGGBB" or "#RRGGBBAA"
            if color_str.starts_with('#') && (color_str.len() == 7 || color_str.len() == 9) {
                let r = u8::from_str_radix(&color_str[1..3], 16).unwrap_or(0);
                let g = u8::from_str_radix(&color_str[3..5], 16).unwrap_or(0);
                let b = u8::from_str_radix(&color_str[5..7], 16).unwrap_or(0);
                let a = if color_str.len() == 9 {
                    u8::from_str_radix(&color_str[7..9], 16).unwrap_or(255)
                } else {
                    255
                };
                println!("Parsed hex color to RGBA: [{}, {}, {}, {}]", r, g, b, a);
                Rgba([r, g, b, a])
            } else {
                // Return a visible color for unknown colors - use pink to make it obvious
                println!(
                    "WARNING: Unrecognized color '{}', defaulting to pink",
                    color_str
                );
                Rgba([255, 0, 255, 255])
            }
        }
    }
}

// Create an anti-aliased version of a color with adjustable alpha
fn blend_color(color: Rgba<u8>, intensity: f32) -> Rgba<u8> {
    // Calculate new alpha based on the original alpha and the intensity factor
    let alpha = (color[3] as f32 * intensity) as u8;
    Rgba([color[0], color[1], color[2], alpha])
}

// Blend a pixel with existing content for smooth anti-aliasing
fn blend_pixel(imgbuf: &mut RgbaImage, x: i32, y: i32, color: Rgba<u8>, alpha: f32) {
    if x < 0 || x >= imgbuf.width() as i32 || y < 0 || y >= imgbuf.height() as i32 {
        return;
    }

    // Get the existing pixel color
    let existing = imgbuf.get_pixel(x as u32, y as u32);

    // Alpha blending formula: new = alpha * src + (1 - alpha) * dst
    let blend_alpha = alpha.max(0.0).min(1.0);
    let inv_alpha = 1.0 - blend_alpha;

    let r = (color[0] as f32 * blend_alpha + existing[0] as f32 * inv_alpha) as u8;
    let g = (color[1] as f32 * blend_alpha + existing[1] as f32 * inv_alpha) as u8;
    let b = (color[2] as f32 * blend_alpha + existing[2] as f32 * inv_alpha) as u8;

    // Final alpha is combined alpha from both sources
    let a = (color[3] as f32 * blend_alpha + existing[3] as f32 * inv_alpha) as u8;

    imgbuf.put_pixel(x as u32, y as u32, Rgba([r, g, b, a]));
}

// Draw a pixel with bounds checking
fn safe_put_pixel(imgbuf: &mut RgbaImage, x: i32, y: i32, color: Rgba<u8>) {
    if x >= 0 && x < imgbuf.width() as i32 && y >= 0 && y < imgbuf.height() as i32 {
        imgbuf.put_pixel(x as u32, y as u32, color);
    }
}

// Draw an anti-aliased line between two points with a given thickness
fn draw_anti_aliased_line(
    imgbuf: &mut RgbaImage,
    x0: i32,
    y0: i32,
    x1: i32,
    y1: i32,
    color: Rgba<u8>,
    thickness: f32,
) {
    // Use Bresenham's algorithm for the core line
    // Convert i32 to isize for the Bresenham algorithm
    let x0_isize = x0 as isize;
    let y0_isize = y0 as isize;
    let x1_isize = x1 as isize;
    let y1_isize = y1 as isize;

    for (x_isize, y_isize) in Bresenham::new((x0_isize, y0_isize), (x1_isize, y1_isize)) {
        // Convert back to i32 for our drawing functions
        let x = x_isize as i32;
        let y = y_isize as i32;

        // Draw a "thick" point at each position along the line
        let radius = (thickness / 2.0).ceil() as i32;
        for dx in -radius..=radius {
            for dy in -radius..=radius {
                let dist = ((dx * dx + dy * dy) as f32).sqrt();
                // Calculate alpha based on distance from the line center
                let alpha = if dist <= thickness / 2.0 {
                    // Full opacity for inner pixels
                    1.0
                } else if dist <= thickness / 2.0 + 1.0 {
                    // Fade out for anti-aliasing at the edge (smooth transition)
                    1.0 - (dist - thickness / 2.0)
                } else {
                    // Outside the line's radius
                    0.0
                };

                // Only draw if there's some opacity
                if alpha > 0.0 {
                    // Use blend_pixel for smoother edges
                    blend_pixel(imgbuf, x + dx, y + dy, color, alpha);
                }
            }
        }
    }
}

// Helper function to calculate the exact rendered width of a text string
// Esta funcionaba, es la misma que se usa en measure text?
fn get_text_width(text: &str, font: &Font, scale: Scale) -> f32 {
    // Calculate the width using font metrics with kerning
    let mut caret = 0.0f32;
    let mut prev_glyph_id = None;

    for c in text.chars() {
        // Get the glyph
        let base_glyph = font.glyph(c);
        let glyph_id = base_glyph.id();

        // Add kerning if we have a previous glyph
        if let Some(prev_id) = prev_glyph_id {
            caret += font.pair_kerning(scale, prev_id, glyph_id);
        }

        // Get metrics for this glyph and add its advance width
        let advance_width = font.glyph(c).scaled(scale).h_metrics().advance_width;
        caret += advance_width;

        // Track previous glyph for kerning
        prev_glyph_id = Some(glyph_id);
    }

    // Return the final width
    caret
}

// Draw an anti-aliased ellipse with a given thickness
fn draw_anti_aliased_ellipse(
    imgbuf: &mut RgbaImage,
    cx: i32,
    cy: i32,
    a: i32,
    b: i32,
    color: Rgba<u8>,
    thickness: f32,
) {
    // For very small ellipses, use a simple algorithm
    if a <= 2 || b <= 2 {
        for angle_deg in 0..360 {
            let rad = angle_deg as Float * std::f32::consts::PI / 180.0;
            let x = cx + (a as f32 * rad.cos()).round() as i32;
            let y = cy + (b as f32 * rad.sin()).round() as i32;
            safe_put_pixel(imgbuf, x, y, color);
        }
        return;
    }

    // Improved ellipse drawing using line segments
    // Using more segments for smoother appearance - scale with radius for higher quality
    let num_segments = (a.max(b) * 8).max(120);

    // Calculate first point
    let first_angle: Float = 0.0;
    let first_x = cx + (a as f32 * first_angle.cos()).round() as i32;
    let first_y = cy + (b as f32 * first_angle.sin()).round() as i32;

    let mut prev_x = first_x;
    let mut prev_y = first_y;

    // Draw segments connecting points along the ellipse
    for i in 1..=num_segments {
        let angle = 2.0 * std::f32::consts::PI * (i as f32 / num_segments as f32);
        let x = cx + (a as f32 * angle.cos()).round() as i32;
        let y = cy + (b as f32 * angle.sin()).round() as i32;

        // Draw anti-aliased line segment between consecutive points
        draw_anti_aliased_line(imgbuf, prev_x, prev_y, x, y, color, thickness);

        prev_x = x;
        prev_y = y;
    }

    // Close the ellipse by connecting back to the first point
    draw_anti_aliased_line(imgbuf, prev_x, prev_y, first_x, first_y, color, thickness);
}


===/demo.txt===
===/Cargo.toml===
[package]
name = "demo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

#add dep to crate in local workspace
volare_engine_layout = { path = "../volare_engine_layout" }
svg_renderer = { path = "../svg_renderer" }
resvg = "0.25.0"
rusttype = "0.9.3"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
uuid = { version = "1.8", features = ["v4"] }

[[bin]]
name = "textdemo"
path = "src/bin/text.rs"

[[bin]]
name = "demo"
path = "src/main.rs"

[[bin]]
name = "patterns"
path = "src/bin/patterns.rs"

[[bin]]
name = "constraints"
path = "src/bin/constraints.rs"


===/.gitignore===
/target

===/src/measure_text.rs===
use rusttype::{point, Font, Scale};
use volare_engine_layout::{Float, TextOptions};

/**
 * Measure text using SVG character advance method
 * This method calculates the width based on the advance width of each character,
 * taking into account kerning between characters.
 * It provides a more accurate width for SVG rendering, especially for variable-width fonts.
 */
pub fn measure_text_svg_character_advance(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);

    let mut total_width = 0.0;
    let mut prev_glyph_id = None;

    for ch in text.chars() {
        let glyph = font.glyph(ch).scaled(scale);

        // Use horizontal advance instead of bounding box
        let advance_width = glyph.h_metrics().advance_width;

        // Add kerning if available
        if let Some(prev_id) = prev_glyph_id {
            total_width += font.pair_kerning(scale, prev_id, glyph.id());
        }

        total_width += advance_width;
        prev_glyph_id = Some(glyph.id());
    }

    // Use font metrics for height instead of glyph bounds
    let v_metrics = font.v_metrics(scale);
    let height = v_metrics.ascent - v_metrics.descent;

    (total_width as Float, height as Float)
}

// tight measurement that accounts for actual glyph positioning
// Used for PNG rendering
pub fn measure_text_ultra_tight(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);
    let v_metrics = font.v_metrics(scale);

    if text.is_empty() {
        return (0.0, (v_metrics.ascent - v_metrics.descent) as Float);
    }

    // Use rusttype's layout function which handles everything correctly
    // TODO: Needs unicode normalization for proper glyph handling, see comments of `layout` function
    let glyphs: Vec<_> = font.layout(text, scale, point(0.0, 0.0)).collect();

    // Find the actual visual bounds
    let mut min_x = f32::INFINITY;
    let mut max_x = f32::NEG_INFINITY;

    for glyph in &glyphs {
        if let Some(bb) = glyph.pixel_bounding_box() {
            min_x = min_x.min(bb.min.x as f32);
            max_x = max_x.max(bb.max.x as f32);
        }
    }

    let width = if min_x.is_finite() && max_x.is_finite() {
        max_x - min_x // Pure visual width, no padding
    } else {
        // Fallback for whitespace
        glyphs
            .iter()
            .map(|g| g.unpositioned().h_metrics().advance_width)
            .sum()
    };

    let height = v_metrics.ascent - v_metrics.descent;

    println!("ULTRA TIGHT: '{}' -> {:.2}x{:.2}", text, width, height);
    (width as Float, height as Float)
}

===/src/bin/arrows-ellipses.rs===
// src/bin/arrows_ellipses_demo.rs
// Demo program to test arrows and ellipses positioning

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🏹 Arrows and Ellipses Demo Starting...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("arrows_ellipses_demo");
    std::fs::create_dir_all(&output_dir)?;

    // Generate various demos to test positioning
    generate_basic_arrows_demo(&output_dir)?;
    generate_basic_ellipses_demo(&output_dir)?;
    generate_mixed_positioning_demo(&output_dir)?;
    generate_free_container_test(&output_dir)?;

    println!("\n✅ All arrows and ellipses demos generated successfully!");
    println!("📁 Files saved in: {}", output_dir.display());

    Ok(())
}

// Demo 1: Basic Arrows in Different Layouts
fn generate_basic_arrows_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","arrows_hstack","arrows_free"],"h_align":"center"}
{"id":"title","type":"text","content":"🏹 Arrow Positioning Test","font_size":24,"color":"darkblue"}
{"id":"arrows_hstack","type":"vstack","children":["hstack_label","hstack_arrows"],"h_align":"center"}
{"id":"hstack_label","type":"text","content":"Arrows in HStack","font_size":16,"color":"#333"}
{"id":"hstack_arrows","type":"hstack","children":["arrow1","arrow2","arrow3"],"v_align":"center"}
{"id":"arrow1","type":"line","start_x":0,"start_y":0,"end_x":50,"end_y":0,"stroke_color":"red","stroke_width":3}
{"id":"arrow2","type":"line","start_x":0,"start_y":0,"end_x":0,"end_y":50,"stroke_color":"green","stroke_width":3}
{"id":"arrow3","type":"line","start_x":0,"start_y":0,"end_x":50,"end_y":50,"stroke_color":"blue","stroke_width":3}
{"id":"arrows_free","type":"vstack","children":["free_label","free_container"],"h_align":"center"}
{"id":"free_label","type":"text","content":"Arrows in Free Container","font_size":16,"color":"#333"}
{"id":"free_container","type":"free_container","width":300,"height":200,"children":["arrow4","arrow5","arrow6"]}
{"id":"arrow4","type":"line","start_x":50,"start_y":50,"end_x":100,"end_y":50,"stroke_color":"red","stroke_width":3,"x":0,"y":0}
{"id":"arrow5","type":"line","start_x":150,"start_y":50,"end_x":150,"end_y":100,"stroke_color":"green","stroke_width":3,"x":0,"y":0}
{"id":"arrow6","type":"line","start_x":200,"start_y":50,"end_x":250,"end_y":100,"stroke_color":"blue","stroke_width":3,"x":0,"y":0}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_basic_arrows.svg"), "Basic Arrows Test")
}

// Demo 2: Basic Ellipses in Different Layouts
//TODO: remove "cx" and "cy"
fn generate_basic_ellipses_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","ellipses_hstack","ellipses_free"],"h_align":"center"}
{"id":"title","type":"text","content":"⭕ Ellipse Positioning Test","font_size":24,"color":"darkgreen"}
{"id":"ellipses_hstack","type":"vstack","children":["hstack_label","hstack_ellipses"],"h_align":"center"}
{"id":"hstack_label","type":"text","content":"Ellipses in HStack","font_size":16,"color":"#333"}
{"id":"hstack_ellipses","type":"hstack","children":["ellipse1","ellipse2","ellipse3"],"v_align":"center"}
{"id":"ellipse1","type":"ellipse","cx":20,"cy":20,"rx":20,"ry":20,"fill":"red","stroke":"darkred","stroke_width":2}
{"id":"ellipse2","type":"ellipse","cx":15,"cy":30,"rx":15,"ry":30,"fill":"green","stroke":"darkgreen","stroke_width":2}
{"id":"ellipse3","type":"ellipse","cx":30,"cy":15,"rx":30,"ry":15,"fill":"blue","stroke":"darkblue","stroke_width":2}
{"id":"ellipses_free","type":"vstack","children":["free_label","free_ellipses_container"],"h_align":"center"}
{"id":"free_label","type":"text","content":"Ellipses in Free Container","font_size":16,"color":"#333"}
{"id":"free_ellipses_container","type":"free_container","width":300,"height":200,"children":["ellipse4","ellipse5","ellipse6"]}
{"id":"ellipse4","type":"ellipse","cx":30,"cy":30,"rx":25,"ry":25,"fill":"red","stroke":"darkred","stroke_width":2,"x":20,"y":20}
{"id":"ellipse5","type":"ellipse","cx":30,"cy":30,"rx":20,"ry":35,"fill":"green","stroke":"darkgreen","stroke_width":2,"x":120,"y":20}
{"id":"ellipse6","type":"ellipse","cx":30,"cy":30,"rx":35,"ry":20,"fill":"blue","stroke":"darkblue","stroke_width":2,"x":220,"y":20}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_basic_ellipses.svg"), "Basic Ellipses Test")
}

// Demo 3: Mixed Positioning - Arrows and Ellipses Together
fn generate_mixed_positioning_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","mixed_demo"],"h_align":"center"}
{"id":"title","type":"text","content":"Mixed Arrows & Ellipses","font_size":24,"color":"darkorange"}
{"id":"mixed_demo","type":"free_container","width":400,"height":300,"children":["target1","target2","target3","arrow_to_1","arrow_to_2","arrow_to_3","labels"]}
{"id":"target1","type":"ellipse","cx":25,"cy":25,"rx":20,"ry":20,"fill":"red","stroke":"darkred","stroke_width":3,"x":50,"y":50}
{"id":"target2","type":"ellipse","cx":25,"cy":25,"rx":20,"ry":20,"fill":"green","stroke":"darkgreen","stroke_width":3,"x":200,"y":50}
{"id":"target3","type":"ellipse","cx":25,"cy":25,"rx":20,"ry":20,"fill":"blue","stroke":"darkblue","stroke_width":3,"x":125,"y":150}
{"id":"arrow_to_1","type":"line","start_x":10,"start_y":10,"end_x":65,"end_y":65,"stroke_color":"black","stroke_width":2,"x":10,"y":10}
{"id":"arrow_to_2","type":"line","start_x":10,"start_y":10,"end_x":75,"end_y":65,"stroke_color":"black","stroke_width":2,"x":150,"y":10}
{"id":"arrow_to_3","type":"line","start_x":10,"start_y":10,"end_x":40,"end_y":65,"stroke_color":"black","stroke_width":2,"x":100,"y":100}
{"id":"labels","type":"vstack","children":["label1","label2"],"h_align":"left","x":50,"y":250}
{"id":"label1","type":"text","content":"• Arrows should point toward ellipses","font_size":12,"color":"#333"}
{"id":"label2","type":"text","content":"• If positioning works, arrows point to targets","font_size":12,"color":"#333"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_mixed_positioning.svg"), "Mixed Arrows & Ellipses")
}

// Demo 4: Free Container Edge Cases
fn generate_free_container_test(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","edge_cases"],"h_align":"center"}
{"id":"title","type":"text","content":"🔍 Edge Case Testing","font_size":24,"color":"darkviolet"}
{"id":"edge_cases","type":"free_container","width":500,"height":400,"children":["corner_ellipses","center_cross","coordinate_test"]}
{"id":"corner_ellipses","type":"free_container","width":200,"height":200,"children":["tl_ellipse","tr_ellipse","bl_ellipse","br_ellipse"],"x":20,"y":20}
{"id":"tl_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"red","stroke":"darkred","stroke_width":1,"x":0,"y":0}
{"id":"tr_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"green","stroke":"darkgreen","stroke_width":1,"x":170,"y":0}
{"id":"bl_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"blue","stroke":"darkblue","stroke_width":1,"x":0,"y":170}
{"id":"br_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"orange","stroke":"darkorange","stroke_width":1,"x":170,"y":170}
{"id":"center_cross","type":"free_container","width":100,"height":100,"children":["h_line","v_line","center_dot"],"x":250,"y":50}
{"id":"h_line","type":"line","start_x":0,"start_y":50,"end_x":100,"end_y":50,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"v_line","type":"line","start_x":50,"start_y":0,"end_x":50,"end_y":100,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"center_dot","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red","stroke":"darkred","stroke_width":1,"x":45,"y":45}
{"id":"coordinate_test","type":"vstack","children":["coord_label","coord_details"],"h_align":"left","x":50,"y":300}
{"id":"coord_label","type":"text","content":"Coordinate System Test:","font_size":14,"color":"#333"}
{"id":"coord_details","type":"vstack","children":["detail1","detail2","detail3"],"h_align":"left"}
{"id":"detail1","type":"text","content":"• Corner ellipses should be at actual corners","font_size":11,"color":"#666"}
{"id":"detail2","type":"text","content":"• Cross lines should intersect at red dot center","font_size":11,"color":"#666"}
{"id":"detail3","type":"text","content":"• All shapes should be positioned as specified","font_size":11,"color":"#666"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_edge_cases.svg"), "Edge Case Testing")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generating: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Saved: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}

===/src/bin/city2.rs===
// src/bin/dense_city.rs
// Demo program that generates a super dense city using loops

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🏙️ Generando Ciudad Súper Densa con Loops...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("dense_city");
    std::fs::create_dir_all(&output_dir)?;

    // Generate the dense city
    generate_dense_city(&output_dir)?;

    println!("\n✅ Ciudad densa generada exitosamente!");
    println!("📁 Archivo guardado en: {}", output_dir.display());

    Ok(())
}

fn generate_dense_city(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("🏗️ Construyendo ciudad con loops...");
    
    let mut jsonl_lines = Vec::new();
    
    // Configuración de la ciudad
    let city_width = 2000;
    let city_height = 1500;
    let block_size = 100;
    let street_width = 8;
    
    // Colores para diferentes tipos de edificios
    let residential_colors = ["#DEB887", "#F4A460", "#CD853F", "#D2691E", "#8B4513", "#A0522D"];
    let commercial_colors = ["#4169E1", "#32CD32", "#FF6347", "#FFD700", "#9370DB", "#20B2AA"];
    let office_colors = ["#708090", "#2F4F4F", "#696969", "#778899", "#B0C4DE", "#87CEEB"];
    let industrial_colors = ["#808080", "#696969", "#A9A9A9", "#778899", "#708090"];
    
    // Root container
    jsonl_lines.push(format!(
        r##"{{"id":"root","type":"free_container","width":{},"height":{},"background":"#87CEEB","children":["street_grid","districts","labels","transportation","landmarks"]}}"##,
        city_width, city_height
    ));
    
    // Generar grid de calles
    let mut street_children = Vec::new();
    let mut street_id = 0;
    
    // Calles horizontales
    for i in 0..(city_height / block_size + 1) {
        let y = i * block_size;
        let id = format!("h_street_{}", street_id);
        street_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"#696969","x":0,"y":{}}}"##,
            id, city_width, street_width, y
        ));
        street_id += 1;
    }
    
    // Calles verticales
    for i in 0..(city_width / block_size + 1) {
        let x = i * block_size;
        let id = format!("v_street_{}", street_id);
        street_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"#696969","x":{},"y":0}}"##,
            id, street_width, city_height, x
        ));
        street_id += 1;
    }
    
    // Container para calles
    jsonl_lines.push(format!(
        r##"{{"id":"street_grid","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        street_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar distritos con loops
    let mut district_children = Vec::new();
    
    // 1. Distrito Residencial (noroeste)
    let mut residential_buildings = Vec::new();
    for block_y in 0..6 {
        for block_x in 0..8 {
            for house_y in 0..3 {
                for house_x in 0..4 {
                    let id = format!("res_{}_{}_{}_{}", block_x, block_y, house_x, house_y);
                    let x = block_x * block_size + house_x * 22 + 12;
                    let y = block_y * block_size + house_y * 28 + 12;
                    let width = 18 + (house_x * 2);
                    let height = 20 + (house_y * 3);
                    let color = residential_colors[(house_x + house_y) % residential_colors.len()];
                    
                    residential_buildings.push(id.clone());
                    jsonl_lines.push(format!(
                        r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                        id, width, height, color, x, y
                    ));
                }
            }
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"residential_district","type":"free_container","width":800,"height":600,"children":[{}],"x":0,"y":0}}"##,
        residential_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("residential_district".to_string());
    
    // 2. Distrito Comercial (centro)
    let mut commercial_buildings = Vec::new();
    for block_y in 0..8 {
        for block_x in 8..14 {
            for bldg_y in 0..2 {
                for bldg_x in 0..3 {
                    let id = format!("com_{}_{}_{}_{}", block_x, block_y, bldg_x, bldg_y);
                    let x = block_x * block_size + bldg_x * 30 + 10;
                    let y = block_y * block_size + bldg_y * 45 + 10;
                    let width = 25 + (bldg_x * 5);
                    let height = 35 + (bldg_y * 10) + (block_y * 2);
                    let color = commercial_colors[(bldg_x + bldg_y + block_y) % commercial_colors.len()];
                    
                    commercial_buildings.push(id.clone());
                    jsonl_lines.push(format!(
                        r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                        id, width, height, color, x, y
                    ));
                }
            }
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"commercial_district","type":"free_container","width":600,"height":800,"children":[{}],"x":800,"y":0}}"##,
        commercial_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("commercial_district".to_string());
    
    // 3. Distrito de Oficinas (suroeste)
    let mut office_buildings = Vec::new();
    for block_y in 6..12 {
        for block_x in 0..10 {
            let id = format!("office_{}_{}", block_x, block_y);
            let x = block_x * block_size + 15;
            let y = block_y * block_size + 15;
            let width = 70;
            let height = 60 + (block_x * 8) + (block_y * 3);
            let color = office_colors[(block_x + block_y) % office_colors.len()];
            
            office_buildings.push(id.clone());
            jsonl_lines.push(format!(
                r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                id, width, height, color, x, y
            ));
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"office_district","type":"free_container","width":1000,"height":600,"children":[{}],"x":0,"y":600}}"##,
        office_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("office_district".to_string());
    
    // 4. Zona Industrial (sureste)
    let mut industrial_buildings = Vec::new();
    for block_y in 8..15 {
        for block_x in 10..20 {
            let id = format!("ind_{}_{}", block_x, block_y);
            let x = block_x * block_size + 20;
            let y = block_y * block_size + 20;
            let width = 60 + (block_x % 3) * 15;
            let height = 40 + (block_y % 4) * 10;
            let color = industrial_colors[(block_x + block_y) % industrial_colors.len()];
            
            industrial_buildings.push(id.clone());
            jsonl_lines.push(format!(
                r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                id, width, height, color, x, y
            ));
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"industrial_district","type":"free_container","width":1000,"height":700,"children":[{}],"x":1000,"y":800}}"##,
        industrial_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("industrial_district".to_string());
    
    // 5. Rascacielos en el centro
    let mut skyscraper_buildings = Vec::new();
    for i in 0..15 {
        for j in 0..8 {
            let id = format!("sky_{}_{}", i, j);
            let x = 1400 + i * 35;
            let y = 200 + j * 70;
            let width = 25 + (i % 3) * 5;
            let height = 100 + i * 12 + j * 8;
            let color_idx = (i + j) % office_colors.len();
            let color = office_colors[color_idx];
            
            skyscraper_buildings.push(id.clone());
            jsonl_lines.push(format!(
                r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                id, width, height, color, x, y
            ));
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"skyscraper_district","type":"free_container","width":600,"height":800,"children":[{}],"x":1400,"y":0}}"##,
        skyscraper_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("skyscraper_district".to_string());
    
    // Container para todos los distritos
    jsonl_lines.push(format!(
        r##"{{"id":"districts","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        district_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar etiquetas para distritos
    let mut label_children = Vec::new();
    let labels = [
        ("Residential Quarter", 400, 50),
        ("Commercial District", 1100, 50),
        ("Business Center", 500, 650),
        ("Industrial Zone", 1500, 850),
        ("Downtown Core", 1700, 50),
    ];
    
    for (i, (text, x, y)) in labels.iter().enumerate() {
        let id = format!("label_{}", i);
        label_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"text","content":"{}","font_size":16,"color":"#000080","x":{},"y":{}}}"##,
            id, text, x, y
        ));
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"labels","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        label_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar sistema de transporte con loops
    let mut transport_children = Vec::new();
    
    // Metro lines
    let metro_lines = [
        (("#FF0000", 6), vec![(0, 300), (500, 305), (1000, 300), (1500, 305), (2000, 300)]),
        (("#00FF00", 6), vec![(0, 600), (600, 605), (1200, 600), (1800, 605), (2000, 600)]),
        (("#0000FF", 6), vec![(300, 0), (305, 400), (300, 800), (305, 1200), (300, 1500)]),
        (("#FFFF00", 6), vec![(900, 0), (905, 350), (900, 700), (905, 1050), (900, 1500)]),
    ];
    
    for (line_idx, ((color, width), points)) in metro_lines.iter().enumerate() {
        let id = format!("metro_line_{}", line_idx);
        transport_children.push(id.clone());
        let points_str = points.iter()
            .map(|(x, y)| format!("[{},{}]", x, y))
            .collect::<Vec<_>>()
            .join(",");
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"polyline","points":[{}],"stroke_color":"{}","stroke_width":{},"x":0,"y":0}}"##,
            id, points_str, color, width
        ));
    }
    
    // Estaciones de metro con validación
    for i in 0..20 {
        for j in 0..15 {
            if (i * 150) % 300 == 0 && (j * 100) % 300 == 0 {
                let id = format!("station_{}_{}", i, j);
                transport_children.push(id.clone());
                jsonl_lines.push(format!(
                    r##"{{"id":"{}","type":"rect","width":8,"height":8,"background":"white","stroke_color":"black","x":{},"y":{}}}"##,
                    id, i * 100 + 296, j * 100 + 296
                ));
            }
        }
    }
    
    // Autopistas con loops
    let highway_segments = [
        (0, 900, 2000, 900, 12),
        (1500, 0, 1500, 1500, 10),
    ];
    
    for (seg_idx, (x1, y1, x2, y2, width)) in highway_segments.iter().enumerate() {
        let id = format!("highway_{}", seg_idx);
        transport_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"polyline","points":[[{},{}],[{},{}]],"stroke_color":"#2F2F2F","stroke_width":{},"x":0,"y":0}}"##,
            id, x1, y1, x2, y2, width
        ));
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"transportation","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        transport_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar landmarks importantes
    let mut landmark_children = Vec::new();
    
    // Parques generados con loops
    let parks = [(400, 400, 150, 100), (1200, 200, 120, 80), (800, 1000, 180, 120)];
    for (park_idx, (x, y, w, h)) in parks.iter().enumerate() {
        let park_id = format!("park_{}", park_idx);
        landmark_children.push(park_id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"#32CD32","x":{},"y":{}}}"##,
            park_id, w, h, x, y
        ));
        
        // Árboles en el parque
        for tree_x in 0..(w / 20) {
            for tree_y in 0..(h / 20) {
                let tree_id = format!("tree_{}_{}_{}", park_idx, tree_x, tree_y);
                landmark_children.push(tree_id.clone());
                jsonl_lines.push(format!(
                    r##"{{"id":"{}","type":"rect","width":4,"height":4,"background":"#228B22","x":{},"y":{}}}"##,
                    tree_id, x + tree_x * 20 + 8, y + tree_y * 20 + 8
                ));
            }
        }
    }
    
    // Río serpenteante
    let mut river_points = Vec::new();
    for i in 0..40 {
        let x = i * 50;
        let y = 1200.0 + (i as f32 * 0.5).sin() * 100.0;
        river_points.push(format!("[{},{}]", x, y as i32));
    }
    landmark_children.push("river".to_string());
    jsonl_lines.push(format!(
        r##"{{"id":"river","type":"polyline","points":[{}],"stroke_color":"#4169E1","stroke_width":20,"x":0,"y":0}}"##,
        river_points.join(",")
    ));
    
    jsonl_lines.push(format!(
        r##"{{"id":"landmarks","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        landmark_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Escribir el JSONL generado con validación
    let jsonl_content = jsonl_lines.join("\n");
    
    // Validar JSON antes de continuar
    println!("🔍 Validando JSONL generado...");
    let mut parser_test = parser::JsonLinesParser::new();
    match parser_test.parse_string(&jsonl_content) {
        Ok(_) => println!("✅ JSONL válido!"),
        Err(e) => {
            println!("❌ Error en JSONL: {:?}", e);
            // Escribir a archivo para debug
            let debug_path = output_dir.join("debug_jsonl.txt");
            std::fs::write(&debug_path, &jsonl_content)?;
            println!("🐛 JSONL escrito a {} para debug", debug_path.display());
            return Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("JSONL inválido: {:?}", e)
            )));
        }
    }
    
    println!("📊 Estadísticas de la ciudad:");
    println!("   🏠 Edificios residenciales: {}", residential_buildings.len());
    println!("   🏢 Edificios comerciales: {}", commercial_buildings.len());
    println!("   🏭 Edificios de oficinas: {}", office_buildings.len());
    println!("   🏗️ Edificios industriales: {}", industrial_buildings.len());
    println!("   🏙️ Rascacielos: {}", skyscraper_buildings.len());
    println!("   📏 Total de líneas JSONL: {}", jsonl_lines.len());
    
    generate_svg_from_jsonl(&jsonl_content, output_dir.join("dense_city.svg"), "Ciudad Súper Densa")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/bin/patterns.rs===
// Create an SVG file with all supported elements

//import svg_renderer
// use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, HorizontalAlignment, LineOptions};
use demo::measure_text::{ measure_text_ultra_tight};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    TableOptions, TextOptions, Fill,
};
//import io modules to write to file
use std::fs::File;

struct CardOptions {

}

//componente card
//la tarjeta tiene contenido y titulo
fn card_component(id: String, session:&mut DiagramBuilder, header: DiagramTreeNode, content: DiagramTreeNode, opts: CardOptions) -> DiagramTreeNode {
    
    session.new_vstack(id.clone(), vec![header,content], HorizontalAlignment::Center)

}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
  
    session.set_measure_text_fn(measure_text_ultra_tight);

    let mut table_items = Vec::new();

    let cardOptions = CardOptions {

    };

      let textOpts =  TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "black".to_string(),  // white text
            line_spacing: 5.0,
        };

    let cheader = session.new_text("title".to_string(), "card title", textOpts.clone());
    let ccontent = session.new_text("contents".to_string(), "card contents", textOpts.clone());
    let card1 = card_component("card".to_string(), &mut session, cheader, ccontent, cardOptions);



    
    // Add the FreeContainer to the table
    // table_items.push(container_with_elements);

    table_items.push(card1);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 5;
    let table = session.new_table("items".to_string(), table_items, 1, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
  
    
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());
    

    // Render PNG
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

===/src/bin/city.rs===
// src/bin/intricate_city.rs
// Demo program that generates an intricate city using only polylines, rects, and free containers

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🏙️ Generando Ciudad Intrincada...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("intricate_city");
    std::fs::create_dir_all(&output_dir)?;

    // Generate the intricate city
    generate_intricate_city(&output_dir)?;

    println!("\n✅ Ciudad generada exitosamente!");
    println!("📁 Archivo guardado en: {}", output_dir.display());

    Ok(())
}

fn generate_intricate_city(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":1400,"height":900,"background":"#E6F3FF","children":["metro_grid","financial_district","tech_campus","cultural_quarter","harbor","mountain_range","sky_bridges","monorail","shopping_centers"]}

{"id":"metro_grid","type":"free_container","width":1400,"height":900,"children":["metro_line_1","metro_line_2","metro_line_3","metro_line_4","station_markers"],"x":0,"y":0}
{"id":"metro_line_1","type":"polyline","points":[[0,200],[300,205],[600,200],[900,205],[1200,200],[1400,205]],"stroke_color":"#FF6B6B","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_2","type":"polyline","points":[[0,450],[350,455],[700,450],[1050,455],[1400,450]],"stroke_color":"#4ECDC4","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_3","type":"polyline","points":[[200,0],[205,200],[200,400],[205,600],[200,800],[205,900]],"stroke_color":"#45B7D1","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_4","type":"polyline","points":[[800,0],[805,200],[800,400],[805,600],[800,800],[805,900]],"stroke_color":"#96CEB4","stroke_width":6,"x":0,"y":0}
{"id":"station_markers","type":"hstack","children":["station_1","station_2","station_3","station_4","station_5"],"v_align":"center","x":180,"y":180}
{"id":"station_1","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_2","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_3","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_4","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_5","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}

{"id":"financial_district","type":"vstack","children":["fd_tier_1","fd_tier_2","fd_tier_3","fd_plaza"],"h_align":"center","x":50,"y":50}
{"id":"fd_tier_1","type":"hstack","children":["tower_mega","tower_alpha","tower_beta"],"v_align":"bottom"}
{"id":"tower_mega","type":"rect","width":45,"height":180,"background":"#2C3E50"}
{"id":"tower_alpha","type":"rect","width":40,"height":160,"background":"#34495E"}
{"id":"tower_beta","type":"rect","width":35,"height":140,"background":"#7F8C8D"}
{"id":"fd_tier_2","type":"hstack","children":["bank_central","office_prime","office_gold"],"v_align":"bottom"}
{"id":"bank_central","type":"rect","width":50,"height":80,"background":"#F39C12"}
{"id":"office_prime","type":"rect","width":30,"height":100,"background":"#E74C3C"}
{"id":"office_gold","type":"rect","width":35,"height":90,"background":"#9B59B6"}
{"id":"fd_tier_3","type":"hstack","children":["retail_1","retail_2","retail_3","retail_4"],"v_align":"center"}
{"id":"retail_1","type":"rect","width":25,"height":25,"background":"#E67E22"}
{"id":"retail_2","type":"rect","width":25,"height":25,"background":"#E74C3C"}
{"id":"retail_3","type":"rect","width":25,"height":25,"background":"#9B59B6"}
{"id":"retail_4","type":"rect","width":25,"height":25,"background":"#3498DB"}
{"id":"fd_plaza","type":"rect","width":200,"height":15,"background":"#BDC3C7"}

{"id":"tech_campus","type":"free_container","width":300,"height":250,"children":["campus_layout","innovation_labs","data_centers"],"x":500,"y":100}
{"id":"campus_layout","type":"vstack","children":["tech_buildings","tech_courtyard","parking_structure"],"h_align":"center","x":0,"y":0}
{"id":"tech_buildings","type":"hstack","children":["lab_a","lab_b","lab_c","lab_d"],"v_align":"bottom"}
{"id":"lab_a","type":"rect","width":40,"height":80,"background":"#1ABC9C"}
{"id":"lab_b","type":"rect","width":35,"height":70,"background":"#16A085"}
{"id":"lab_c","type":"rect","width":45,"height":85,"background":"#3498DB"}
{"id":"lab_d","type":"rect","width":38,"height":75,"background":"#2980B9"}
{"id":"tech_courtyard","type":"rect","width":180,"height":40,"background":"#2ECC71"}
{"id":"parking_structure","type":"hstack","children":["parking_level_1","parking_level_2","parking_level_3"],"v_align":"center"}
{"id":"parking_level_1","type":"rect","width":50,"height":15,"background":"#95A5A6"}
{"id":"parking_level_2","type":"rect","width":50,"height":15,"background":"#7F8C8D"}
{"id":"parking_level_3","type":"rect","width":50,"height":15,"background":"#95A5A6"}
{"id":"innovation_labs","type":"polyline","points":[[0,0],[50,20],[100,10],[150,30],[200,15],[250,25],[300,20]],"stroke_color":"#E74C3C","stroke_width":3,"x":0,"y":50}
{"id":"data_centers","type":"vstack","children":["server_1","server_2"],"h_align":"right","x":220,"y":180}
{"id":"server_1","type":"rect","width":60,"height":30,"background":"#34495E"}
{"id":"server_2","type":"rect","width":60,"height":25,"background":"#2C3E50"}

{"id":"cultural_quarter","type":"free_container","width":280,"height":200,"children":["museums","theaters","galleries"],"x":900,"y":250}
{"id":"museums","type":"vstack","children":["museum_art","museum_history","museum_science"],"h_align":"left","x":0,"y":0}
{"id":"museum_art","type":"hstack","children":["art_wing_1","art_wing_2","art_central"],"v_align":"center"}
{"id":"art_wing_1","type":"rect","width":30,"height":40,"background":"#8E44AD"}
{"id":"art_wing_2","type":"rect","width":30,"height":40,"background":"#9B59B6"}
{"id":"art_central","type":"rect","width":50,"height":60,"background":"#663399"}
{"id":"museum_history","type":"rect","width":120,"height":35,"background":"#D35400"}
{"id":"museum_science","type":"hstack","children":["planetarium","exhibits","imax"],"v_align":"center"}
{"id":"planetarium","type":"rect","width":25,"height":25,"background":"#2C3E50"}
{"id":"exhibits","type":"rect","width":60,"height":30,"background":"#34495E"}
{"id":"imax","type":"rect","width":35,"height":28,"background":"#2C3E50"}
{"id":"theaters","type":"hstack","children":["opera_house","concert_hall"],"v_align":"bottom","x":140,"y":20}
{"id":"opera_house","type":"vstack","children":["opera_dome","opera_base"],"h_align":"center"}
{"id":"opera_dome","type":"rect","width":40,"height":20,"background":"#E67E22"}
{"id":"opera_base","type":"rect","width":60,"height":40,"background":"#D35400"}
{"id":"concert_hall","type":"rect","width":45,"height":70,"background":"#F39C12"}
{"id":"galleries","type":"polyline","points":[[0,150],[40,160],[80,150],[120,160],[160,150],[200,160],[240,150],[280,160]],"stroke_color":"#9B59B6","stroke_width":4,"x":0,"y":0}

{"id":"harbor","type":"free_container","width":400,"height":300,"children":["waterfront","docks","marina","lighthouse"],"x":1000,"y":600}
{"id":"waterfront","type":"rect","width":400,"height":300,"background":"#3498DB","x":0,"y":0}
{"id":"docks","type":"vstack","children":["pier_1","pier_2","pier_3"],"h_align":"left","x":20,"y":50}
{"id":"pier_1","type":"hstack","children":["dock_a","dock_b","dock_c"],"v_align":"center"}
{"id":"dock_a","type":"rect","width":60,"height":8,"background":"#8B4513"}
{"id":"dock_b","type":"rect","width":60,"height":8,"background":"#A0522D"}
{"id":"dock_c","type":"rect","width":60,"height":8,"background":"#8B4513"}
{"id":"pier_2","type":"rect","width":200,"height":10,"background":"#654321"}
{"id":"pier_3","type":"hstack","children":["slip_1","slip_2","slip_3","slip_4"],"v_align":"center"}
{"id":"slip_1","type":"rect","width":40,"height":6,"background":"#8B4513"}
{"id":"slip_2","type":"rect","width":40,"height":6,"background":"#A0522D"}
{"id":"slip_3","type":"rect","width":40,"height":6,"background":"#8B4513"}
{"id":"slip_4","type":"rect","width":40,"height":6,"background":"#A0522D"}
{"id":"marina","type":"polyline","points":[[50,200],[80,220],[120,210],[160,230],[200,220],[240,240],[280,230]],"stroke_color":"white","stroke_width":2,"x":0,"y":0}
{"id":"lighthouse","type":"vstack","children":["lighthouse_base","lighthouse_tower","lighthouse_light"],"h_align":"center","x":350,"y":180}
{"id":"lighthouse_base","type":"rect","width":20,"height":30,"background":"#E74C3C"}
{"id":"lighthouse_tower","type":"rect","width":12,"height":60,"background":"white"}
{"id":"lighthouse_light","type":"rect","width":16,"height":8,"background":"#F1C40F"}

{"id":"mountain_range","type":"polyline","points":[[0,0],[100,50],[200,20],[300,80],[400,30],[500,90],[600,40],[700,100],[800,50],[900,110],[1000,60],[1100,120],[1200,70],[1300,130],[1400,80]],"stroke_color":"#7D6E3E","stroke_width":30,"x":0,"y":0}

{"id":"sky_bridges","type":"free_container","width":1400,"height":900,"children":["bridge_network","aerial_walkways"],"x":0,"y":0}
{"id":"bridge_network","type":"hstack","children":["sky_bridge_1","sky_bridge_2","sky_bridge_3"],"v_align":"center","x":100,"y":150}
{"id":"sky_bridge_1","type":"polyline","points":[[0,0],[150,10],[300,0]],"stroke_color":"#BDC3C7","stroke_width":4,"x":0,"y":0}
{"id":"sky_bridge_2","type":"polyline","points":[[0,0],[200,15],[400,0]],"stroke_color":"#95A5A6","stroke_width":4,"x":0,"y":0}
{"id":"sky_bridge_3","type":"polyline","points":[[0,0],[180,8],[360,0]],"stroke_color":"#BDC3C7","stroke_width":4,"x":0,"y":0}
{"id":"aerial_walkways","type":"vstack","children":["walkway_level_1","walkway_level_2"],"h_align":"center","x":600,"y":100}
{"id":"walkway_level_1","type":"polyline","points":[[0,0],[100,5],[200,0],[300,5],[400,0]],"stroke_color":"#ECF0F1","stroke_width":3,"x":0,"y":0}
{"id":"walkway_level_2","type":"polyline","points":[[50,0],[150,8],[250,0],[350,8],[450,0]],"stroke_color":"#BDC3C7","stroke_width":3,"x":0,"y":0}

{"id":"monorail","type":"polyline","points":[[0,350],[200,355],[400,350],[600,355],[800,350],[1000,355],[1200,350],[1400,355]],"stroke_color":"#2C3E50","stroke_width":8,"x":0,"y":0}

{"id":"shopping_centers","type":"free_container","width":600,"height":400,"children":["mall_complex","outdoor_plaza","market_district"],"x":250,"y":500}
{"id":"mall_complex","type":"vstack","children":["mall_upper","mall_main","mall_food_court"],"h_align":"center","x":0,"y":0}
{"id":"mall_upper","type":"hstack","children":["store_1","store_2","store_3","store_4","store_5"],"v_align":"center"}
{"id":"store_1","type":"rect","width":40,"height":30,"background":"#E91E63"}
{"id":"store_2","type":"rect","width":35,"height":30,"background":"#9C27B0"}
{"id":"store_3","type":"rect","width":45,"height":30,"background":"#673AB7"}
{"id":"store_4","type":"rect","width":38,"height":30,"background":"#3F51B5"}
{"id":"store_5","type":"rect","width":42,"height":30,"background":"#2196F3"}
{"id":"mall_main","type":"rect","width":250,"height":40,"background":"#F5F5F5"}
{"id":"mall_food_court","type":"hstack","children":["restaurant_1","restaurant_2","restaurant_3","seating"],"v_align":"center"}
{"id":"restaurant_1","type":"rect","width":50,"height":25,"background":"#FF5722"}
{"id":"restaurant_2","type":"rect","width":45,"height":25,"background":"#FF9800"}
{"id":"restaurant_3","type":"rect","width":40,"height":25,"background":"#FFC107"}
{"id":"seating","type":"rect","width":80,"height":25,"background":"#FFEB3B"}
{"id":"outdoor_plaza","type":"free_container","width":200,"height":150,"children":["plaza_fountains","plaza_vendors"],"x":300,"y":50}
{"id":"plaza_fountains","type":"vstack","children":["fountain_main","fountain_small_1","fountain_small_2"],"h_align":"center","x":50,"y":20}
{"id":"fountain_main","type":"rect","width":30,"height":30,"background":"#00BCD4"}
{"id":"fountain_small_1","type":"rect","width":15,"height":15,"background":"#26C6DA"}
{"id":"fountain_small_2","type":"rect","width":15,"height":15,"background":"#26C6DA"}
{"id":"plaza_vendors","type":"hstack","children":["vendor_1","vendor_2","vendor_3"],"v_align":"center","x":20,"y":100}
{"id":"vendor_1","type":"rect","width":25,"height":15,"background":"#4CAF50"}
{"id":"vendor_2","type":"rect","width":25,"height":15,"background":"#8BC34A"}
{"id":"vendor_3","type":"rect","width":25,"height":15,"background":"#CDDC39"}
{"id":"market_district","type":"polyline","points":[[400,200],[450,220],[500,200],[550,220],[600,200]],"stroke_color":"#795548","stroke_width":6,"x":0,"y":0}"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("intricate_city.svg"), "Ciudad Intrincada")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}

===/src/bin/custom_components.rs===
// src/bin/custom_component_demo.rs
// Demo program showing how to register and use custom components

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::{fmt::format, fs::File};
use volare_engine_layout::*;

// Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

/// Custom Component 1: Badge
/// Creates a rounded pill-shaped element with text
fn create_badge_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("🏷️  Creating badge component with attrs: {:?}", attrs);

    // Extract attributes
    let text = get_string_attr(attrs, "text", "Badge");
    let background = get_string_attr(attrs, "background", "blue");
    let color = get_string_attr(attrs, "color", "white");
    let font_size = get_float_attr(attrs, "font_size", 12.0);
    let padding = get_float_attr(attrs, "padding", 8.0);

    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        id =  uuid::Uuid::new_v4().to_string()
    }

    // Create text element
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size,
        text_color: color,
        line_width: 200,
        line_spacing: 0.0,
    };
    let text_node = builder.new_text(
        format!("{}_text", id),
        &text, text_options);

    // Wrap in rounded box
    let box_options = BoxOptions {
        fill_color: Fill::Color(background),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding,
        border_radius: font_size,               // Make it pill-shaped
        width_behavior: SizeBehavior::Content,  // Auto width based on text
        height_behavior: SizeBehavior::Content, // Auto height based on text
    };
    let badge = builder.new_box(
        id,
        text_node, box_options);

    println!("✅ Badge '{}' created successfully", text);
    Ok(badge)
}

/// Custom Component 2: Alert Box
/// Creates an alert with optional icon, title, and message
fn create_alert_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("⚠️  Creating alert component with attrs: {:?}", attrs);

    let alert_type = get_string_attr(attrs, "alert-type", "info");
    let title = get_string_attr(attrs, "title", "Alert");
    let message = get_string_attr(attrs, "message", "Alert message");
    let width = get_float_attr(attrs, "width", 300.0);
    let show_icon = get_bool_attr(attrs, "show_icon", true);
    let mut id = get_string_attr(attrs, "id", "");

    if id.is_empty() {
        id = uuid::Uuid::new_v4().to_string()
    }

    //TODO aqui seria util tener
    // let context = builder.CreateComponentContext(id)
    // y todos los elems internos les asigna prefijo el id
    // util para no tener que concatenarlos

    // Define alert styles
    let (bg_color, border_color, icon) = match alert_type.as_str() {
        "success" => ("#d4edda", "#28a745", "✓"),
        "warning" => ("#fff3cd", "#ffc107", "⚠"),
        "error" => ("#f8d7da", "#dc3545", "✗"),
        "info" | _ => ("#d1ecf1", "#17a2b8", "ℹ"),
    };

    let mut children = Vec::new();

    // Create header with optional icon
    if show_icon {
        let icon_text = builder.new_text(
            format!("{}_showicon", id),
            icon,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: border_color.to_string(),
                line_width: 50,
                line_spacing: 0.0,
            },
        );

        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#333".to_string(),
                line_width: (width - 50.0) as usize,
                line_spacing: 0.0,
            },
        );

        let header = builder.new_hstack(
            format!("{}_header", id),
            vec![icon_text, title_text],
            VerticalAlignment::Center,
        );
        children.push(header);
    } else {
        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#333".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add message
    let message_text = builder.new_text(
        format!("{}_addmsg", id),
        &message,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666".to_string(),
            line_width: width as usize,
            line_spacing: 2.0,
        },
    );
    children.push(message_text);

    // Create vertical layout
    let content = builder.new_vstack(
        format!("{}_contentstack", id),
        children,
        HorizontalAlignment::Left,
    );

    // Wrap in styled box
    let alert_box = builder.new_box(
        id,
        content,
        BoxOptions {
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            padding: 16.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Content, // Auto height based on content
        },
    );

    println!("✅ Alert '{}' ({}) created successfully", title, alert_type);
    Ok(alert_box)
}

/// Custom Component 3: Progress Bar
/// Creates a progress bar with background and fill
fn create_progress_bar_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("📊 Creating progress bar component with attrs: {:?}", attrs);

    let width = get_float_attr(attrs, "width", 200.0);
    let height = get_float_attr(attrs, "height", 20.0);
    let progress = get_float_attr(attrs, "progress", 0.5).min(1.0).max(0.0);
    let bg_color = get_string_attr(attrs, "bg_color", "lightgray");
    let fill_color = get_string_attr(attrs, "fill_color", "blue");
    let show_text = get_bool_attr(attrs, "show_text", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        // Generate a unique ID if not provided
         id = format!("progress_bar_{}", uuid::Uuid::new_v4());
    }

    // Create background bar
    let bg_rect = builder.new_rectangle(
        format!("bg_{}", id),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(height),
            fill_color: Fill::Color(bg_color),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            border_radius: height / 2.0,
        },
    );

    // Create progress fill
    let fill_width = width * progress;
    let fill_rect = builder.new_rectangle(
        format!("fill_{}", id),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(fill_width),
            height_behavior: SizeBehavior::Fixed(height),
            fill_color: Fill::Color(fill_color),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            border_radius: height / 2.0,
        },
    );

    let mut elements = vec![(bg_rect, (0.0, 0.0)), (fill_rect, (0.0, 0.0))];

    // Add percentage text if requested
    if show_text {
        let percentage = (progress * 100.0) as i32;
        let text_node = builder.new_text(
            format!("text_{}", id),
            &format!("{}%", percentage),
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: height * 0.7,
                text_color: "black".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        // Center the text roughly
        let text_x = (width - 30.0) / 2.0; // Rough centering
        let text_y = height * 0.15;
        elements.push((text_node, (text_x, text_y)));
    }

    let progress_bar = builder.new_free_container(id.to_string(), elements);

    println!(
        "✅ Progress bar ({}%) created successfully",
        (progress * 100.0) as i32
    );
    Ok(progress_bar)
}

/// Custom Component 4: Button
/// Creates a clickable button with text
fn create_button_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("🔘 Creating button component with attrs: {:?}", attrs);

    let text = get_string_attr(attrs, "text", "Button");
    let variant = get_string_attr(attrs, "variant", "primary");
    let size = get_string_attr(attrs, "size", "medium");
    let disabled = get_bool_attr(attrs, "disabled", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("button_{}", uuid::Uuid::new_v4());
    }

    // Define button styles based on variant
    let (bg_color, text_color, border_color) = if disabled {
        ("#cccccc", "#666666", "#999999")
    } else {
        match variant.as_str() {
            "primary" => ("#007bff", "white", "#0056b3"),
            "secondary" => ("#6c757d", "white", "#545b62"),
            "success" => ("#28a745", "white", "#1e7e34"),
            "danger" => ("#dc3545", "white", "#bd2130"),
            "warning" => ("#ffc107", "#212529", "#d39e00"),
            _ => ("#007bff", "white", "#0056b3"),
        }
    };

    // Define size-based properties
    let (font_size, padding_x, padding_y) = match size.as_str() {
        "small" => (12.0, 12.0, 6.0),
        "large" => (18.0, 24.0, 12.0),
        _ => (14.0, 16.0, 8.0), // medium
    };

    // Create button text
    let button_text = builder.new_text(
        format!("{}-{}", id, text),
        &text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size,
            text_color: text_color.to_string(),
            line_width: 200,
            line_spacing: 0.0,
        },
    );

    // Wrap in styled box
    let button = builder.new_box(
        format!("button_{}", id),
        button_text,
        BoxOptions {
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            padding: f32::max(padding_x, padding_y), // Use max for uniform padding
            border_radius: 4.0,
            width_behavior: SizeBehavior::Content, // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
        },
    );

    println!(
        "✅ Button '{}' ({}, {}) created successfully",
        text, variant, size
    );
    Ok(button)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 Custom Component Demo Starting...\n");

    // Create diagram builder and set text measurement function
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all our custom components
    println!("📝 Registering custom components...");
    builder.register_custom_component("badge", create_badge_component);
    builder.register_custom_component("alert", create_alert_component);
    builder.register_custom_component("progress_bar", create_progress_bar_component);
    builder.register_custom_component("button", create_button_component);
    println!("✅ All custom components registered!\n");

    // Demo 1: Direct usage with Rust API
    println!("=== Demo 1: Direct Rust API Usage ===");

    // Create components directly
    let badge_attrs = json!({
        "text": "NEW",
        "background": "red",
        "color": "white",
        "font_size": 14.0,
        "padding": 10.0
    })
    .as_object()
    .unwrap()
    .clone();

    let _badge = builder.create_custom_component("badge", &badge_attrs)?;

    let alert_attrs = json!({
        "type": "success",
        "title": "Success!",
        "message": "Your custom component system is working perfectly!",
        "width": 400.0,
        "show_icon": true
    })
    .as_object()
    .unwrap()
    .clone();

    let _alert = builder.create_custom_component("alert", &alert_attrs)?;

    println!("✅ Direct API usage successful!\n");

    // Demo 2: JSON Lines usage
    println!("=== Demo 2: JSON Lines Usage ===");

    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","demo_section","buttons_section","progress_section","alerts_section"],"h_align":"center"}
{"id":"title","type":"text","content":"🎨 Custom Components Showcase","font_size":25,"color":"darkblue"}
{"id":"demo_section","type":"hstack","children":["badge1","badge2","badge3"],"v_align":"center"}
{"id":"badge1","type":"badge","text":"NEW","background":"#ff4444","color":"white","font_size":12,"padding":8}
{"id":"badge2","type":"badge","text":"SALE","background":"#44ff44","color":"black","font_size":12,"padding":8}
{"id":"badge3","type":"badge","text":"HOT","background":"#ff8800","color":"white","font_size":12,"padding":8}
{"id":"buttons_section","type":"hstack","children":["btn1","btn2","btn3","btn4"],"v_align":"center"}
{"id":"btn1","type":"button","text":"Primary","variant":"primary","size":"medium"}
{"id":"btn2","type":"button","text":"Success","variant":"success","size":"medium"}
{"id":"btn3","type":"button","text":"Warning","variant":"warning","size":"medium"}
{"id":"btn4","type":"button","text":"Disabled","variant":"secondary","size":"medium","disabled":true}
{"id":"progress_section","type":"vstack","children":["progress1","progress2","progress3"],"h_align":"center"}
{"id":"progress1","type":"progress_bar","width":300,"height":20,"progress":0.25,"fill_color":"#ff4444","show_text":true}
{"id":"progress2","type":"progress_bar","width":300,"height":20,"progress":0.65,"fill_color":"#44ff44","show_text":true}
{"id":"progress3","type":"progress_bar","width":300,"height":20,"progress":0.90,"fill_color":"#4444ff","show_text":true}
{"id":"alerts_section","type":"vstack","children":["alert1","alert2","alert3","alert4"],"h_align":"left"}
{"id":"alert1","type":"alert","alert-type":"success","title":"Success Alert","message":"Everything is working perfectly! Your custom components are rendering correctly.","width":500,"show_icon":true}
{"id":"alert2","type":"alert","alert-type":"warning","title":"Warning Alert","message":"This is a warning message to demonstrate the warning alert style.","width":500,"show_icon":true}
{"id":"alert3","type":"alert","alert-type":"error","title":"Error Alert","message":"This shows how error messages would appear in your application.","width":500,"show_icon":true}
{"id":"alert4","type":"alert","alert-type":"info","title":"Info Alert","message":"Here's some informational content using the info alert component.","width":500,"show_icon":true}
"##;

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components with the parse builder
    parse_builder.register_custom_component("badge", create_badge_component);
    parse_builder.register_custom_component("alert", create_alert_component);
    parse_builder.register_custom_component("progress_bar", create_progress_bar_component);
    parse_builder.register_custom_component("button", create_button_component);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    println!("✅ JSON Lines parsing successful!");

    // Calculate layout
    println!("📐 Calculating layout...");
    layout::layout_tree_node(&mut parse_builder, &diagram);
    println!("✅ Layout calculation complete!");

    // Demo 3: Render to SVG
    println!("\n=== Demo 3: SVG Rendering ===");

    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("custom-components-showcase.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("✅ SVG rendered successfully!");
    println!("📄 File saved to: {}", svg_path.to_str().unwrap());

    // Demo 4: Statistics
    println!("\n=== Demo 4: Component Statistics ===");
    let registered_types = parse_builder.get_custom_component_types();
    println!("📊 Registered custom components: {:?}", registered_types);
    println!("🔢 Total custom components: {}", registered_types.len());

    // Count components in the diagram
    fn count_custom_components(
        node: &diagram_builder::DiagramTreeNode,
        types: &[&String],
    ) -> usize {
        let mut count = 0;
        if types
            .iter()
            .any(|t| t.as_str() == format!("{:?}", node.entity_type))
        {
            count += 1;
        }
        for child in &node.children {
            count += count_custom_components(child, types);
        }
        count
    }

    let custom_count = count_custom_components(&diagram, &registered_types);
    println!("🎯 Custom components in diagram: {}", custom_count);

    println!("\n🎉 Custom Component Demo Complete!");
    println!("💡 Check the generated SVG file to see your custom components in action!");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);
        builder.register_custom_component("alert", create_alert_component);
        builder.register_custom_component("progress_bar", create_progress_bar_component);
        builder.register_custom_component("button", create_button_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 4);
        assert!(builder.has_custom_component("badge"));
        assert!(builder.has_custom_component("alert"));
        assert!(builder.has_custom_component("progress_bar"));
        assert!(builder.has_custom_component("button"));
    }

    #[test]
    fn test_jsonl_with_custom_components() {
        let input = r#"
{"id":"root","type":"badge","text":"Test Badge","background":"red"}
"#;

        let mut parser = parser::JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let result = parser.build(&root_id, &mut builder);
        assert!(result.is_ok());
    }
}

===/src/bin/visual_experiments.rs===
// src/bin/visual_experiments.rs
// Demo program that generates SVGs for visual experiments using JSONL format

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🎨 Generando Experimentos Visuales...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("visual_experiments");
    std::fs::create_dir_all(&output_dir)?;

    // 🎯 Experimentos de Animación/Progresión
    println!("=== 🎯 Experimentos de Animación/Progresión ===");
    
    // 1. Construcción de Edificio
    generate_building_construction(&output_dir)?;
    
    // 2. Crecimiento de Árbol
    generate_tree_growth(&output_dir)?;

    // 📊 Visualización de Datos en Tiempo Real
    println!("\n=== 📊 Visualización de Datos ===");
    
    // 3. Dashboard Financiero
    generate_financial_dashboard(&output_dir)?;
    
    // 4. Monitor de Sistema
    generate_system_monitor(&output_dir)?;

    // 🎮 Interfaces Interactivas
    println!("\n=== 🎮 Interfaces Interactivas ===");
    
    // 5. Panel de Control Espacial
    generate_space_control_panel(&output_dir)?;
    
    // 6. Simulador de Tráfico
    generate_traffic_simulator(&output_dir)?;

    // 🧬 Simulaciones Científicas
    println!("\n=== 🧬 Simulaciones Científicas ===");
    
    // 7. Modelo Molecular
    generate_molecular_model(&output_dir)?;
    
    // 8. Sistema Solar
    generate_solar_system(&output_dir)?;

    // 🎨 Arte Generativo
    println!("\n=== 🎨 Arte Generativo ===");
    
    // 9. Patrón Fractal Simple
    generate_fractal_pattern(&output_dir)?;
    
    // 10. Mandala Geométrico
    generate_geometric_mandala(&output_dir)?;

    println!("\n✅ Todos los experimentos generados exitosamente!");
    println!("📁 Archivos guardados en: {}", output_dir.display());

    Ok(())
}

// 1. Construcción de Edificio
fn generate_building_construction(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":400,"children":["ground","floor1","floor2","floor3","roof","window1","window2"]}
{"id":"ground","type":"rect","width":400,"height":20,"background":"brown","x":0,"y":380}
{"id":"floor1","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":320}
{"id":"floor2","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":260}
{"id":"floor3","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":200}
{"id":"roof","type":"polyline","points":[[100,200],[150,150],[250,150],[300,200]],"stroke_color":"red","x":0,"y":0}
{"id":"window1","type":"rect","width":20,"height":30,"background":"lightblue","x":120,"y":340}
{"id":"window2","type":"rect","width":20,"height":30,"background":"lightblue","x":160,"y":340}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_building_construction.svg"), "Construcción de Edificio")
}

// 2. Crecimiento de Árbol

fn generate_tree_growth(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
   // 2. Crecimiento de Árbol
 let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":300,"children":["trunk","branch1","branch2","leaf1","leaf2","apple1"]}
{"id":"trunk","type":"rect","width":20,"height":100,"background":"brown","x":190,"y":150}
{"id":"branch1","type":"line","start_x":200,"start_y":150,"end_x":170,"end_y":120,"stroke_color":"brown","stroke_width":3,"x":0,"y":0}
{"id":"branch2","type":"line","start_x":200,"start_y":150,"end_x":230,"end_y":120,"stroke_color":"brown","stroke_width":3,"x":0,"y":0}
{"id":"leaf1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"green","x":155,"y":105}
{"id":"leaf2","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"green","x":215,"y":105}
{"id":"apple1","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red","x":160,"y":125}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_tree_growth.svg"), "Crecimiento de Árbol")
}

// 3. Dashboard Financiero
fn generate_financial_dashboard(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["header","metrics","chart_area"],"h_align":"center"}
{"id":"header","type":"text","content":"📈 Financial Dashboard","font_size":24,"color":"darkblue"}
{"id":"metrics","type":"hstack","children":["revenue","profit","users"],"v_align":"center"}
{"id":"revenue","type":"vstack","children":["rev_icon","rev_value","rev_change"],"h_align":"center"}
{"id":"rev_icon","type":"text","content":"💰","font_size":20}
{"id":"rev_value","type":"text","content":"$125,430","font_size":18,"color":"#333"}
{"id":"rev_change","type":"text","content":"↗ +12.5%","font_size":12,"color":"green"}
{"id":"profit","type":"vstack","children":["prof_icon","prof_value","prof_change"],"h_align":"center"}
{"id":"prof_icon","type":"text","content":"📊","font_size":20}
{"id":"prof_value","type":"text","content":"$45,200","font_size":18,"color":"#333"}
{"id":"prof_change","type":"text","content":"↗ +8.2%","font_size":12,"color":"green"}
{"id":"users","type":"vstack","children":["user_icon","user_value","user_change"],"h_align":"center"}
{"id":"user_icon","type":"text","content":"👥","font_size":20}
{"id":"user_value","type":"text","content":"8,945","font_size":18,"color":"#333"}
{"id":"user_change","type":"text","content":"↘ -2.1%","font_size":12,"color":"red"}
{"id":"chart_area","type":"free_container","width":250,"height":120,"children":["bar1","bar2","bar3"]}
{"id":"bar1","type":"rect","width":30,"height":50,"background":"blue","x":50,"y":50}
{"id":"bar2","type":"rect","width":30,"height":75,"background":"green","x":100,"y":25}
{"id":"bar3","type":"rect","width":30,"height":40,"background":"red","x":150,"y":60}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_financial_dashboard.svg"), "Dashboard Financiero")
}

// 4. Monitor de Sistema
fn generate_system_monitor(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","cpu_section","memory_section","network_section"],"h_align":"left"}
{"id":"title","type":"text","content":"🖥️ System Monitor","font_size":20,"color":"#333"}
{"id":"cpu_section","type":"hstack","children":["cpu_label","cpu_container"],"v_align":"center"}
{"id":"cpu_label","type":"text","content":"CPU:","font_size":14}
{"id":"cpu_container","type":"free_container","width":210,"height":25,"children":["cpu_bg","cpu_fill","cpu_text"]}
{"id":"cpu_bg","type":"rect","width":200,"height":20,"background":"lightgray","x":5,"y":2}
{"id":"cpu_fill","type":"rect","width":150,"height":20,"background":"orange","x":5,"y":2}
{"id":"cpu_text","type":"text","content":"75%","font_size":12,"x":105,"y":12}
{"id":"memory_section","type":"hstack","children":["mem_label","mem_container"],"v_align":"center"}
{"id":"mem_label","type":"text","content":"Memory:","font_size":14}
{"id":"mem_container","type":"free_container","width":210,"height":25,"children":["mem_bg","mem_fill","mem_text"]}
{"id":"mem_bg","type":"rect","width":200,"height":20,"background":"lightgray","x":5,"y":2}
{"id":"mem_fill","type":"rect","width":90,"height":20,"background":"blue","x":5,"y":2}
{"id":"mem_text","type":"text","content":"45%","font_size":12,"x":105,"y":12}
{"id":"network_section","type":"hstack","children":["net_label","net_indicator"],"v_align":"center"}
{"id":"net_label","type":"text","content":"Network:","font_size":14}
{"id":"net_indicator","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"green"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_system_monitor.svg"), "Monitor de Sistema")
}

// 5. Panel de Control Espacial
fn generate_space_control_panel(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":250,"background":"black","border_color":"cyan","border_width":2,"children":["radar","blip1","blip2","status_panel"]}
{"id":"radar","type":"ellipse","cx":80,"cy":80,"rx":80,"ry":80,"fill":"darkgreen","stroke":"green","x":50,"y":50}
{"id":"blip1","type":"ellipse","cx":3,"cy":3,"rx":3,"ry":3,"fill":"red","x":120,"y":140}
{"id":"blip2","type":"ellipse","cx":3,"cy":3,"rx":3,"ry":3,"fill":"yellow","x":170,"y":160}
{"id":"status_panel","type":"vstack","children":["shields","energy","weapons"],"h_align":"left","x":250,"y":50}
{"id":"shields","type":"text","content":"🛡️ Shields: 85%","color":"cyan","font_size":12}
{"id":"energy","type":"text","content":"⚡ Energy: 92%","color":"yellow","font_size":12}
{"id":"weapons","type":"text","content":"🔫 Weapons: Online","color":"green","font_size":12}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("05_space_control_panel.svg"), "Panel de Control Espacial")
}

// 6. Simulador de Tráfico
fn generate_traffic_simulator(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":300,"background":"lightgray","children":["road_h","road_v","car1","car2","car3","traffic_light"]}
{"id":"road_h","type":"rect","width":400,"height":40,"background":"darkgray","x":0,"y":130}
{"id":"road_v","type":"rect","width":40,"height":300,"background":"darkgray","x":180,"y":0}
{"id":"car1","type":"rect","width":30,"height":15,"background":"red","x":50,"y":140}
{"id":"car2","type":"rect","width":30,"height":15,"background":"blue","x":320,"y":140}
{"id":"car3","type":"rect","width":15,"height":30,"background":"green","x":185,"y":50}
{"id":"traffic_light","type":"vstack","children":["red_light","yellow_light","green_light"],"h_align":"center","x":175,"y":110}
{"id":"red_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red"}
{"id":"yellow_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"gray"}
{"id":"green_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"gray"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("06_traffic_simulator.svg"), "Simulador de Tráfico")
}

// 7. Modelo Molecular
fn generate_molecular_model(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":300,"height":300,"children":["carbon1","hydrogen1","hydrogen2","oxygen1","bond1","bond2","bond3"]}
{"id":"carbon1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"gray","x":100,"y":100}
{"id":"hydrogen1","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"white","stroke":"black","x":150,"y":90}
{"id":"hydrogen2","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"white","stroke":"black","x":150,"y":110}
{"id":"oxygen1","type":"ellipse","cx":12,"cy":12,"rx":12,"ry":12,"fill":"red","x":200,"y":100}
{"id":"bond1","type":"line","start_x":115,"start_y":110,"end_x":150,"end_y":100,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"bond2","type":"line","start_x":115,"start_y":115,"end_x":150,"end_y":118,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"bond3","type":"line","start_x":130,"start_y":115,"end_x":200,"end_y":112,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("07_molecular_model.svg"), "Modelo Molecular")
}

// 8. Sistema Solar
fn generate_solar_system(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":500,"height":500,"background":"black","children":["sun","mercury_orbit","venus_orbit","earth_orbit","mercury","venus","earth","moon"]}
{"id":"sun","type":"ellipse","cx":25,"cy":25,"rx":25,"ry":25,"fill":"yellow","x":225,"y":225}
{"id":"mercury_orbit","type":"ellipse","cx":250,"cy":250,"rx":80,"ry":80,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"venus_orbit","type":"ellipse","cx":250,"cy":250,"rx":120,"ry":120,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"earth_orbit","type":"ellipse","cx":250,"cy":250,"rx":160,"ry":160,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"mercury","type":"ellipse","cx":4,"cy":4,"rx":4,"ry":4,"fill":"orange","x":320,"y":246}
{"id":"venus","type":"ellipse","cx":6,"cy":6,"rx":6,"ry":6,"fill":"yellow","x":360,"y":244}
{"id":"earth","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"blue","x":400,"y":242}
{"id":"moon","type":"ellipse","cx":2,"cy":2,"rx":2,"ry":2,"fill":"gray","x":415,"y":240}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("08_solar_system.svg"), "Sistema Solar")
}

// 9. Patrón Fractal Simple
fn generate_fractal_pattern(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":400,"children":["center","nw","ne","sw","se","nw_nw","nw_ne","nw_sw","nw_se"]}
{"id":"center","type":"rect","width":100,"height":100,"background":"blue","x":150,"y":150}
{"id":"nw","type":"rect","width":50,"height":50,"background":"lightblue","x":100,"y":100}
{"id":"ne","type":"rect","width":50,"height":50,"background":"lightblue","x":250,"y":100}
{"id":"sw","type":"rect","width":50,"height":50,"background":"lightblue","x":100,"y":250}
{"id":"se","type":"rect","width":50,"height":50,"background":"lightblue","x":250,"y":250}
{"id":"nw_nw","type":"rect","width":25,"height":25,"background":"cyan","x":75,"y":75}
{"id":"nw_ne","type":"rect","width":25,"height":25,"background":"cyan","x":125,"y":75}
{"id":"nw_sw","type":"rect","width":25,"height":25,"background":"cyan","x":75,"y":125}
{"id":"nw_se","type":"rect","width":25,"height":25,"background":"cyan","x":125,"y":125}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("09_fractal_pattern.svg"), "Patrón Fractal Simple")
}

// 10. Mandala Geométrico
fn generate_geometric_mandala(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":300,"height":300,"children":["center_circle","ring1_1","ring1_2","ring1_3","ring1_4","ring1_5","ring1_6"]}
{"id":"center_circle","type":"ellipse","cx":20,"cy":20,"rx":20,"ry":20,"fill":"purple","x":130,"y":130}
{"id":"ring1_1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":135,"y":80}
{"id":"ring1_2","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":185,"y":105}
{"id":"ring1_3","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":185,"y":155}
{"id":"ring1_4","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":135,"y":180}
{"id":"ring1_5","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":85,"y":155}
{"id":"ring1_6","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":85,"y":105}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("10_geometric_mandala.svg"), "Mandala Geométrico")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/bin/constraints.rs===
// src/bin/intricate_city.rs
// Demo program that generates an intricate city using only polylines, rects, and free containers

use demo::measure_text::measure_text_svg_character_advance;
use resvg::usvg::roxmltree::Children;
use uuid::fmt::Simple;
use volare_engine_layout::diagram_builder::DiagramTreeNode;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Cassowary constraints demo...\n");
    let mut builder = DiagramBuilder::new();
    let output_dir = std::env::temp_dir().join("constraints_demo");
    std::fs::create_dir_all(&output_dir)?;
    let output_path = output_dir.join("constraints1.svg");
    builder.set_measure_text_fn(measure_text_svg_character_advance);
    let children = vec![builder.new_rectangle(
        "r1".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("red".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    ),
    builder.new_rectangle(
        "r2".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    ),
    builder.new_rectangle(
        "r3".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("green".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    ),
      builder.new_rectangle(
        "r4".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("purple".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    )
    ];

    let mut children_with_pos: Vec<(DiagramTreeNode, Option<Point>)>= children.iter().map(|c| {
        (c.clone(), None)
    }).collect();

     if let Some(elem) = children_with_pos.get_mut(0) {
        elem.1  = Some(Point::new(0.0, 0.0))
     }

    builder.set_position("r1".to_string(), 50.0, 50.0);

    let mut constraints = Vec::<SimpleConstraint>::new();
    // R1 should be set to the right of r2
    constraints.push(SimpleConstraint::RightOf("r1".into(), "r2".into()));
    constraints.push(SimpleConstraint::Below("r3".into(), "r2".into()));
    constraints.push(SimpleConstraint::Above("r4".into(), "r1".into()));
    constraints.push(SimpleConstraint::RightOf("r1".into(), "r4".into()));
    let root = builder.new_constraint_layout_container("container".to_string(), children_with_pos, constraints);
    layout_tree_node(&mut builder, &root);
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&builder, &root, &mut svg_file)?;

    println!("    ✅ Guardado: {}",output_path.to_str().unwrap());
  

    Ok(())
}

===/src/bin/sample_components.rs===
// src/bin/useful_components_demo.rs
// A library of practical custom components for real-world usage

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::fs::File;
use volare_engine_layout::*;

// Helper functions for attribute extraction
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Vec<String> {
    attrs
        .get(key)
        .and_then(|v| v.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default()
}

/// Card Component - A flexible container with header, body, and footer
fn create_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let content = get_string_attr(attrs, "content", "");
    let footer = get_string_attr(attrs, "footer", "");
    let width = get_float_attr(attrs, "width", 300.0);
    let padding = get_float_attr(attrs, "padding", 16.0);
    let border_radius = get_float_attr(attrs, "border_radius", 8.0);
    let shadow = get_bool_attr(attrs, "shadow", true);
    let variant = get_string_attr(attrs, "variant", "default");

    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        id = uuid::Uuid::new_v4().to_string()
    }

    // Define card styles based on variant
    let (bg_color, border_color) = match variant.as_str() {
        "primary" => ("#ffffff", "#007bff"),
        "success" => ("#f8fff8", "#28a745"),
        "warning" => ("#fffdf0", "#ffc107"),
        "danger" => ("#fff8f8", "#dc3545"),
        _ => ("#ffffff", "#e0e0e0"),
    };

    let mut children = Vec::new();

    // Add title if provided
    if !title.is_empty() {
        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: "#333333".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_text = builder.new_text(
            format!("{}_subtitle", id),
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#666666".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_text);
    }

    // Add content if provided
    if !content.is_empty() {
        let content_text = builder.new_text(
            format!("{}_content", id),
            &content,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#444444".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 4.0,
            },
        );
        children.push(content_text);
    }

    // Add footer if provided
    if !footer.is_empty() {
        let footer_text = builder.new_text(
            format!("{}_footer", id),
            &footer,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#888888".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(footer_text);
    }

    // Create layout
    let content_stack = builder.new_vstack(
        format!("{}_contentstack", id),
        children, HorizontalAlignment::Left);

    // Apply shadow effect by creating multiple boxes
    if shadow {
        // Shadow box (slightly offset)
        let shadow_box = builder.new_box(
            format!("{}_shadowbox", id),
            content_stack,
            BoxOptions {
                fill_color: Fill::Color("#00000010".to_string()),
                stroke_color: "transparent".to_string(),
                stroke_width: 0.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );

        // Main card box
        let main_content = builder.new_rectangle(
            format!("{}_maincontent", id),
            RectOptions {
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            border_radius,
        });

        // Use free container to overlay them
        let card = builder.new_free_container(
            id, 
            vec![
            (shadow_box, (2.0, 2.0)),   // Shadow slightly offset
            (main_content, (0.0, 0.0)), // Main card on top
        ]);
        Ok(card)
    } else {
        let card = builder.new_box(
            id,
            content_stack,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: 1.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );
        Ok(card)
    }
}

/// List Component - Creates a styled list with bullets or numbers
fn create_list_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let list_type = get_string_attr(attrs, "list_type", "bullet"); // bullet, number, check
    let spacing = get_float_attr(attrs, "spacing", 4.0);
    let width = get_float_attr(attrs, "width", 300.0);
    let font_size = get_float_attr(attrs, "font_size", 14.0);
    let mut id = get_string_attr(attrs, "id", "");

    if id.is_empty(){
        id = uuid::Uuid::new_v4().to_string()
    }

    if items.is_empty() {
        return Err("List component requires 'items' array".to_string());
    }

    let mut list_children = Vec::new();

    for (index, item) in items.iter().enumerate() {
        // Create bullet/number
        let marker = match list_type.as_str() {
            "number" => format!("{}.", index + 1),
            "check" => "✓".to_string(),
            "arrow" => "→".to_string(),
            _ => "•".to_string(), // bullet
        };

        let marker_text = builder.new_text(
            format!("{}-marker", id),
            &marker,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#666666".to_string(),
                line_width: 30,
                line_spacing: 0.0,
            },
        );

        let item_text = builder.new_text(
            format!("{}_item_text", id),
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#333333".to_string(),
                line_width: (width - 40.0) as usize,
                line_spacing: 0.0,
            },
        );

        let list_item = builder.new_hstack(
            format!("list_items_{}", id),
            vec![marker_text, item_text], VerticalAlignment::Top);
        list_children.push(list_item);
    }

    let list = builder.new_vstack(
        format!("list_items_{}", id),
        list_children, HorizontalAlignment::Left);
    Ok(list)
}

/// Form Field Component - Creates labeled input-like elements
fn create_form_field_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let label = get_string_attr(attrs, "label", "Field");
    let placeholder = get_string_attr(attrs, "placeholder", "Enter value...");
    let field_type = get_string_attr(attrs, "field_type", "text"); // text, email, password, textarea
    let required = get_bool_attr(attrs, "required", false);
    let width = get_float_attr(attrs, "width", 250.0);
    let error = get_string_attr(attrs, "error", "");
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
         id = format!("form_field_{}", uuid::Uuid::new_v4());
    }

    let mut children = Vec::new();

    // Create label
    let label_text = if required {
        format!("{} *", label)
    } else {
        label
    };

    let label_node = builder.new_text(
        format!("label_{}", id),
        &label_text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: if required { "#333333" } else { "#666666" }.to_string(),
            line_width: width as usize,
            line_spacing: 0.0,
        },
    );
    children.push(label_node);

    // Create input field representation
    let field_height = match field_type.as_str() {
        "textarea" => 60.0,
        _ => 36.0,
    };

    let placeholder_text = builder.new_text(
        format!("placeholder_{}", id),
        &placeholder,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#999999".to_string(),
            line_width: (width - 24.0) as usize,
            line_spacing: 0.0,
        },
    );

    let input_field = builder.new_box(
        format!("input_field_{}", id),
        placeholder_text,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: if !error.is_empty() {
                "#dc3545"
            } else {
                "#cccccc"
            }
            .to_string(),
            stroke_width: 1.0,
            padding: 12.0,
            border_radius: 4.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(field_height),
        },
    );
    children.push(input_field);

    // Add error message if present
    if !error.is_empty() {
        let error_text = builder.new_text(
            format!("error_{}", id),
            &error,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#dc3545".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(error_text);
    }

    let form_field = builder.new_vstack(id.to_string(), children, HorizontalAlignment::Left);
    Ok(form_field)
}

/// Stats Card Component - Displays key metrics with icons
fn create_stats_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Metric");
    let value = get_string_attr(attrs, "value", "0");
    let change = get_string_attr(attrs, "change", "");
    let icon = get_string_attr(attrs, "icon", "📊");
    let trend = get_string_attr(attrs, "trend", "neutral"); // up, down, neutral
    let color = get_string_attr(attrs, "color", "#007bff");
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("stats_card_{}", uuid::Uuid::new_v4());
    }
    // Determine trend color and symbol
    let (trend_color, trend_symbol) = match trend.as_str() {
        "up" => ("#28a745", "↗"),
        "down" => ("#dc3545", "↘"),
        _ => ("#6c757d", "→"),
    };

    // Create icon
    let icon_text = builder.new_text(
        format!("icon_{}", id),
        &icon,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            text_color: color,
            line_width: 50,
            line_spacing: 0.0,
        },
    );

    // Create value and title section
    let value_text = builder.new_text(
        format!("value_{}", id),
        &value,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 28.0,
            text_color: "#333333".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let title_text = builder.new_text(
        format!("title_{}", id),
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666666".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let mut right_children = vec![value_text, title_text];

    // Add change indicator if provided
    if !change.is_empty() {
        let change_text = format!("{} {}", trend_symbol, change);
        let change_node = builder.new_text(
            "change_text".to_string(),
            &change_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: trend_color.to_string(),
                line_width: 150,
                line_spacing: 0.0,
            },
        );
        right_children.push(change_node);
    }

    let right_section = builder.new_vstack("right_section".to_string(), right_children, HorizontalAlignment::Left);
    let content = builder.new_hstack("stats_card_content".to_string(), vec![icon_text, right_section], VerticalAlignment::Center);

    let stats_card = builder.new_box(
        id,
        content,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: "#e0e0e0".to_string(),
            stroke_width: 1.0,
            padding: 20.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(300.0),
            height_behavior: SizeBehavior::Content,
        },
    );

    Ok(stats_card)
}

/// Navigation Menu Component - Creates a horizontal or vertical menu
fn create_nav_menu_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let orientation = get_string_attr(attrs, "orientation", "horizontal"); // horizontal, vertical
    let active_item = get_string_attr(attrs, "active_item", "");
    let style = get_string_attr(attrs, "style", "default"); // default, pills, tabs
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("nav_menu_{}", uuid::Uuid::new_v4());
    }

    if items.is_empty() {
        return Err("Navigation menu requires 'items' array".to_string());
    }

    let mut nav_children = Vec::new();

    for item in items.iter() {
        let is_active = item == &active_item;

        // Style based on state and style type
        let (bg_color, text_color, border_color) = match (is_active, style.as_str()) {
            (true, "pills") => ("#007bff", "#ffffff", "#007bff"),
            (false, "pills") => ("transparent", "#007bff", "transparent"),
            (true, "tabs") => ("#ffffff", "#007bff", "#007bff"),
            (false, "tabs") => ("transparent", "#666666", "#e0e0e0"),
            (true, _) => ("transparent", "#007bff", "transparent"),
            (false, _) => ("transparent", "#666666", "transparent"),
        };

        let nav_text = builder.new_text(
            format!("nav_text_{}_{}", item, id),
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: text_color.to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );

        let nav_item = builder.new_box(
            format!("nav_item_{}_{}", item, id),
            nav_text,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: if style == "tabs" { 1.0 } else { 0.0 },
                padding: 12.0,
                border_radius: if style == "pills" { 20.0 } else { 4.0 },
                width_behavior: SizeBehavior::Content,
                height_behavior: SizeBehavior::Content,
            },
        );

        nav_children.push(nav_item);
    }

    let nav_menu = match orientation.as_str() {
        "vertical" => builder.new_vstack(format!("nav_menu_{}_{}", id, orientation), nav_children, HorizontalAlignment::Left),
        _ => builder.new_hstack(format!("nav_menu_{}_{}", id, orientation), nav_children, VerticalAlignment::Center),
    };

    Ok(nav_menu)
}

/// Header Component - Creates page headers with optional breadcrumbs
fn create_header_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Page Title");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let breadcrumbs = get_array_attr(attrs, "breadcrumbs");
    let show_back = get_bool_attr(attrs, "show_back", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("header_{}", uuid::Uuid::new_v4());
    }


    let mut children = Vec::new();

    // Add breadcrumbs if provided
    if !breadcrumbs.is_empty() {
        let breadcrumb_text = breadcrumbs.join(" > ");
        let breadcrumb_node = builder.new_text(
            format!("breadcrumb_{}",id),
            &breadcrumb_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(breadcrumb_node);
    }

    // Add back button if requested
    if show_back {
        let back_text = builder.new_text(
            "back_button".to_string(),
            "← Back",
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#007bff".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        children.push(back_text);
    }

    // Add main title
    let title_node = builder.new_text(
        format!("title_{}", id),
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 32.0,
            text_color: "#333333".to_string(),
            line_width: 600,
            line_spacing: 0.0,
        },
    );
    children.push(title_node);

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_node = builder.new_text(
            format!("subtitle_{}", id),
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_node);
    }

    let header = builder.new_vstack("header".to_string(),children, HorizontalAlignment::Left);
    Ok(header)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 Useful Components Demo Starting...\n");

    // Create diagram builder and register components
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all useful components
    println!("📝 Registering useful components...");
    builder.register_custom_component("card", create_card_component);
    builder.register_custom_component("list", create_list_component);
    builder.register_custom_component("form_field", create_form_field_component);
    builder.register_custom_component("stats_card", create_stats_card_component);
    builder.register_custom_component("nav_menu", create_nav_menu_component);
    builder.register_custom_component("header", create_header_component);
    println!("✅ All useful components registered!\n");

    // The JSONL content - Real-world dashboard example
    let jsonl_input = r##"{"id":"root","type":"vstack","children":["main_header","nav","dashboard_content"],"h_align":"center"}
{"id":"main_header","type":"header","title":"Analytics Dashboard","subtitle":"Monitor your key metrics and performance indicators","breadcrumbs":["Home","Analytics","Dashboard"]}
{"id":"nav","type":"nav_menu","items":["Overview","Analytics","Reports","Settings"],"active_item":"Analytics","style":"tabs","orientation":"horizontal"}
{"id":"dashboard_content","type":"vstack","children":["stats_row","charts_row","recent_activity"],"h_align":"center"}
{"id":"stats_row","type":"hstack","children":["stats1","stats2","stats3","stats4"],"v_align":"top"}
{"id":"stats1","type":"stats_card","title":"Total Users","value":"12,345","change":"+12.5%","trend":"up","icon":"👥","color":"#007bff"}
{"id":"stats2","type":"stats_card","title":"Revenue","value":"$89,432","change":"+8.2%","trend":"up","icon":"💰","color":"#28a745"}
{"id":"stats3","type":"stats_card","title":"Orders","value":"1,234","change":"-2.1%","trend":"down","icon":"📦","color":"#ffc107"}
{"id":"stats4","type":"stats_card","title":"Conversion","value":"3.24%","change":"+0.8%","trend":"up","icon":"📈","color":"#17a2b8"}
{"id":"charts_row","type":"hstack","children":["performance_card","recent_orders_card"],"v_align":"top"}
{"id":"performance_card","type":"card","title":"Performance Metrics","content":"Your application performance has improved by 23% this month. Server response times are optimal and user engagement is at an all-time high.","footer":"Last updated: 2 minutes ago","width":400,"variant":"primary","shadow":true}
{"id":"recent_orders_card","type":"card","title":"Recent Orders","width":400,"variant":"default","shadow":true,"children":["orders_list"]}
{"id":"orders_list","type":"list","items":["Order #1234 - $299.99 - Processing","Order #1235 - $156.78 - Shipped","Order #1236 - $89.50 - Delivered","Order #1237 - $445.20 - Processing"],"list_type":"number","spacing":6,"width":350}
{"id":"recent_activity","type":"vstack","children":["activity_header","activity_content"],"h_align":"left"}
{"id":"activity_header","type":"text","content":"Recent Activity","font_size":20,"color":"#333333"}
{"id":"activity_content","type":"hstack","children":["activity_list","user_form"],"v_align":"top"}
{"id":"activity_list","type":"list","items":["User john.doe logged in","New order received (#1238)","Payment processed for order #1235","User jane.smith updated profile","System backup completed","New user registration: mike.wilson"],"list_type":"arrow","width":400,"font_size":13}
{"id":"user_form","type":"vstack","children":["form_title","name_field","email_field","message_field","submit_section"],"h_align":"left"}
{"id":"form_title","type":"text","content":"Quick Contact","font_size":18,"color":"#333333"}
{"id":"name_field","type":"form_field","label":"Full Name","placeholder":"Enter your full name","required":true,"width":300}
{"id":"email_field","type":"form_field","label":"Email Address","placeholder":"your.email@company.com","field_type":"email","required":true,"width":300}
{"id":"message_field","type":"form_field","label":"Message","placeholder":"Type your message here...","field_type":"textarea","width":300}
{"id":"submit_section","type":"card","content":"Form ready to submit","footer":"All fields are validated","width":300,"variant":"success"}"##;

    // Parse and build the diagram
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components
    parse_builder.register_custom_component("card", create_card_component);
    parse_builder.register_custom_component("list", create_list_component);
    parse_builder.register_custom_component("form_field", create_form_field_component);
    parse_builder.register_custom_component("stats_card", create_stats_card_component);
    parse_builder.register_custom_component("nav_menu", create_nav_menu_component);
    parse_builder.register_custom_component("header", create_header_component);

    // Build and layout
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("useful-components-dashboard.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("✅ Dashboard rendered successfully!");
    println!("📄 File saved to: {}", svg_path.to_str().unwrap());
    println!("\n🎉 Useful Components Demo Complete!");

    Ok(())
}

===/src/bin/text.rs===
// Create an SVG file with all supported elements

//import svg_renderer
// use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, LineOptions};
use demo::measure_text::{ measure_text_ultra_tight};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    TableOptions, TextOptions, Fill,
};
//import io modules to write to file
use std::fs::File;



fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
  
    session.set_measure_text_fn(measure_text_ultra_tight);

    let mut table_items = Vec::new();

    let thetext =  br#""Lorem ipsum dolor sit amet, consectetur adipiscing elit.
otra linea texto
otra mas...
It could also be compensating for the fact that pos includes
cumulative scaling from parent transforms, 
and you need to pass down the "base" position to child renderers.
The comment "Calculate absolute position without any scaling" suggests the goal is to get back to unscaled coordinates that the child rendering pipeline expects.""#;

    let textOpts =  TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "white".to_string(),  // white text
            line_spacing: 5.0,
        };

    let blue_text = session.new_text(
        "blue_text".to_string(),
        std::str::from_utf8(thetext).unwrap(),
       textOpts.clone(),
    );

   // debug_text_measurement(std::str::from_utf8(thetext).unwrap(), &textOpts.clone());


    let box_options = BoxOptions {
        fill_color: Fill::Color("#0000FF".to_string()),  // blue background
        stroke_color: "#000066".to_string(),  // dark blue border
        stroke_width: 1.0,
        //TODO: falta tener en cuenta padding al momento de hacer layout de elementos de box
        padding: 50.0,
        border_radius: 0.0,
        width_behavior: volare_engine_layout::SizeBehavior::Fixed(200.0), // fixed width
        height_behavior: volare_engine_layout::SizeBehavior::Content, // auto height
    };

    let box1 = session.new_box("box1".to_string(), blue_text, box_options);

    
    // Add the FreeContainer to the table
    // table_items.push(container_with_elements);

    table_items.push(box1);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 5;
    let table = session.new_table("text_table".to_string(), table_items, 5, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
  
    
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());
    

    // Render PNG
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

===/src/bin/arcs.rs===
// src/bin/arc_shapes_demo.rs
// Demo program showcasing Arc, Semicircle, and Quarter Circle shapes

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🌀 Arc Shapes Demo Starting...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("arc_shapes_demo");
    std::fs::create_dir_all(&output_dir)?;

    // Generate various arc shape demonstrations
    generate_basic_arcs_demo(&output_dir)?;
    generate_semicircles_demo(&output_dir)?;
    generate_quarter_circles_demo(&output_dir)?;
    generate_filled_arcs_demo(&output_dir)?;
    generate_complex_arc_patterns(&output_dir)?;
    generate_arc_dashboard(&output_dir)?;

    println!("\n✅ All arc shape demos generated successfully!");
    println!("📁 Files saved in: {}", output_dir.display());

    Ok(())
}

// Demo 1: Basic Arc Shapes
fn generate_basic_arcs_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","arcs_container"],"h_align":"center"}
{"id":"title","type":"text","content":"🌀 Basic Arc Shapes","font_size":24,"color":"darkblue"}
{"id":"arcs_container","type":"free_container","width":900,"height":400,"children":["arc_45","arc_90","arc_180","arc_270","arc_300","labels"]}
{"id":"arc_45","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":45,"stroke_color":"#ff4444","stroke_width":3,"x":80,"y":120}
{"id":"arc_90","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":90,"stroke_color":"#44ff44","stroke_width":3,"x":200,"y":120}
{"id":"arc_180","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":180,"stroke_color":"#4444ff","stroke_width":3,"x":320,"y":120}
{"id":"arc_270","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":270,"stroke_color":"#ff44ff","stroke_width":3,"x":440,"y":120}
{"id":"arc_300","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":300,"stroke_color":"#44ffff","stroke_width":3,"x":560,"y":120}
{"id":"labels","type":"vstack","children":["label_45","label_90","label_180","label_270","label_300"],"h_align":"left","x":50,"y":320}
{"id":"label_45","type":"text","content":"• 45° Arc (Red)","font_size":14,"color":"#ff4444"}
{"id":"label_90","type":"text","content":"• 90° Arc (Green)","font_size":14,"color":"#44ff44"}
{"id":"label_180","type":"text","content":"• 180° Arc (Blue)","font_size":14,"color":"#4444ff"}
{"id":"label_270","type":"text","content":"• 270° Arc (Magenta)","font_size":14,"color":"#ff44ff"}
{"id":"label_300","type":"text","content":"• 300° Arc (Cyan)","font_size":14,"color":"#44ffff"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_basic_arcs.svg"), "Basic Arc Shapes")
}

// Demo 2: Semicircles in Different Orientations
fn generate_semicircles_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","semicircles_layout"],"h_align":"center"}
{"id":"title","type":"text","content":"🔄 Semicircle Variations","font_size":24,"color":"darkgreen"}
{"id":"semicircles_layout","type":"free_container","width":600,"height":350,"children":["semi_up","semi_down","semi_left","semi_right","descriptions"]}
{"id":"semi_up","type":"semicircle","cx":150,"cy":150,"radius":50,"facing_up":true,"stroke_color":"#e74c3c","stroke_width":4,"filled":false,"x":0,"y":0}
{"id":"semi_down","type":"semicircle","cx":450,"cy":150,"radius":50,"facing_up":false,"stroke_color":"#3498db","stroke_width":4,"filled":false,"x":0,"y":0}
{"id":"semi_left","type":"arc","cx":150,"cy":300,"radius":50,"start_angle":90,"end_angle":270,"stroke_color":"#f39c12","stroke_width":4,"x":0,"y":0}
{"id":"semi_right","type":"arc","cx":450,"cy":300,"radius":50,"start_angle":270,"end_angle":90,"stroke_color":"#9b59b6","stroke_width":4,"x":0,"y":0}
{"id":"descriptions","type":"vstack","children":["desc1","desc2","desc3","desc4"],"h_align":"left","x":50,"y":50}
{"id":"desc1","type":"text","content":"Top Semicircle (0°-180°)","font_size":12,"color":"#e74c3c"}
{"id":"desc2","type":"text","content":"Bottom Semicircle (180°-360°)","font_size":12,"color":"#3498db"}
{"id":"desc3","type":"text","content":"Left Semicircle (90°-270°)","font_size":12,"color":"#f39c12"}
{"id":"desc4","type":"text","content":"Right Semicircle (270°-90°)","font_size":12,"color":"#9b59b6"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_semicircles.svg"), "Semicircle Variations")
}

// Demo 3: Quarter Circles in All Quadrants
fn generate_quarter_circles_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","quarters_container"],"h_align":"center"}
{"id":"title","type":"text","content":"📐 Quarter Circle Quadrants","font_size":24,"color":"darkorchid"}
{"id":"quarters_container","type":"free_container","width":400,"height":400,"children":["q1","q2","q3","q4","center_point","quadrant_labels"]}
{"id":"q1","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":1,"stroke_color":"#e74c3c","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"q2","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":2,"stroke_color":"#2ecc71","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"q3","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":3,"stroke_color":"#3498db","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"q4","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":4,"stroke_color":"#f39c12","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"center_point","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"black","x":195,"y":195}
{"id":"quadrant_labels","type":"vstack","children":["q1_label","q2_label","q3_label","q4_label"],"h_align":"left","x":50,"y":50}
{"id":"q1_label","type":"text","content":"Q1: Top-Right (0°-90°)","font_size":12,"color":"#e74c3c"}
{"id":"q2_label","type":"text","content":"Q2: Top-Left (90°-180°)","font_size":12,"color":"#2ecc71"}
{"id":"q3_label","type":"text","content":"Q3: Bottom-Left (180°-270°)","font_size":12,"color":"#3498db"}
{"id":"q4_label","type":"text","content":"Q4: Bottom-Right (270°-360°)","font_size":12,"color":"#f39c12"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_quarter_circles.svg"), "Quarter Circle Quadrants")
}

// Demo 4: Filled vs Unfilled Arcs
fn generate_filled_arcs_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","filled_comparison"],"h_align":"center"}
{"id":"title","type":"text","content":"🎨 Filled vs Unfilled Arcs","font_size":24,"color":"darkred"}
{"id":"filled_comparison","type":"hstack","children":["unfilled_section","filled_section"],"v_align":"center"}
{"id":"unfilled_section","type":"vstack","children":["unfilled_label","unfilled_arcs"],"h_align":"center"}
{"id":"unfilled_label","type":"text","content":"Outline Only","font_size":16,"color":"#333"}
{"id":"unfilled_arcs","type":"hstack","children":["arc_outline_1","arc_outline_2","arc_outline_3"],"v_align":"center"}
{"id":"arc_outline_1","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":90,"stroke_color":"#e74c3c","stroke_width":4,"filled":false}
{"id":"arc_outline_2","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":180,"stroke_color":"#3498db","stroke_width":4,"filled":false}
{"id":"arc_outline_3","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":270,"stroke_color":"#2ecc71","stroke_width":4,"filled":false}
{"id":"filled_section","type":"vstack","children":["filled_label","filled_arcs"],"h_align":"center"}
{"id":"filled_label","type":"text","content":"Filled Sectors","font_size":16,"color":"#333"}
{"id":"filled_arcs","type":"hstack","children":["arc_filled_1","arc_filled_2","arc_filled_3"],"v_align":"center"}
{"id":"arc_filled_1","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":90,"stroke_color":"#c0392b","stroke_width":2,"fill_color":"#e74c3c","filled":true}
{"id":"arc_filled_2","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":180,"stroke_color":"#2980b9","stroke_width":2,"fill_color":"#3498db","filled":true}
{"id":"arc_filled_3","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":270,"stroke_color":"#27ae60","stroke_width":2,"fill_color":"#2ecc71","filled":true}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_filled_arcs.svg"), "Filled vs Unfilled Arcs")
}

// Demo 5: Complex Arc Patterns
fn generate_complex_arc_patterns(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","patterns_container"],"h_align":"center"}
{"id":"title","type":"text","content":"🌟 Complex Arc Patterns","font_size":24,"color":"darkcyan"}
{"id":"patterns_container","type":"free_container","width":800,"height":500,"children":["flower_pattern","spiral_pattern","clock_pattern","legend"]}
{"id":"flower_pattern","type":"free_container","width":200,"height":200,"children":["petal1","petal2","petal3","petal4","petal5","petal6","flower_center"],"x":50,"y":50}
{"id":"petal1","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":0,"end_angle":60,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#fce4ec","filled":true}
{"id":"petal2","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":60,"end_angle":120,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#f8bbd9","filled":true}
{"id":"petal3","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":120,"end_angle":180,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#fce4ec","filled":true}
{"id":"petal4","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":180,"end_angle":240,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#f8bbd9","filled":true}
{"id":"petal5","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":240,"end_angle":300,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#fce4ec","filled":true}
{"id":"petal6","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":300,"end_angle":360,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#f8bbd9","filled":true}
{"id":"flower_center","type":"ellipse","cx":10,"cy":10,"rx":10,"ry":10,"fill":"#ffeb3b","stroke":"#ff9800","stroke_width":2,"x":90,"y":90}
{"id":"spiral_pattern","type":"free_container","width":200,"height":200,"children":["spiral1","spiral2","spiral3","spiral4","spiral5"],"x":300,"y":50}
{"id":"spiral1","type":"arc","cx":100,"cy":100,"radius":20,"start_angle":0,"end_angle":270,"stroke_color":"#9c27b0","stroke_width":6,"filled":false}
{"id":"spiral2","type":"arc","cx":100,"cy":100,"radius":35,"start_angle":45,"end_angle":315,"stroke_color":"#673ab7","stroke_width":5,"filled":false}
{"id":"spiral3","type":"arc","cx":100,"cy":100,"radius":50,"start_angle":90,"end_angle":360,"stroke_color":"#3f51b5","stroke_width":4,"filled":false}
{"id":"spiral4","type":"arc","cx":100,"cy":100,"radius":65,"start_angle":135,"end_angle":405,"stroke_color":"#2196f3","stroke_width":3,"filled":false}
{"id":"spiral5","type":"arc","cx":100,"cy":100,"radius":80,"start_angle":180,"end_angle":450,"stroke_color":"#03a9f4","stroke_width":2,"filled":false}
{"id":"clock_pattern","type":"free_container","width":200,"height":200,"children":["clock_12","clock_3","clock_6","clock_9","clock_center","hour_hand","minute_hand"],"x":550,"y":50}
{"id":"clock_12","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":1,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_3","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":4,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_6","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":3,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_9","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":2,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_center","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"#424242","x":92,"y":92}
{"id":"hour_hand","type":"line","start_x":100,"start_y":100,"end_x":100,"end_y":60,"stroke_color":"#212121","stroke_width":4,"x":0,"y":0}
{"id":"minute_hand","type":"line","start_x":100,"start_y":100,"end_x":130,"end_y":100,"stroke_color":"#424242","stroke_width":2,"x":0,"y":0}
{"id":"legend","type":"vstack","children":["flower_desc","spiral_desc","clock_desc"],"h_align":"left","x":50,"y":300}
{"id":"flower_desc","type":"text","content":"🌸 Flower Pattern: 6 filled arc petals (60° each)","font_size":14,"color":"#e91e63"}
{"id":"spiral_desc","type":"text","content":"🌀 Spiral Pattern: Concentric arcs with increasing radius","font_size":14,"color":"#9c27b0"}
{"id":"clock_desc","type":"text","content":"🕒 Clock Pattern: Quarter circles forming clock face","font_size":14,"color":"#795548"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("05_complex_patterns.svg"), "Complex Arc Patterns")
}

// Demo 6: Arc Dashboard with Various Metrics
fn generate_arc_dashboard(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["header","dashboard_content"],"h_align":"center"}
{"id":"header","type":"text","content":"📊 Arc-Based Dashboard","font_size":26,"color":"#2c3e50"}
{"id":"dashboard_content","type":"free_container","width":900,"height":600,"children":["progress_gauges","pie_charts","status_indicators","dashboard_labels"]}
{"id":"progress_gauges","type":"free_container","width":300,"height":200,"children":["gauge1_bg","gauge1_fill","gauge1_text","gauge2_bg","gauge2_fill","gauge2_text","gauge3_bg","gauge3_fill","gauge3_text"],"x":50,"y":50}
{"id":"gauge1_bg","type":"arc","cx":100,"cy":100,"radius":60,"start_angle":180,"end_angle":360,"stroke_color":"#ecf0f1","stroke_width":12,"filled":false}
{"id":"gauge1_fill","type":"arc","cx":100,"cy":100,"radius":60,"start_angle":180,"end_angle":288,"stroke_color":"#e74c3c","stroke_width":12,"filled":false}
{"id":"gauge1_text","type":"text","content":"CPU 60%","font_size":12,"color":"#2c3e50","x":75,"y":120}
{"id":"gauge2_bg","type":"arc","cx":100,"cy":250,"radius":60,"start_angle":180,"end_angle":360,"stroke_color":"#ecf0f1","stroke_width":12,"filled":false}
{"id":"gauge2_fill","type":"arc","cx":100,"cy":250,"radius":60,"start_angle":180,"end_angle":324,"stroke_color":"#f39c12","stroke_width":12,"filled":false}
{"id":"gauge2_text","type":"text","content":"RAM 80%","font_size":12,"color":"#2c3e50","x":75,"y":270}
{"id":"gauge3_bg","type":"arc","cx":250,"cy":175,"radius":60,"start_angle":180,"end_angle":360,"stroke_color":"#ecf0f1","stroke_width":12,"filled":false}
{"id":"gauge3_fill","type":"arc","cx":250,"cy":175,"radius":60,"start_angle":180,"end_angle":252,"stroke_color":"#27ae60","stroke_width":12,"filled":false}
{"id":"gauge3_text","type":"text","content":"Disk 40%","font_size":12,"color":"#2c3e50","x":225,"y":195}
{"id":"pie_charts","type":"free_container","width":250,"height":250,"children":["pie1_s1","pie1_s2","pie1_s3","pie1_s4","pie2_s1","pie2_s2","pie2_s3"],"x":400,"y":50}
{"id":"pie1_s1","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":0,"end_angle":144,"stroke_color":"#3498db","stroke_width":2,"fill_color":"#3498db","filled":true}
{"id":"pie1_s2","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":144,"end_angle":216,"stroke_color":"#e74c3c","stroke_width":2,"fill_color":"#e74c3c","filled":true}
{"id":"pie1_s3","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":216,"end_angle":288,"stroke_color":"#2ecc71","stroke_width":2,"fill_color":"#2ecc71","filled":true}
{"id":"pie1_s4","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":288,"end_angle":360,"stroke_color":"#f39c12","stroke_width":2,"fill_color":"#f39c12","filled":true}
{"id":"pie2_s1","type":"arc","cx":80,"cy":200,"radius":40,"start_angle":0,"end_angle":180,"stroke_color":"#9b59b6","stroke_width":2,"fill_color":"#9b59b6","filled":true}
{"id":"pie2_s2","type":"arc","cx":80,"cy":200,"radius":40,"start_angle":180,"end_angle":270,"stroke_color":"#1abc9c","stroke_width":2,"fill_color":"#1abc9c","filled":true}
{"id":"pie2_s3","type":"arc","cx":80,"cy":200,"radius":40,"start_angle":270,"end_angle":360,"stroke_color":"#e67e22","stroke_width":2,"fill_color":"#e67e22","filled":true}
{"id":"status_indicators","type":"free_container","width":200,"height":300,"children":["status1","status2","status3","status4"],"x":700,"y":50}
{"id":"status1","type":"arc","cx":50,"cy":50,"radius":30,"start_angle":0,"end_angle":90,"stroke_color":"#27ae60","stroke_width":8,"filled":false}
{"id":"status2","type":"arc","cx":150,"cy":50,"radius":30,"start_angle":0,"end_angle":180,"stroke_color":"#f39c12","stroke_width":8,"filled":false}
{"id":"status3","type":"arc","cx":50,"cy":150,"radius":30,"start_angle":0,"end_angle":270,"stroke_color":"#e74c3c","stroke_width":8,"filled":false}
{"id":"status4","type":"arc","cx":150,"cy":150,"radius":30,"start_angle":0,"end_angle":360,"stroke_color":"#8e44ad","stroke_width":8,"filled":false}
{"id":"dashboard_labels","type":"vstack","children":["gauges_label","pie_label","status_label"],"h_align":"left","x":50,"y":400}
{"id":"gauges_label","type":"text","content":"📈 Progress Gauges: System resource usage","font_size":16,"color":"#34495e"}
{"id":"pie_label","type":"text","content":"🍰 Pie Charts: Data distribution visualization","font_size":16,"color":"#34495e"}
{"id":"status_label","type":"text","content":"🔄 Status Indicators: Service availability levels","font_size":16,"color":"#34495e"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("06_arc_dashboard.svg"), "Arc-Based Dashboard")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generating: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Saved: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/lib.rs===
pub mod measure_text; 

===/src/text_renderer_comparison.rs===
// Text Renderer Comparison Test
// This file demonstrates the differences in text positioning and spacing
// between the SVG and PNG renderers

// use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{
    renderer_base::Renderer,
    BoxOptions,
    TextOptions,
    Fill,
    DiagramBuilder,
    layout::layout_tree_node,
};

// Import measurement function
use crate::measure_text::measure_text;
use std::fs::File;

pub fn run_comparison_test() -> Result<(), Box<dyn std::error::Error>> {
    // Create session
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(measure_text);

    // Create options for the test
    let title_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 18.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let regular_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 14.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let small_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 12.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let box_options = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 0.0,
    };

    let box_options_no_padding = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 0.0,
        border_radius: 0.0,
    };

    // Create title
    let title = session.new_text(
        "Text Rendering Comparison",
        title_text_options,
    );

    // Create a simple single-line text
    let single_line_text = session.new_text(
        "This is a single line of text.",
        regular_text_options.clone(),
    );
    
    // Create a simple single-line text with a box around it
    let single_line_text_boxed = session.new_text(
        "This is a single line with a box.",
        regular_text_options.clone(),
    );
    let single_line_box = session.new_box(single_line_text_boxed, box_options.clone());

    // Create a simple single-line text with a box around it (no padding)
    let single_line_text_boxed_no_padding = session.new_text(
        "Single line box without padding.",
        regular_text_options.clone(),
    );
    let single_line_box_no_padding = session.new_box(single_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Create a multi-line text example
    let multi_line_text = session.new_text(
        "This is a multi-line text example.\nSecond line of text.\nThird line for testing purposes.",
        regular_text_options.clone(),
    );

    // Create a multi-line text with a box around it
    let multi_line_text_boxed = session.new_text(
        "This is a multi-line text with a box.\nSecond line of text.\nThird line demonstrates the gap.",
        regular_text_options.clone(),
    );
    let multi_line_box = session.new_box(multi_line_text_boxed, box_options.clone());

    // Create a multi-line text with a box (no padding) around it
    let multi_line_text_boxed_no_padding = session.new_text(
        "This is a multi-line text box no padding.\nSecond line without padding.\nThird line gap is more pronounced.",
        regular_text_options.clone(),
    );
    let multi_line_box_no_padding = session.new_box(multi_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Text with linebreaking that causes varying line widths
    let varying_width_text = session.new_text(
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eget ligula eu lectus lobortis condimentum. Aliquam nonummy auctor massa.",
        small_text_options.clone(),
    );
    let varying_width_box = session.new_box(varying_width_text, box_options.clone());

    // Create explanation text
    let explanation = session.new_text(
        "The images above demonstrate differences in text positioning between SVG and PNG renderers. Key issues to observe:\n\n1. Vertical spacing between lines in multi-line text\n2. Text centering in boxes with and without padding\n3. Vertical alignment issues with text baseline",
        small_text_options,
    );

    // Arrange all elements in a vertical stack
    let elements = vec![
        title,
        single_line_text,
        single_line_box,
        single_line_box_no_padding,
        multi_line_text,
        multi_line_box,
        multi_line_box_no_padding,
        varying_width_box,
        explanation,
    ];

    let stack = session.ne(elements);

    // Calculate layout
    layout_tree_node(&mut session, &stack);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("text-comparison-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&session, &stack, &mut svg_file)?;
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render to PNG
    let mut png_path = temp_dir.clone();
    png_path.push("text-comparison-test.png");
    let png_renderer = PNGRenderer {};
    let mut png_file = File::create(&png_path)?;
    png_renderer.render(&session, &stack, &mut png_file)?;
    println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}
===/src/main.rs===
// Create an SVG file with all supported elements

pub mod measure_text;

//import svg_renderer
// use image_renderer::PNGRenderer;
use resvg::tiny_skia::Rect;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{RectOptions, SimpleConstraint, SizeBehavior};
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, LineOptions};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    Fill, TableOptions, TextOptions,
};
//import io modules to write to file
use measure_text::{
    measure_text_svg_character_advance,
}; // Use the ultra-tight measurement for text

use std::fs::File;



fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 0.0,
    };
    session.set_measure_text_fn(measure_text_svg_character_advance);

    //Create a polyline for a star
    let mut points = Vec::new();
    // Outer vertex
    points.push((10.0, 0.0));
    // Inner vertex
    points.push((16.0, 16.0));
    // Outer vertex
    points.push((0.0, 6.0));
    // Inner vertex
    points.push((20.0, 6.0));
    // Outer vertex
    points.push((4.0, 16.0));
    // Closing the shape by returning to the first point
    points.push((10.0, 0.0));

    let polyline = session.new_polyline(
        "star".to_string(),
        points,
        LineOptions {
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //Create horizontal stack with 2 rects and one text, set vertical align to center 
    let mut rectOpts = RectOptions::default();
    rectOpts.width_behavior =  SizeBehavior::Fixed(150.0);
    rectOpts.height_behavior = SizeBehavior::Fixed(150.0);
    rectOpts.stroke_color = "black".to_string();
    rectOpts.stroke_width = 1.0;
    let rect = session.new_rectangle("r1".to_string(), rectOpts.clone());
    let rect2 = session.new_rectangle("r2".to_string(), rectOpts.clone());


    let label = session.new_text(
        "label".to_string(),
        "Center",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            line_width: 60,
            text_color: "#333333".to_string(),
            line_spacing: 0.0,
        },
    );

    let hstack_centered = session.new_hstack(
        "hstack_centered".to_string(),
        vec![rect, label, rect2],
        volare_engine_layout::VerticalAlignment::Center
    );


    

    // Create a more visible polyline - hexagon
    let mut hex_points = Vec::new();
    let hex_size = 50.0;
    for i in 0..6 {
        let angle = (i as f32) * std::f32::consts::PI / 3.0;
        let x = hex_size * angle.cos() + hex_size;
        let y = hex_size * angle.sin() + hex_size;
        hex_points.push((x, y));
    }
    // Close the shape
    hex_points.push(hex_points[0]);

    let hexagon = session.new_polyline(
        "hexagon".to_string(),
        hex_points,
        LineOptions {
            stroke_color: "blue".to_string(),
            stroke_width: 2.0,
        },
    );

    //Create a table with 10 ellipses
    let mut table_items_ellipses: Vec<DiagramTreeNode> = Vec::new();
    for i in 0..10 {
        let ellipse = session.new_elipse(
            format!("table_ellipse_{}", i).to_string(),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        table_items_ellipses.push(ellipse);
    }
    let tableEllipses = session.new_table("table_ellipses".to_string(), table_items_ellipses, 5, TableOptions::default());

    //Create a list of 10 texts
    let mut table_items = Vec::new();
    table_items.push(hstack_centered);
    table_items.push(tableEllipses);
    table_items.push(polyline);
    table_items.push(hexagon);
    for i in 0..10 {
        let text = session.new_text(
            format!("table_text_{}", i),
            &format!("Text hey ☣ {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        table_items.push(text);
        //texts.push(get_test_table(&mut session));
    }
    //Add a couple of ellipses

    //Create an ellipse and wrap it with a box
    let ellipse = session.new_elipse(
        "ellipse1".to_string(),
        (10.0, 10.0),
        EllipseOptions {
            fill_color: "red".to_string(),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //table_items.push(ellipse);

    //Now add 10 ellipses
    for i in 0..10 {
        let ellipse = session.new_elipse(
            format!("ellipse{}", i).to_string(),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        // table_items.push(ellipse);
    }

    //create a paragraph of lorem ipsum
    let lorem_ipsum = br#"
  THE adjustment \u{f1878} factor (currently font_size * 0.05) slightly shifts the text vertically to achieve better visual centering. It's a small empirical correction that helps the
  text appear more naturally centered to the human eye, rather than strictly mathematically centered.

  Without this adjustment, the text might appear slightly too high in the box, even when it's mathematically centered according to its metrics. This is particularly noticeable
  with certain fonts or at larger font sizes.

  In essence, it's an optical adjustment that helps the text look properly centered, compensating for the inherent asymmetry in font design and the way our eyes perceive text
  positioning."#;

    //create text shape
    let text = session.new_text(
        "lorem_ipsum".to_string(),
        std::str::from_utf8(lorem_ipsum).unwrap(),
        text_options.clone(),
    );
    table_items.push(text);

    //Add sample image from file (first instance)
    let sampleImage = session.new_image_from_file("imagefile0".to_string(), "demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
    //table_items.push(sampleImage);

    //Add sample image from file
    // The path is relative to where the binary is run
    let file_image = session.new_image_from_file("imagefile".to_string(), "demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
   // table_items.push(file_image);

    // Create a FreeContainer with multiple visual elements at specific positions using the new method

    // Create all elements first
    let title_text = session.new_text(
        "titletext".to_string(),
        "FreeContainer Demo",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 18.0,
            line_width: 100,
            text_color: "#000000".to_string(),
            line_spacing: 0.0,
        },
    );

    let red_circle = session.new_elipse(
        "redcircle".to_string(),
        (15.0, 15.0), // radius
        EllipseOptions {
            fill_color: "#FF0000".to_string(), // bright red
            stroke_color: "black".to_string(),
            stroke_width: 2.0,
        },
    );

    let thetext = format!(
        r#"
    Esto es un texto
    Otra linea de texto
    Otra mas...
    "#
    );

    let blue_text = session.new_text(
        "bluetext".to_string(),
        &thetext,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "white".to_string(), // white text
            line_spacing: 0.0,
        },
    );

    // Create a box around the blue text
    let box_options = BoxOptions {
        fill_color: Fill::Color("#0000FF".to_string()), // blue background
        stroke_color: "green".to_string(),              // dark blue border
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 3.0,
        width_behavior: volare_engine_layout::SizeBehavior::Fixed(700.0), // Fixed width for the box
        height_behavior: volare_engine_layout::SizeBehavior::Fixed(200.0), 
        ..BoxOptions::default()
    };
    let blue_box = session.new_box("bluebox".to_string(),blue_text, box_options);

    let green_ellipse = session.new_elipse(
        "greeneclipse".to_string(),
        (30.0, 20.0),
        EllipseOptions {
            fill_color: "#00CC00".to_string(),   // green
            stroke_color: "#006600".to_string(), // dark green
            stroke_width: 2.0,
        },
    );

    let subtitle = session.new_text(
        "test_absolute".to_string(),
        "Absolute positioning of elements",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            line_width: 100,
            text_color: "#555555".to_string(), // dark gray
            line_spacing: 0.0,
        },
    );

    // Create a container with all children at once
    let container_with_elements = session.new_free_container("containerwithelems".to_string(),vec![
        (title_text, (30.0, 10.0)),
        (red_circle, (40.0, 50.0)),
        (blue_box, (80.0, 40.0)),
        (green_ellipse, (150.0, 70.0)),
        (subtitle, (30.0, 120.0)),
    ]);

    // Add styling to the container with more vibrant colors
    let free_container = session.get_free_container_mut(container_with_elements.entity_id.clone());
    free_container.background_color = Some("#FFDDDD".to_string()); // Light red background (more visible)
    free_container.border_color = Some("#FF0000".to_string()); // Bright red border
    free_container.border_width = 5.0; // Thicker border


    // Add the FreeContainer to the table
    table_items.push(container_with_elements);


    // Create constraint layout and elements
    let elem1 = session.new_rectangle("constrained1".to_string(), RectOptions{
        width_behavior: SizeBehavior::Fixed(50.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        fill_color: Fill::Color("red".to_string()),
        stroke_color: "yellow".to_string(),
        ..Default::default()
    });
    let elem2 = session.new_rectangle("constrained2".to_string(), RectOptions{
        width_behavior: SizeBehavior::Fixed(50.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        fill_color: Fill::Color("black".to_string()),
        ..Default::default()
    });

    let constraints = vec![SimpleConstraint::AlignLeft("constrained1".to_string(), "constrained2".to_string())];
    let constraint_container = session.new_constraint_layout_container("constraint_container1".to_string(), vec![(elem1, None),(elem2, None)], constraints);
    table_items.push(constraint_container);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 2;
    let table = session.new_table("table".to_string(), table_items, 5, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render PNG
    // Use other  measure function for PNG rendering
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

// Sample image loading is now handled directly through file loading

//function that returns a sample table with 10 elements and 3 columns

/// .
fn get_test_table(session: &mut DiagramBuilder) -> DiagramTreeNode {
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 5.0,
    };
    //Create a list of 10 texts
    let mut texts = Vec::new();
    for i in 0..10 {
        let textid = format!("text_{}", i);
        let text = session.new_text(
            textid,
            &format!("Text hey {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        texts.push(text);
    }
    //create a table options object with all defaults except the header color
    let table_options = TableOptions {
        header_fill_color: "blue".to_string(),
        ..Default::default()
    };
    //Create a table for the texts with 2 columns
    let table = session.new_table("tabletexts".to_string(), texts, 3, table_options);
    table
}



===/volare_engine_layout.txt===
===/Cargo.toml===
[package]
name = "volare_engine_layout"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.2"
cassowary = "0.3"
anyhow = "1.0.99"

===/Cargo.lock===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "layout-base"
version = "0.1.0"

===/docs/the-diagram-tree-spec.md===
# The diagram Tree.

Diagrams are declared as a tree of nodes.
Each node must contain one of the supported diagram components:

- Box
- Group
- Text
- VerticalStack
- etc.

Each diagram consists in the logic necessary to create the tree, without regard for the element size or position, that's calculated by the engine.


The layout components

Layout components that are containers, expect their children to already exist. So we need an upper layer that creates an abstraction so the user is not concerned with internal details.

Ideally the user defines something like:

VerticalStack({props}, [
    Box ({props}, elem),
    HorizontalStack({props}, [
        elem1,
        elem2,
        elem3
    ]),
    Table({props}, [
        [elem1,elem2,elem3],
        [elem4,elem5,elem6]
    ])
])

What we are building is something similar to a virtual representation.
Like react virtual dom.


Each function should return a DiagramNode


Another option is to have vectors for each type of node in the parent element,
and just store the index in DiagramNode

```
struct DiagramNode {
    entity_type: EntityType,
    ix: usize,
    children: Vec<(ix, EntityType)>
}
```

This way we would have a way to retrieve the specific element from a different array.

Where would those arrays live?

Some kind of DiagramBuilder object

## Builder pattern

```rust
let builder = DiagramBuilder::new();

let root = builder.newVerticalStack()
root.add(builder.newBox(...))
.add(builder.newHorizontalStack(...).
    add(builder.newBox({}, builder.Text("Hey"))))

```

Having a builder api with methods that make it easy to create a diagram
by adding nodes is useful to create the API

Then, we can pass the DiagramNode object to the render api.

What happens inside newBox method inside the builder?

- The builder populates the BoxShape component and adds it to the boxes list
- Returns the position of the item in the array **and the entity type**
- (ix, EntityType)

Inside `add`:

Each children is a pair of (ix, EntityType).

Now we have a space where the properties are stored, and each node store indexes and an identifier
to have a way to know what array to look for.

Each index is valid only for the lifetime of the builder object.

## Stage 2

We already have a diagram representation, but no entities have been created.
The properties for each component will be required by the renderer layer (e.g color).
So they should be passed to the render layer somehow.

The renderer can receive an instance of the builder to have access to the internal details for each element?

The properties do affect layout and are used by rendering.




===/docs/JSONL Diagram Specification.md===
# JSONL Diagram Specification
v1.1 - 

This specification describes the JSON Lines format for creating diagrams using the Volare Layout Engine. Each line in a JSONL file represents a single entity with its properties.

## Basic Structure

Each entity follows this format:
```json
{"id": "unique_id", "type": "entity_type", "attribute1": "value1", "attribute2": "value2"}
```

## The first element must be the root container

The first element needs to be the root container with children for the layout to work correctly.

## Core Entity Types

### Text (`"type": "text"`)
Renders text content with styling options.

**Required Attributes:**
- `content` or `text` - The text to display

**Optional Attributes:**
- `font_size` (number) - Font size in pixels (default: 12)
- `color` or `text_color` (string) - Text color (default: "black")
- `font_family` (string) - Font family name (default: "Arial")
- `line_width` (number) - Maximum characters per line for wrapping (default: 200)
- `line_spacing` (number) - Space between lines (default: 0)

**Example:**
```json
{"id":"title","type":"text","content":"Hello World","font_size":24,"color":"blue"}
```

### Box (`"type": "box"`)
Wraps another element with padding, background, and border.

**Required Attributes:**
- `children` (array) - Array with exactly one child element ID

**Optional Attributes:**
- `padding` (number) - Inner padding (default: 0)
- `background`, `background_color`, or `fill` (string) - Background color (default: "white")
- `border_color` or `stroke_color` (string) - Border color (default: "black")
- `border_width` or `stroke_width` (number) - Border thickness (default: 1)
- `border_radius` (number) - Corner radius for rounded corners (default: 0)
- `width` (number or string) - Width behavior: number for fixed, "content" for auto, "grow" for fill
- `height` (number or string) - Height behavior: number for fixed, "content" for auto, "grow" for fill

**Example:**
```json
{"id":"container","type":"box","padding":10,"background":"lightblue","children":["text1"]}
```

### Rectangle (`"type": "rect"`)
Draws a rectangle shape.

**Required Attributes:**
- `width` (number) - Rectangle width
- `height` (number) - Rectangle height

**Optional Attributes:**
- `background`, `background_color`, or `fill` (string) - Fill color (default: "white")
- `border_color` or `stroke_color` (string) - Border color (default: "black")
- `border_width` or `stroke_width` (number) - Border thickness (default: 1)
- `border_radius` (number) - Corner radius for rounded corners (default: 0)

**Example:**
```json
{"id":"rect1","type":"rect","width":100,"height":50,"background":"red","border_radius":5}
```

## Layout Containers

### Vertical Stack (`"type": "vstack"`)
Stacks children vertically.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Optional Attributes:**
- `h_align` or `horizontal_alignment` (string) - Horizontal alignment: "left", "center", "right" (default: "center")

**Example:**
```json
{"id":"stack1","type":"vstack","children":["elem1","elem2"],"h_align":"left"}
```

### Horizontal Stack (`"type": "hstack"`)
Stacks children horizontally.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Optional Attributes:**
- `v_align` or `vertical_alignment` (string) - Vertical alignment: "top", "center", "bottom" (default: "center")

**Example:**
```json
{"id":"stack2","type":"hstack","children":["elem1","elem2"],"v_align":"top"}
```

### Group (`"type": "group"`)
Groups elements without layout constraints.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Example:**
```json
{"id":"group1","type":"group","children":["elem1","elem2"]}
```

### Table (`"type": "table"`)
Arranges children in a grid layout.

**Required Attributes:**
- `children` (array) - Array of cell element IDs
- `cols` or `columns` (number) - Number of columns

**Optional Attributes:**
- `header_fill_color` or `header_background` (string) - Header row background (default: "lightgray")
- `fill_color` or `background` (string) - Table background (default: "white")
- `border_color` (string) - Border color (default: "black")
- `border_width` (number) - Border thickness (default: 1)
- `cell_padding` or `padding` (number) - Cell padding (default: 20)

**Example:**
```json
{"id":"table1","type":"table","children":["cell1","cell2","cell3","cell4"],"cols":2,"cell_padding":15}
```

### Free Container (`"type": "free_container"`)
Allows absolute positioning of children.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Child Positioning:**
Each child element should have `x` and `y` attributes for positioning within the container.

**Optional Container Attributes:**
- `width` (number) - Container width
- `height` (number) - Container height
- `background` or `background_color` (string) - Background color
- `border_color` (string) - Border color
- `border_width` (number) - Border thickness

**Example:**
```json
{"id":"container","type":"free_container","width":400,"height":300,"children":["item1","item2"]}
{"id":"item1","type":"text","content":"Positioned Text","x":50,"y":100}
{"id":"item2","type":"rect","width":60,"height":40,"background":"blue","x":200,"y":150}
```

## Shape Types

### Line (`"type": "line"`)
Draws a straight line between two points.

**Required Attributes:**
- `start_x` or `x1` (number) - Starting X coordinate
- `start_y` or `y1` (number) - Starting Y coordinate
- `end_x` or `x2` (number) - Ending X coordinate
- `end_y` or `y2` (number) - Ending Y coordinate

**Optional Attributes:**
- `stroke_color` or `color` (string) - Line color (default: "black")
- `stroke_width` (number) - Line thickness (default: 1)

**Example:**
```json
{"id":"line1","type":"line","start_x":0,"start_y":0,"end_x":100,"end_y":50,"stroke_color":"blue"}
```

### Ellipse (`"type": "ellipse"`)
Draws an ellipse or circle.

**Required Attributes:**
- `rx` or `radius_x` (number) - Horizontal radius
- `ry` or `radius_y` (number) - Vertical radius

**Optional Attributes:**
- `fill`, `fill_color`, or `background` (string) - Fill color (default: "white")
- `stroke`, `stroke_color`, or `border_color` (string) - Border color (default: "black")
- `stroke_width` or `border_width` (number) - Border thickness (default: 1)

**Example:**
```json
{"id":"circle","type":"ellipse","rx":25,"ry":25,"fill":"yellow"}
```

### Arc (`"type": "arc"`)
Draws an arc segment. Arcs work like ellipses - they are positioned by the layout system and centered within their bounding box.

**Required Attributes:**
- `radius` or `r` (number) - Arc radius
- `start_angle` or `start` (number) - Start angle in degrees
- `end_angle` or `end` (number) - End angle in degrees

**Optional Attributes:**
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the arc sector (default: false)

**Positioning:**
- Arcs are positioned using `x`, `y` attributes (for free containers) like other shapes
- The `cx`, `cy` attributes are ignored - positioning is handled by the layout system
- Arc size is always `diameter = radius * 2` regardless of arc sweep
- The arc is automatically centered within its bounding box

**Special Cases:**
- 360° arcs (full circles) render as proper circles
- Filled arcs create pie-slice shapes with lines to the center
- Unfilled arcs draw only the arc curve

**Examples:**
```json
{"id":"quarter","type":"arc","radius":40,"start_angle":0,"end_angle":90,"stroke_color":"red","x":50,"y":50}
{"id":"semicircle","type":"arc","radius":30,"start_angle":0,"end_angle":180,"filled":true,"fill_color":"blue","x":150,"y":50}
{"id":"full_circle","type":"arc","radius":25,"start_angle":0,"end_angle":360,"filled":true,"fill_color":"green","x":250,"y":50}
```

### Semicircle (`"type": "semicircle"`)
Draws a semicircle (180° arc).

**Required Attributes:**
- `cx` or `center_x` (number) - Center X coordinate
- `cy` or `center_y` (number) - Center Y coordinate
- `radius` or `r` (number) - Semicircle radius

**Optional Attributes:**
- `facing_up` or `up` (boolean) - True for top semicircle, false for bottom (default: true)
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the semicircle (default: false)

**Example:**
```json
{"id":"semi1","type":"semicircle","cx":100,"cy":100,"radius":40,"facing_up":false,"fill":"green"}
```

### Quarter Circle (`"type": "quarter_circle"`)
Draws a quarter circle (90° arc).

**Required Attributes:**
- `cx` or `center_x` (number) - Center X coordinate
- `cy` or `center_y` (number) - Center Y coordinate
- `radius` or `r` (number) - Quarter circle radius
- `quadrant` (number) - Quadrant: 1=top-right, 2=top-left, 3=bottom-left, 4=bottom-right

**Optional Attributes:**
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the quarter circle (default: false)

**Example:**
```json
{"id":"quarter1","type":"quarter_circle","cx":50,"cy":50,"radius":30,"quadrant":1,"fill":"orange"}
```


### Polyline (`"type": "polyline"`)
Draws connected line segments.

**Required Attributes:**
- `points` (array) - Array of [x, y] coordinate pairs

**Optional Attributes:**
- `stroke_color` or `color` (string) - Line color (default: "black")
- `stroke_width` (number) - Line thickness (default: 1)

**Example:**
```json
{"id":"poly1","type":"polyline","points":[[0,0],[50,25],[100,0],[150,50]],"stroke_color":"purple"}
```

## Media Types

### Image (`"type": "image"`)
Displays an image from file or base64 data.

**Required Attributes:**
- `src` (string) - Base64 image data, OR
- `file_path` (string) - Path to image file

**Optional Attributes:**
- `width` (number or string) - Image width
- `height` (number or string) - Image height

**Example:**
```json
{"id":"img1","type":"image","file_path":"assets/logo.png","width":200,"height":150}
```

## Transform and Positioning Attributes

All entities support the following positioning and transform attributes:

### Positioning (for Free Container children)
- `x` (number) - X position relative to container
- `y` (number) - Y position relative to container

### Transforms
- `rotation` or `rotate` (number) - Rotation angle in degrees
- `scale` (number or array) - Uniform scale (number) or [scaleX, scaleY] (array)
- `transform` (string) - CSS-style transform string (experimental)

**Transform Examples:**
```json
{"id":"rotated_rect","type":"rect","width":50,"height":30,"background":"blue","rotation":45}
{"id":"scaled_text","type":"text","content":"Big Text","scale":2.0}
{"id":"complex_shape","type":"rect","width":40,"height":40,"scale":[1.5,0.8],"rotation":30}
```

## Size Behaviors

For `width` and `height` attributes, you can use:

- **Number** - Fixed size in pixels: `"width": 200`
- **"content"** or **"auto"** - Size based on content: `"width": "content"`
- **"grow"** - Take all available space: `"width": "grow"` (TODO: Not currently supported)

**Note:** When using fixed width with text content, automatic text wrapping ensures optimal text layout within the specified constraints.

## Color Values

Colors can be specified as:
- Named colors: `"red"`, `"blue"`, `"lightgray"`
- Hex colors: `"#FF0000"`, `"#0066CC"`
- RGB colors: `"rgb(255,0,0)"`

## Custom Components

The system supports custom components registered by the application. These components can accept any attributes defined by their implementation. Examples from the codebase include:

- `badge` - Creates a styled badge with text
- `alert` - Creates alert boxes with different types
- `progress_bar` - Creates progress indicators
- `button` - Creates interactive buttons

Custom components are registered via `builder.register_custom_component()` and can have any attributes their implementation supports.

## Complete Example

```json
{"id":"root","type":"vstack","children":["header","content","footer"],"h_align":"center"}
{"id":"header","type":"box","padding":15,"background":"#f0f0f0","children":["title"]}
{"id":"title","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"content","type":"hstack","children":["sidebar","main"],"v_align":"top"}
{"id":"sidebar","type":"vstack","children":["nav1","nav2","nav3"],"h_align":"left"}
{"id":"nav1","type":"text","content":"Home","color":"blue"}
{"id":"nav2","type":"text","content":"About","color":"blue"}
{"id":"nav3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":20,"background":"white","children":["article"]}
{"id":"article","type":"text","content":"This is the main content area with longer text that will wrap to multiple lines.","line_width":300}
{"id":"footer","type":"text","content":"© 2024 My Company","font_size":10,"color":"gray"}
```

This creates a document layout with header, sidebar navigation, main content area, and footer.

## Implementation Notes

- The parser supports flexible attribute naming (e.g., `background`, `background_color`, and `fill` all work for background colors)
- Transform attributes are parsed and applied during entity building
- Container-relative positioning (`x`, `y`) is handled separately from transforms
- Size behaviors allow for responsive layouts with content-based or fixed sizing
- All supported entity types are handled in the `build_entity` match statement in parser.rs

# JSONL Format for Constraint Layout Container

## Overview
This JSONL format is designed specifically for declaring constraint layout containers in your system. Since constraints are only supported within constraint layout containers, the format focuses on defining the container and its child entities with their associated constraints.

## Container Declaration Format

The constraint layout container is declared with its children and constraints:

```jsonl
{"type": "constraint_container", "id": "layout1", "children": ["rect1", "rect2", "rect3"], "constraints": []}
```

## Child Entity Declaration Format

Child entities must be declared before the container:

```jsonl
{"type": "rect", "id": "rect1", "width": 100, "height": 50, "fill": "blue"}
{"type": "rect", "id": "rect2", "width": 80, "height": 40, "fill": "red"}  
{"type": "text", "id": "text1", "content": "Hello World", "font_size": 16}
```

## Inline Constraint Declaration

Constraints can be declared inline within the container definition:

```jsonl
{
  "type": "constraint_container", 
  "id": "layout1", 
  "children": ["rect1", "rect2", "rect3"],
  "constraints": [
    {"type": "align_left", "entities": ["rect1", "rect2"]},
    {"type": "below", "entities": ["rect2", "rect1"]},
    {"type": "horizontal_spacing", "entities": ["rect1", "rect3"], "spacing": 20.0}
  ]
}
```

## Complete Example

```jsonl
{"type": "comment", "text": "Dashboard layout with constraint-based positioning"}

{"type": "rect", "id": "header", "width": 400, "height": 60, "fill": "navy"}
{"type": "rect", "id": "sidebar", "width": 150, "height": 300, "fill": "lightgray"}
{"type": "rect", "id": "content", "width": 250, "height": 300, "fill": "white"}
{"type": "rect", "id": "footer", "width": 400, "height": 40, "fill": "darkgray"}

{
  "type": "constraint_container",
  "id": "dashboard_layout", 
  "children": ["header", "sidebar", "content", "footer"],
  "constraints": [
    {"type": "align_left", "entities": ["header", "sidebar"]},
    {"type": "right_of", "entities": ["content", "sidebar"]},
    {"type": "below", "entities": ["sidebar", "header"]},
    {"type": "below", "entities": ["content", "header"]},
    {"type": "below", "entities": ["footer", "content"]},
    {"type": "align_left", "entities": ["footer", "sidebar"]},
    {"type": "same_width", "entities": ["header", "footer"]},
    {"type": "vertical_spacing", "entities": ["header", "sidebar"], "spacing": 10.0},
    {"type": "horizontal_spacing", "entities": ["sidebar", "content"], "spacing": 20.0}
  ]
}
```

## Constraint Types

### Alignment Constraints
```jsonl
{"type": "align_left", "entities": ["rect1", "rect2"]}
{"type": "align_right", "entities": ["rect1", "rect2"]}
{"type": "align_top", "entities": ["rect1", "rect2"]}
{"type": "align_bottom", "entities": ["rect1", "rect2"]}
{"type": "align_center_horizontal", "entities": ["rect1", "rect2"]}
{"type": "align_center_vertical", "entities": ["rect1", "rect2"]}
```

### Directional Positioning
```jsonl
{"type": "right_of", "entities": ["rect1", "rect2"]}
{"type": "left_of", "entities": ["rect1", "rect2"]}
{"type": "above", "entities": ["rect1", "rect2"]}
{"type": "below", "entities": ["rect1", "rect2"]}
```

### Spacing Constraints
```jsonl
{"type": "horizontal_spacing", "entities": ["rect1", "rect2"], "spacing": 20.0}
{"type": "vertical_spacing", "entities": ["rect1", "rect2"], "spacing": 15.0}
{"type": "fixed_distance", "entities": ["rect1", "rect2"], "distance": 100.0}
```

### Layout Stacking
```jsonl
{"type": "stack_horizontal", "entities": ["rect1", "rect2", "rect3"], "spacing": 10.0}
{"type": "stack_vertical", "entities": ["rect1", "rect2", "rect3"], "spacing": 8.0}
```

### Size Relationship Constraints
```jsonl
{"type": "same_width", "entities": ["rect1", "rect2"]}
{"type": "same_height", "entities": ["rect1", "rect2"]}
{"type": "same_size", "entities": ["rect1", "rect2"]}
{"type": "proportional_width", "entities": ["rect1", "rect2"], "ratio": 1.5}
{"type": "proportional_height", "entities": ["rect1", "rect2"], "ratio": 0.8}
```

### Advanced Layout Constraints
```jsonl
{"type": "aspect_ratio", "entity": "rect1", "ratio": 1.618}
{"type": "distribute_horizontally", "entities": ["rect1", "rect2", "rect3"]}
{"type": "distribute_vertically", "entities": ["rect1", "rect2", "rect3"]}
```

## Multiple Constraint Containers

You can define multiple constraint containers in the same JSONL:

```jsonl
{"type": "rect", "id": "nav1", "width": 100, "height": 30, "fill": "blue"}
{"type": "rect", "id": "nav2", "width": 100, "height": 30, "fill": "blue"}
{"type": "rect", "id": "nav3", "width": 100, "height": 30, "fill": "blue"}

{"type": "constraint_container", "id": "navbar", "children": ["nav1", "nav2", "nav3"], "constraints": [
  {"type": "stack_horizontal", "entities": ["nav1", "nav2", "nav3"], "spacing": 10.0},
  {"type": "align_center_vertical", "entities": ["nav1", "nav2"]},
  {"type": "align_center_vertical", "entities": ["nav2", "nav3"]}
]}

{"type": "rect", "id": "card1", "width": 200, "height": 150, "fill": "lightblue"}
{"type": "rect", "id": "card2", "width": 200, "height": 150, "fill": "lightgreen"}

{"type": "constraint_container", "id": "card_layout", "children": ["card1", "card2"], "constraints": [
  {"type": "vertical_spacing", "entities": ["card1", "card2"], "spacing": 20.0},
  {"type": "align_center_horizontal", "entities": ["card1", "card2"]}
]}
```

## Advanced Example with All Constraint Types

```jsonl
{"type": "rect", "id": "main_rect", "width": 200, "height": 100, "fill": "blue"}
{"type": "rect", "id": "side_rect", "width": 100, "height": 50, "fill": "red"}
{"type": "rect", "id": "bottom_rect", "width": 150, "height": 75, "fill": "green"}
{"type": "rect", "id": "item1", "width": 50, "height": 30, "fill": "yellow"}
{"type": "rect", "id": "item2", "width": 50, "height": 30, "fill": "orange"}
{"type": "rect", "id": "item3", "width": 50, "height": 30, "fill": "purple"}

{
  "type": "constraint_container",
  "id": "advanced_layout",
  "children": ["main_rect", "side_rect", "bottom_rect", "item1", "item2", "item3"],
  "constraints": [
    {"type": "right_of", "entities": ["side_rect", "main_rect"]},
    {"type": "below", "entities": ["bottom_rect", "main_rect"]},
    {"type": "horizontal_spacing", "entities": ["main_rect", "side_rect"], "spacing": 20.0},
    {"type": "vertical_spacing", "entities": ["main_rect", "bottom_rect"], "spacing": 15.0},
    {"type": "same_width", "entities": ["side_rect", "bottom_rect"]},
    {"type": "proportional_height", "entities": ["side_rect", "main_rect"], "ratio": 0.5},
    {"type": "aspect_ratio", "entity": "main_rect", "ratio": 2.0},
    {"type": "stack_horizontal", "entities": ["item1", "item2", "item3"], "spacing": 10.0},
    {"type": "distribute_vertically", "entities": ["main_rect", "bottom_rect"]}
  ]
}
```

## Positioning

Since constraint containers handle positioning through constraints, explicit `x` and `y` positions are generally not needed for children. However, you can still provide initial position suggestions:

```jsonl
{"type": "rect", "id": "rect1", "width": 100, "height": 50, "fill": "blue", "x": 50, "y": 50}
```

This would be used as a suggestion in the constraint system, but the final positioning will be determined by the constraints.
===/docs/examples/shapes/polylines.jsonl===
{"id":"root","type":"vstack","children":["title","demo_container"],"h_align":"center"}
{"id":"title","type":"text","content":"📈 Polyline Test & Examples","font_size":24,"color":"darkblue"}
{"id":"demo_container","type":"free_container","width":700,"height":500,"children":["simple_line","zigzag","triangle","star","graph","house","labels"]}
{"id":"simple_line","type":"polyline","points":[[0,0],[100,0],[100,50],[0,50]],"stroke_color":"red","stroke_width":3,"x":50,"y":50}
{"id":"zigzag","type":"polyline","points":[[0,0],[30,20],[60,0],[90,20],[120,0],[150,20]],"stroke_color":"green","stroke_width":2,"x":200,"y":50}
{"id":"triangle","type":"polyline","points":[[0,40],[40,0],[80,40],[0,40]],"stroke_color":"blue","stroke_width":3,"x":400,"y":50}
{"id":"star","type":"polyline","points":[[25,0],[30,15],[45,15],[35,25],[40,40],[25,30],[10,40],[15,25],[5,15],[20,15],[25,0]],"stroke_color":"gold","stroke_width":2,"x":550,"y":50}
{"id":"graph","type":"polyline","points":[[0,80],[20,60],[40,70],[60,30],[80,40],[100,10],[120,20],[140,5]],"stroke_color":"purple","stroke_width":3,"x":50,"y":150}
{"id":"house","type":"polyline","points":[[0,40],[0,10],[20,0],[40,10],[40,40],[30,40],[30,25],[10,25],[10,40],[0,40]],"stroke_color":"brown","stroke_width":2,"x":250,"y":150}
{"id":"labels","type":"vstack","children":["label1","label2","label3","label4","label5","label6","positioning_note"],"h_align":"left","x":50,"y":300}
{"id":"label1","type":"text","content":"• Red: Simple rectangle path","font_size":12,"color":"red"}
{"id":"label2","type":"text","content":"• Green: Zigzag line pattern","font_size":12,"color":"green"}
{"id":"label3","type":"text","content":"• Blue: Closed triangle shape","font_size":12,"color":"blue"}
{"id":"label4","type":"text","content":"• Gold: 5-pointed star","font_size":12,"color":"gold"}
{"id":"label5","type":"text","content":"• Purple: Data graph line","font_size":12,"color":"purple"}
{"id":"label6","type":"text","content":"• Brown: House outline","font_size":12,"color":"brown"}
{"id":"positioning_note","type":"text","content":"All polylines positioned using x,y coordinates","font_size":10,"color":"gray"}
===/docs/examples/shapes/arcs.jsonl===
{"id":"root","type":"vstack","children":["title","test_container"],"h_align":"center"}
{"id":"title","type":"text","content":"🌀 Arc Positioning Test","font_size":24,"color":"darkblue"}
{"id":"test_container","type":"free_container","width":600,"height":400,"children":["arc1","arc2","arc3","arc4","reference_grid","labels"]}
{"id":"arc1","type":"arc","radius":40,"start_angle":0,"end_angle":90,"stroke_color":"red","stroke_width":3,"filled":false,"x":60,"y":60}
{"id":"arc2","type":"arc","radius":30,"start_angle":0,"end_angle":180,"stroke_color":"green","stroke_width":3,"filled":true,"fill_color":"lightgreen","x":220,"y":70}
{"id":"arc3","type":"arc","radius":35,"start_angle":0,"end_angle":270,"stroke_color":"blue","stroke_width":3,"filled":false,"x":365,"y":65}
{"id":"arc4","type":"arc","radius":25,"start_angle":0,"end_angle":360,"stroke_color":"purple","stroke_width":3,"filled":true,"fill_color":"lavender","x":150,"y":225}
{"id":"reference_grid","type":"free_container","width":600,"height":400,"children":["ref1","ref2","ref3","ref4"],"x":0,"y":0}
{"id":"ref1","type":"ellipse","rx":3,"ry":3,"fill":"red","stroke":"darkred","stroke_width":1,"x":97,"y":97}
{"id":"ref2","type":"ellipse","rx":3,"ry":3,"fill":"green","stroke":"darkgreen","stroke_width":1,"x":247,"y":97}
{"id":"ref3","type":"ellipse","rx":3,"ry":3,"fill":"blue","stroke":"darkblue","stroke_width":1,"x":397,"y":97}
{"id":"ref4","type":"ellipse","rx":3,"ry":3,"fill":"purple","stroke":"darkpurple","stroke_width":1,"x":172,"y":247}
{"id":"labels","type":"vstack","children":["label1","label2","label3","label4","note"],"h_align":"left","x":50,"y":320}
{"id":"label1","type":"text","content":"• Red: 90° arc at (60,60) with radius 40","font_size":12,"color":"red"}
{"id":"label2","type":"text","content":"• Green: 180° filled arc at (220,70) with radius 30","font_size":12,"color":"green"}
{"id":"label3","type":"text","content":"• Blue: 270° arc at (365,65) with radius 35","font_size":12,"color":"blue"}
{"id":"label4","type":"text","content":"• Purple: 360° filled arc at (150,225) with radius 25","font_size":12,"color":"purple"}
{"id":"note","type":"text","content":"Small dots mark where arc centers should be","font_size":10,"color":"gray"}
===/docs/examples/shapes/arcs-and-ellipses.jsonl===
{"id":"root","type":"vstack","children":["title","shape_stack","spacing","rotated_stack"],"h_align":"center"}
{"id":"title","type":"text","content":"📦 VStack Bounding Box Test","font_size":24,"color":"darkgreen"}
{"id":"shape_stack","type":"vstack","children":["ellipse1","arc1","ellipse2","arc2","ellipse3"],"h_align":"center"}
{"id":"ellipse1","type":"ellipse","rx":30,"ry":20,"fill":"lightblue","stroke":"blue","stroke_width":2}
{"id":"arc1","type":"arc","radius":25,"start_angle":0,"end_angle":180,"stroke_color":"red","stroke_width":3,"filled":true,"fill_color":"pink"}
{"id":"ellipse2","type":"ellipse","rx":40,"ry":15,"fill":"lightgreen","stroke":"green","stroke_width":2}
{"id":"arc2","type":"arc","radius":30,"start_angle":0,"end_angle":270,"stroke_color":"purple","stroke_width":3,"filled":false}
{"id":"ellipse3","type":"ellipse","rx":25,"ry":25,"fill":"yellow","stroke":"orange","stroke_width":2}
{"id":"spacing","type":"text","content":"---","font_size":16,"color":"gray"}
{"id":"rotated_stack","type":"vstack","children":["rot_ellipse1","rot_arc1","rot_ellipse2","rot_arc2","rot_circle"],"h_align":"center"}
{"id":"rot_ellipse1","type":"ellipse","rx":35,"ry":20,"fill":"lightcoral","stroke":"darkred","stroke_width":2,"rotation":45}
{"id":"rot_arc1","type":"arc","radius":28,"start_angle":0,"end_angle":120,"stroke_color":"darkblue","stroke_width":4,"filled":true,"fill_color":"lightsteelblue","rotation":30}
{"id":"rot_ellipse2","type":"ellipse","rx":20,"ry":40,"fill":"lightpink","stroke":"deeppink","stroke_width":2,"rotation":-30}
{"id":"rot_arc2","type":"arc","radius":35,"start_angle":45,"end_angle":315,"stroke_color":"darkorange","stroke_width":3,"filled":false,"rotation":60}
{"id":"rot_circle","type":"arc","radius":20,"start_angle":0,"end_angle":360,"stroke_color":"darkviolet","stroke_width":2,"filled":true,"fill_color":"mediumpurple","rotation":90}
===/docs/examples/shapes/shapes-reference.jsonl===
{"id":"root","type":"vstack","children":["title","subtitle","shapes_table"],"h_align":"center"}
{"id":"title","type":"text","content":"🎨 Complete Shape Reference","font_size":28,"color":"darkblue"}
{"id":"subtitle","type":"text","content":"All supported shapes with examples - Renderer Reference","font_size":16,"color":"gray"}
{"id":"shapes_table","type":"table","cols":3,"children":["header1","header2","header3","text_name","text_demo","text_desc","rect_name","rect_demo","rect_desc","ellipse_name","ellipse_demo","ellipse_desc","arc_name","arc_demo","arc_desc","line_name","line_demo","line_desc","polyline_name","polyline_demo","polyline_desc","box_name","box_demo","box_desc","image_name","image_demo","image_desc","vstack_name","vstack_demo","vstack_desc","hstack_name","hstack_demo","hstack_desc","table_name","table_demo","table_desc","group_name","group_demo","group_desc","container_name","container_demo","container_desc"],"header_fill_color":"lightblue","border_color":"darkblue","border_width":2,"cell_padding":15}
{"id":"header1","type":"text","content":"Shape Type","font_size":16,"color":"darkblue"}
{"id":"header2","type":"text","content":"Example","font_size":16,"color":"darkblue"}
{"id":"header3","type":"text","content":"Description","font_size":16,"color":"darkblue"}
{"id":"text_name","type":"text","content":"Text","font_size":14,"color":"black"}
{"id":"text_demo","type":"text","content":"Hello World!\nMultiline text\nsupported","font_size":12,"color":"darkgreen"}
{"id":"text_desc","type":"text","content":"Renders text with font styling, wrapping, and line spacing","font_size":11,"color":"gray"}
{"id":"rect_name","type":"text","content":"Rectangle","font_size":14,"color":"black"}
{"id":"rect_demo","type":"rect","width":60,"height":40,"background":"lightcoral","border_color":"darkred","border_width":2,"border_radius":5}
{"id":"rect_desc","type":"text","content":"Rectangular shapes with optional rounded corners","font_size":11,"color":"gray"}
{"id":"ellipse_name","type":"text","content":"Ellipse","font_size":14,"color":"black"}
{"id":"ellipse_demo","type":"ellipse","rx":30,"ry":20,"fill":"lightblue","stroke":"darkblue","stroke_width":2}
{"id":"ellipse_desc","type":"text","content":"Ellipses and circles with customizable radii","font_size":11,"color":"gray"}
{"id":"arc_name","type":"text","content":"Arc","font_size":14,"color":"black"}
{"id":"arc_demo","type":"arc","radius":25,"start_angle":0,"end_angle":270,"stroke_color":"purple","stroke_width":3,"filled":true,"fill_color":"lavender"}
{"id":"arc_desc","type":"text","content":"Arc segments, semicircles, and pie slices","font_size":11,"color":"gray"}
{"id":"line_name","type":"text","content":"Line","font_size":14,"color":"black"}
{"id":"line_demo","type":"line","start_x":0,"start_y":0,"end_x":50,"end_y":30,"stroke_color":"red","stroke_width":3}
{"id":"line_desc","type":"text","content":"Straight lines between two points","font_size":11,"color":"gray"}
{"id":"polyline_name","type":"text","content":"Polyline","font_size":14,"color":"black"}
{"id":"polyline_demo","type":"polyline","points":[[0,20],[15,0],[30,20],[45,5],[60,25]],"stroke_color":"orange","stroke_width":2}
{"id":"polyline_desc","type":"text","content":"Connected line segments forming complex paths","font_size":11,"color":"gray"}
{"id":"box_name","type":"text","content":"Box","font_size":14,"color":"black"}
{"id":"box_demo","type":"box","padding":8,"background":"lightyellow","border_color":"gold","border_width":2,"children":["box_child"]}
{"id":"box_child","type":"text","content":"Boxed","font_size":10,"color":"darkorange"}
{"id":"box_desc","type":"text","content":"Container with padding, background, and border","font_size":11,"color":"gray"}
{"id":"image_name","type":"text","content":"Image","font_size":14,"color":"black"}
{"id":"image_demo","type":"rect","width":50,"height":30,"background":"lightgray","border_color":"gray","border_width":1}
{"id":"image_desc","type":"text","content":"Images from files or base64 data (placeholder shown)","font_size":11,"color":"gray"}
{"id":"vstack_name","type":"text","content":"VStack","font_size":14,"color":"black"}
{"id":"vstack_demo","type":"vstack","children":["vs1","vs2","vs3"],"h_align":"center"}
{"id":"vs1","type":"rect","width":15,"height":8,"background":"red"}
{"id":"vs2","type":"rect","width":20,"height":8,"background":"green"}
{"id":"vs3","type":"rect","width":12,"height":8,"background":"blue"}
{"id":"vstack_desc","type":"text","content":"Vertical layout container for stacking elements","font_size":11,"color":"gray"}
{"id":"hstack_name","type":"text","content":"HStack","font_size":14,"color":"black"}
{"id":"hstack_demo","type":"hstack","children":["hs1","hs2","hs3"],"v_align":"center"}
{"id":"hs1","type":"rect","width":8,"height":15,"background":"red"}
{"id":"hs2","type":"rect","width":8,"height":20,"background":"green"}
{"id":"hs3","type":"rect","width":8,"height":12,"background":"blue"}
{"id":"hstack_desc","type":"text","content":"Horizontal layout container for side-by-side elements","font_size":11,"color":"gray"}
{"id":"table_name","type":"text","content":"Table","font_size":14,"color":"black"}
{"id":"table_demo","type":"table","cols":2,"children":["t1","t2","t3","t4"],"border_color":"black","border_width":1,"cell_padding":3}
{"id":"t1","type":"text","content":"A","font_size":10}
{"id":"t2","type":"text","content":"B","font_size":10}
{"id":"t3","type":"text","content":"C","font_size":10}
{"id":"t4","type":"text","content":"D","font_size":10}
{"id":"table_desc","type":"text","content":"Grid layout with configurable rows and columns","font_size":11,"color":"gray"}
{"id":"group_name","type":"text","content":"Group","font_size":14,"color":"black"}
{"id":"group_demo","type":"group","children":["g1","g2"]}
{"id":"g1","type":"rect","width":20,"height":15,"background":"pink"}
{"id":"g2","type":"rect","width":15,"height":20,"background":"lightgreen"}
{"id":"group_desc","type":"text","content":"Groups elements without layout constraints","font_size":11,"color":"gray"}
{"id":"container_name","type":"text","content":"Free Container","font_size":14,"color":"black"}
{"id":"container_demo","type":"free_container","width":60,"height":40,"children":["fc1","fc2"]}
{"id":"fc1","type":"rect","width":15,"height":10,"background":"cyan","x":5,"y":5}
{"id":"fc2","type":"rect","width":10,"height":15,"background":"magenta","x":35,"y":20}
{"id":"container_desc","type":"text","content":"Absolute positioning container using x,y coordinates","font_size":11,"color":"gray"}
===/docs/examples/images.jsonl===
{"id":"root","type":"vstack","children":["header","main_content","footer"],"h_align":"center"}
{"id":"header","type":"box","padding":20,"background":"#2c3e50","children":["header_content"]}
{"id":"header_content","type":"text","content":"📷 Multi-Service Image Test","font_size":28,"color":"white"}
{"id":"main_content","type":"vstack","children":["placeholders_section","avatars_section","mixed_section"],"h_align":"center"}
{"id":"placeholders_section","type":"vstack","children":["placeholder_title","placeholder_images"],"h_align":"center"}
{"id":"placeholder_title","type":"text","content":"Lorem Picsum Placeholders","font_size":20,"color":"#34495e"}
{"id":"placeholder_images","type":"hstack","children":["placeholder_1","placeholder_2","placeholder_3","placeholder_4"],"v_align":"center"}
{"id":"placeholder_1","type":"image","src":"https://picsum.photos/150/150?random=10","width":150,"height":150}
{"id":"placeholder_2","type":"image","src":"https://picsum.photos/150/150?random=20","width":150,"height":150}
{"id":"placeholder_3","type":"image","src":"https://picsum.photos/150/150?random=30","width":150,"height":150}
{"id":"placeholder_4","type":"image","src":"https://picsum.photos/150/150?random=40","width":150,"height":150}
{"id":"avatars_section","type":"vstack","children":["avatar_title","avatar_images"],"h_align":"center"}
{"id":"avatar_title","type":"text","content":"DiceBear Avatar Generator","font_size":20,"color":"#34495e"}
{"id":"avatar_images","type":"hstack","children":["avatar_1","avatar_2","avatar_3"],"v_align":"center"}
{"id":"avatar_1","type":"image","src":"https://api.dicebear.com/7.x/avataaars/svg?seed=Felix","width":100,"height":100}
{"id":"avatar_2","type":"image","src":"https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka","width":100,"height":100}
{"id":"avatar_3","type":"image","src":"https://api.dicebear.com/7.x/avataaars/svg?seed=John","width":100,"height":100}
{"id":"mixed_section","type":"vstack","children":["mixed_title","mixed_content"],"h_align":"center"}
{"id":"mixed_title","type":"text","content":"Mixed Content Layout","font_size":20,"color":"#34495e"}
{"id":"mixed_content","type":"free_container","width":600,"height":300,"background":"#ecf0f1","border_color":"#bdc3c7","border_width":2,"children":["large_img","info_card","small_avatars"]}
{"id":"large_img","type":"image","src":"https://picsum.photos/250/200?random=100","width":250,"height":200,"x":20,"y":20}
{"id":"info_card","type":"box","padding":15,"background":"white","border_color":"#95a5a6","border_width":1,"border_radius":8,"children":["info_text"],"x":300,"y":30}
{"id":"info_text","type":"text","content":"This large image demonstrates absolute positioning within a free container. The image uses Lorem Picsum with specific dimensions and a random seed.","line_width":250,"font_size":12,"color":"#2c3e50"}
{"id":"small_avatars","type":"hstack","children":["mini_avatar_1","mini_avatar_2","mini_avatar_3"],"v_align":"center","x":350,"y":200}
{"id":"mini_avatar_1","type":"image","src":"https://api.dicebear.com/7.x/miniavs/svg?seed=test1","width":40,"height":40}
{"id":"mini_avatar_2","type":"image","src":"https://api.dicebear.com/7.x/miniavs/svg?seed=test2","width":40,"height":40}
{"id":"mini_avatar_3","type":"image","src":"https://api.dicebear.com/7.x/miniavs/svg?seed=test3","width":40,"height":40}
{"id":"footer","type":"box","padding":10,"background":"#95a5a6","children":["footer_text"]}
{"id":"footer_text","type":"text","content":"🌐 Images loaded from: picsum.photos (photos) • dicebear.com (avatars)","font_size":12,"color":"#2c3e50"}
===/docs/examples/text/text-in-box-auto-wrap.jsonl===
{"id":"test_box","type":"box","width":400,"padding":20,"children":["long_text"]}
{"id":"long_text","type":"text","content":"This is a very long text that should automatically wrap to fit within the 400px box width with 20px padding on each side."}
===/.gitignore===
/target
/Cargo.lock

===/.github/workflows/test-and-build.yml===
# test rust project and build

name: Test and Build

on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test
      - name: Build
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release





===/src/layout.rs===
/* Layout calculation for each type of entity */

use std::f32::{INFINITY, NEG_INFINITY};

use crate::components::Float;
use crate::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, FreeContainer,
    HorizontalStack, PolyLine, ShapeArrow, ShapeBox, ShapeEllipse, ShapeGroup, ShapeImage,
    ShapeLine, ShapeText, Table, VerticalStack,
};
use crate::{
    ConstraintLayoutContainer, ConstraintSystem, HorizontalAlignment, Point, ShapeArc, ShapeRect, ShapeSpacer, SizeBehavior, SpacerDirection, TextLine, VerticalAlignment
};

use crate::transform::Transform;

/* The box layout includes the padding and the dimensions
of the wrapped element
The wrapped element position and size should be updated before calling this function
(except for grow behavior).
The wrapped element position is relative to the box position.
*/
pub fn layout_box(session: &mut DiagramBuilder, shape_box: &ShapeBox) {
    println!("Box: {:?}", shape_box);

    // Get the wrapped element dimensions
    let mut wrapped_elem_bounds = session.get_effective_bounds(shape_box.wrapped_entity.clone());

    // Calculate the box dimensions based on size behavior
    let box_width = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(width) => {
            // For fixed width, use the specified width
            width
        }
        SizeBehavior::Content => {
            // Content sizing - size based on wrapped element + padding
            wrapped_elem_bounds.width + shape_box.box_options.padding * 2.0
        }
        SizeBehavior::Grow => {
            // TODO: Implement grow behavior in future iterations
            // For now, fall back to content behavior
            wrapped_elem_bounds.width + shape_box.box_options.padding * 2.0
        }
    };

    // Auto-wrap text if box has fixed width (do this BEFORE positioning)
    if let SizeBehavior::Fixed(fixed_width) = shape_box.box_options.width_behavior {
        let wrapped_entity_type = session.entityTypes.get(&shape_box.wrapped_entity);
        if let Some(EntityType::TextShape) = wrapped_entity_type {
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            auto_wrap_text_in_box(session, &shape_box.wrapped_entity, available_width);
            // Re-get bounds after text wrapping
            wrapped_elem_bounds = session.get_effective_bounds(shape_box.wrapped_entity.clone());
        }
    }

    // Calculate the box height (after potential text wrapping)
    let box_height = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(height) => height,
        SizeBehavior::Content => wrapped_elem_bounds.height + shape_box.box_options.padding * 2.0,
        SizeBehavior::Grow => wrapped_elem_bounds.height + shape_box.box_options.padding * 2.0,
    };

    // Calculate where we want the wrapped element's bounding box to be positioned
    let desired_content_x = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(fixed_width) => {
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            if wrapped_elem_bounds.width <= available_width {
                // Center the content bounding box
                shape_box.box_options.padding + (available_width - wrapped_elem_bounds.width) / 2.0
            } else {
                // Content is larger than available space, align bounding box to left edge
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, position bounding box at padding
            shape_box.box_options.padding
        }
    };

    let desired_content_y = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(fixed_height) => {
            let available_height = fixed_height - shape_box.box_options.padding * 2.0;
            if wrapped_elem_bounds.height <= available_height {
                // Center the content bounding box
                shape_box.box_options.padding
                    + (available_height - wrapped_elem_bounds.height) / 2.0
            } else {
                // Content is larger than available space, align bounding box to top edge
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, position bounding box at padding
            shape_box.box_options.padding
        }
    };

    // FIXED: Apply bounding box compensation when positioning the wrapped element
    let transform_x = desired_content_x - wrapped_elem_bounds.x;
    let transform_y = desired_content_y - wrapped_elem_bounds.y;

    session.set_position(shape_box.wrapped_entity.clone(), transform_x, transform_y);

    println!(
        "Box: {}, width: {}, height: {}, padding: {}, content positioned at: ({}, {})",
        shape_box.entity,
        box_width,
        box_height,
        shape_box.box_options.padding,
        transform_x,
        transform_y
    );

    // Set the box dimensions
    session.set_size(shape_box.entity.clone(), box_width, box_height);
}

fn calculate_optimal_line_width(
    session: &DiagramBuilder,
    text: &str,
    text_options: &TextOptions,
    available_width: Float,
) -> usize {
    // Binary search for optimal line_width
    let mut min_width = 10;
    let mut max_width = text.len();
    let mut best_width = min_width;

    while min_width <= max_width {
        let mid_width = (min_width + max_width) / 2;

        // Test this line_width
        let mut test_options = text_options.clone();
        test_options.line_width = mid_width;

        let wrapped_lines = textwrap::wrap(text, mid_width);
        if wrapped_lines.is_empty() {
            break;
        }

        // Measure the widest line
        let max_line_width = wrapped_lines
            .iter()
            .map(|line| session.measure_text.unwrap()(line, &test_options).0)
            .fold(0.0f32, |a, b| a.max(b));

        if max_line_width <= available_width {
            best_width = mid_width;
            min_width = mid_width + 1; // Try wider
        } else {
            max_width = mid_width - 1; // Try narrower
        }
    }

    best_width
}

// Add this function to layout.rs
fn auto_wrap_text_in_box(
    session: &mut DiagramBuilder,
    text_entity_id: &EntityID,
    available_width: Float,
) {
    // Get the current text shape
    let text_shape = session.get_text(text_entity_id.clone()).clone();

    // Calculate optimal line_width using actual text measurement
    let new_line_width = calculate_optimal_line_width(
        session,
        &text_shape.text,
        &text_shape.text_options,
        available_width,
    );
    // Only re-layout if line_width changed significantly
    if (new_line_width as i32 - text_shape.text_options.line_width as i32).abs() > 5 {
        // Create new text options with updated line_width
        let mut new_text_options = text_shape.text_options.clone();
        new_text_options.line_width = new_line_width;

        // Re-create text lines with new wrapping
        let text_lines = textwrap::wrap(&text_shape.text, new_line_width);
        let mut new_lines = Vec::new();

        // Update existing lines or create new ones
        for (i, line_text) in text_lines.iter().enumerate() {
            let line_id = if i < text_shape.lines.len() {
                // Reuse existing line
                let existing_line_id = text_shape.lines[i].clone();
                let existing_line = session.get_text_line_mut(existing_line_id.clone());
                if let Some(existing_line) = existing_line {
                    existing_line.text = line_text.to_string();
                } else {
                    println!(
                        "Warning: Text line ID {} not found in session",
                        existing_line_id
                    );
                    continue;
                }
                existing_line_id
            } else {
                // Create new line
                // Note: here we are creating new elements on layout
                let line_id = format!("{}-autowrap-line-{}", text_entity_id, i);
                session.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line_text.to_string(),
                };
                session.add_text_line(line_id.clone(), text_line);
                line_id
            };
            new_lines.push(line_id);
        }

        // Update the text shape with new options and lines
        let updated_text_shape = ShapeText {
            entity: text_shape.entity.clone(),
            text: text_shape.text.clone(),
            text_options: new_text_options,
            lines: new_lines,
        };

        // Update the session with the new text shape
        session.add_text(text_entity_id.clone(), updated_text_shape.clone());

        // Re-layout the text with new dimensions
        layout_text(session, &updated_text_shape);
    }
}

// Helper function to estimate character width based on font
fn estimate_char_width(text_options: &TextOptions) -> Float {
    // Rough estimation: font_size * 0.6 for typical fonts
    // You could make this more sophisticated based on font_family
    text_options.font_size * 0.6
}

/**
 * Update the group size based on the size of the elements.
 * Group elements must be positioned before calling this function.
 * (Doesn't update the position of the elements)
 */

pub fn layout_group(session: &mut DiagramBuilder, shape_group: &ShapeGroup) {
    // Calculate actual bounding box using positions, not just max dimensions
    let mut min_x = Float::INFINITY;
    let mut min_y = Float::INFINITY;
    let mut max_x = Float::NEG_INFINITY;
    let mut max_y = Float::NEG_INFINITY;

    for elem in shape_group.elements.iter() {
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let elem_pos = session.get_position(elem.clone()); // Uses transforms behind the scenes

        min_x = min_x.min(elem_pos.0);
        min_y = min_y.min(elem_pos.1);
        max_x = max_x.max(elem_pos.0 + elem_bounds.width);
        max_y = max_y.max(elem_pos.1 + elem_bounds.height);
    }

    if min_x != Float::INFINITY {
        let width = max_x - min_x;
        let height = max_y - min_y;
        session.set_size(shape_group.entity.clone(), width, height);

        // use bounding box compensation since set_position works with transform origins
        let group_bounds = session.get_effective_bounds(shape_group.entity.clone());
        let transform_x = min_x - group_bounds.x;
        let transform_y = min_y - group_bounds.y;
        session.set_position(shape_group.entity.clone(), transform_x, transform_y);
    } else {
        session.set_size(shape_group.entity.clone(), 0.0, 0.0);
        session.set_position(shape_group.entity.clone(), 0.0, 0.0);
    }
}

// WHY this function doesn't need the bounding box compensation:
//
// 1. Text lines don't have individual rotations - they're just positioned within the text entity
// 2. The rotation transform is applied to the parent text entity as a whole
// 3. Individual lines are positioned relative to (0,0) within the text entity
// 4. When the text entity is rotated, all lines rotate together as one unit
//
// Transform hierarchy:
// Text Entity (has rotation transform)
//   └── Line 1 (positioned at 0, 0 relative to text entity)
//   └── Line 2 (positioned at 0, 16 relative to text entity)
//   └── Line 3 (positioned at 0, 32 relative to text entity)
pub fn layout_text(session: &mut DiagramBuilder, shape_text: &ShapeText) {
    let mut y = 0.0;
    let mut max_line_width = 0.0;

    for (i, line) in shape_text.lines.iter().enumerate() {
        let textLine = session.get_text_line(line.clone());
        let line_size = session.measure_text.unwrap()(&textLine.text, &shape_text.text_options);

        if line_size.0 > max_line_width {
            max_line_width = line_size.0;
        }

        session.set_position(line.clone(), 0.0, y);
        session.set_size(line.clone(), line_size.0, line_size.1);

        // Add line height
        y += line_size.1;

        // Add line spacing ONLY between lines (not after the last line)
        if i < shape_text.lines.len() - 1 {
            y += shape_text.text_options.line_spacing;
        }
    }

    // No need to subtract line spacing at the end
    session.set_size(shape_text.entity.clone(), max_line_width, y);
}

pub fn layout_spacer(session: &mut DiagramBuilder, spacer: &ShapeSpacer) {
    let (width, height) = match spacer.spacer_options.direction {
        SpacerDirection::Horizontal => (spacer.spacer_options.width, 1.0),
        SpacerDirection::Vertical => (1.0, spacer.spacer_options.height),
        SpacerDirection::Both => (spacer.spacer_options.width, spacer.spacer_options.height),
    };

    session.set_size(spacer.entity.clone(), width, height);
}

/**
 * Updates the size of the line entity based on the start and end points
 */
pub fn layout_line(session: &mut DiagramBuilder, shape_line: &ShapeLine) {
    let start = shape_line.start;
    let end = shape_line.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_line.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_line.entity.clone(), x, y);
}

/**
 * Updates the size of the arrow entity based on the start and end points
 */
pub fn layout_arrow(session: &mut DiagramBuilder, shape_arrow: &ShapeArrow) {
    let start = shape_arrow.start;
    let end = shape_arrow.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_arrow.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_arrow.entity.clone(), x, y);
}

/**
 * Updates the size of the ellipse entity based on the horizontal and vertical radius
 * radius.0 is the horizontal radius and radius.1 is the vertical radius
 * The position of the ellipse is the top left corner of the bounding box
 */
pub fn layout_ellipse(session: &mut DiagramBuilder, shape_ellipse: &ShapeEllipse) {
    // Only set the size based on radius
    let width = shape_ellipse.radius.0 * 2.0;
    let height = shape_ellipse.radius.1 * 2.0;
    session.set_size(shape_ellipse.entity.clone(), width, height);
}

pub fn layout_rect(session: &mut DiagramBuilder, rect: &ShapeRect) {
    // If the rect has a fixed size, use that
    let width = match rect.rect_options.width_behavior {
        SizeBehavior::Fixed(w) => w,
        _ => 0.0,
    };
    let height = match rect.rect_options.height_behavior {
        SizeBehavior::Fixed(h) => h,
        _ => 0.0,
    };

    session.set_size(rect.entity.clone(), width, height);
}

/**
 * Sets the image entity size to the preferred size
 */
pub fn layout_image(session: &mut DiagramBuilder, shape_image: &ShapeImage) {
    let width = match shape_image.width_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0,
    };

    let height = match shape_image.height_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0,
    };

    session.set_size(shape_image.entity.clone(), width, height);
}
/**
 * Updates the position of the elements in the vertical stack
 * and the size of the vertical stack
 */
pub fn layout_vertical_stack(session: &mut DiagramBuilder, vertical_stack: &VerticalStack) {
    let mut logical_y = 0.0; // Where we want each element's bounding box to start
    let mut width = 0.0;

    for elem in vertical_stack.elements.iter() {
        println!("DEBUG:::y: {}", logical_y);
        let elem_bounds = session.get_effective_bounds(elem.clone());

        // FIXED: Position the element so its bounding box starts at logical_y
        let transform_y = logical_y - elem_bounds.y;
        session.set_position(elem.clone(), 0.0, transform_y);

        // FIXED: Add the effective height to logical_y for next element
        logical_y += elem_bounds.height;

        if elem_bounds.width > width {
            width = elem_bounds.width;
        }
    }

    // Set the stack size to the total logical height
    session.set_size(vertical_stack.entity.clone(), width, logical_y);

    // Second pass: adjust x positions for horizontal alignment
    for elem in vertical_stack.elements.iter() {
        // FIXED: Use effective bounds consistently for alignment calculations
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let current_pos = session.get_position(elem.clone());

        let x = match vertical_stack.horizontal_alignment {
            HorizontalAlignment::Left => -elem_bounds.x, // Compensate for bounding box offset
            HorizontalAlignment::Center => (width - elem_bounds.width) / 2.0 - elem_bounds.x,
            HorizontalAlignment::Right => width - elem_bounds.width - elem_bounds.x,
        };

        session.set_position(elem.clone(), x, current_pos.1); // Update x, keep y
    }
}

pub fn layout_horizontal_stack(session: &mut DiagramBuilder, horizontal_stack: &HorizontalStack) {
    let mut logical_x = 0.0; // Where we want each element's bounding box to start
    let mut height = 0.0;

    for elem in horizontal_stack.elements.iter() {
        let elem_bounds = session.get_effective_bounds(elem.clone());

        // FIXED: Position the element so its bounding box starts at logical_x
        let transform_x = logical_x - elem_bounds.x;
        session.set_position(elem.clone(), transform_x, 0.0);

        // FIXED: Add the effective width to logical_x for next element
        logical_x += elem_bounds.width;

        if elem_bounds.height > height {
            height = elem_bounds.height;
        }
    }

    // Set the stack size to the total logical width
    session.set_size(horizontal_stack.entity.clone(), logical_x, height);

    // Second pass: adjust y positions for vertical alignment
    for elem in horizontal_stack.elements.iter() {
        // FIXED: Use effective bounds consistently for alignment calculations
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let current_pos = session.get_position(elem.clone());

        let y = match horizontal_stack.vertical_alignment {
            VerticalAlignment::Top => -elem_bounds.y, // Compensate for bounding box offset
            VerticalAlignment::Center => (height - elem_bounds.height) / 2.0 - elem_bounds.y,
            VerticalAlignment::Bottom => height - elem_bounds.height - elem_bounds.y,
        };

        session.set_position(elem.clone(), current_pos.0, y);
    }
}
/**
 * Calculates the layout for each of the cells according to table rules:
 * - Cells in the same column have the same width (eq to the max of widths)
 * - Cells in the same row have the same height (eq to the max of heights)
 * - Rows on top of each other
 * - Cols to the right of each other
 * - The sizes of the internal elements should be previously computed for this to work
 */
pub fn layout_table(session: &mut DiagramBuilder, table: &Table) {
    //we need to group elements by row and column, calculate their
    //natural sizes and then update their rows and columns
    let mut rows: Vec<Vec<EntityID>> = Vec::new();
    let mut cols: Vec<Vec<EntityID>> = Vec::new();
    let mut row_heights: Vec<Float> = Vec::new();
    let mut col_widths: Vec<Float> = Vec::new();

    // Add variables to store line positions
    let mut horizontal_line_positions: Vec<Float> = Vec::new();
    let mut vertical_line_positions: Vec<Float> = Vec::new();

    //initialize rows and cols
    for (i, elem) in table.cells.iter().enumerate() {
        let row = i / table.cols;
        let col = i % table.cols;
        //add the element to the row and col
        if row >= rows.len() {
            rows.push(Vec::new());
            row_heights.push(0.0);
        }
        if col >= cols.len() {
            cols.push(Vec::new());
            col_widths.push(0.0);
        }
        rows[row].push(elem.clone());
        cols[col].push(elem.clone());

        //update the row and col sizes
        let elem_bounds = session.get_effective_bounds(elem.clone());

        let content_width = elem_bounds.width + table.table_options.cell_padding as Float * 2.0;
        let content_height = elem_bounds.height + table.table_options.cell_padding as Float * 2.0;
        if content_width > col_widths[col] {
            col_widths[col] = content_width;
        }
        if content_height > row_heights[row] {
            row_heights[row] = content_height;
        }
    }

    //print row heights and col widths
    println!("row heights: {:?}", row_heights);
    println!("col widths: {:?}", col_widths);

    //we already have each row and col and their sizes.
    //Now we have to update the position of each element
    //and the size of the table

    //iterate through rows and cols and update the position of each element
    let mut logical_x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        let mut logical_y = 0.0;
        for (j, elem) in col.iter().enumerate() {
            let elem_bounds = session.get_effective_bounds(elem.clone());

            // Calculate where we want the element's bounding box to be (with padding)
            let desired_x = logical_x + table.table_options.cell_padding as Float;
            let desired_y = logical_y + table.table_options.cell_padding as Float;

            // Compensate for the element's bounding box offset
            let transform_x = desired_x - elem_bounds.x;
            let transform_y = desired_y - elem_bounds.y;

            // FIXED: Instead of overwriting position, add translation to existing transform
            let current_transform = session.get_transform(elem.clone());
            let position_transform = Transform::translation(transform_x, transform_y);
            let new_transform = current_transform.combine(&position_transform);
            session.set_transform(elem.clone(), new_transform);

            logical_y += row_heights[j];
        }
        logical_x += col_widths[i];
    }

    //Update the position of the horizontal lines
    let mut y = 0.0;
    for (i, row) in rows.iter().enumerate() {
        horizontal_line_positions.push(y);
        y += row_heights[i];
    }

    //Update the position of the vertical lines
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        vertical_line_positions.push(x);
        x += col_widths[i];
    }

    //update the size of the table
    let width: Float = col_widths.iter().sum();
    let height: Float = row_heights.iter().sum();

    //Update the size of the table header rect
    session.set_size(table.header_rect.clone(), width, row_heights[0]);

    //print the size of the table
    println!("Table size: {:?}", (width, height));

    session.set_size(table.entity.clone(), width, height);

    //We need to update the position of the horizontal lines and their size
    for (i, line) in table.row_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line.clone());
        if i < horizontal_line_positions.len() {
            //set the y position of the horizontal line, x will be 0
            session.set_position(line.clone(), 0.0, horizontal_line_positions[i]);
            //update the size, we only need to update the height and leave the width as it is (0 by default)
            session.set_size(line.clone(), width, line_size.1);
        }
    }

    for (i, line) in table.col_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line.clone());
        if i < vertical_line_positions.len() {
            //set the x position of the vertical line, y will be 0
            session.set_position(line.clone(), vertical_line_positions[i], 0.0);
            //update the size, we only need to update the width and leave the height as it is (0 by default)
            session.set_size(line.clone(), line_size.0, height);
        }
    }
}

pub fn layout_polyline(session: &mut DiagramBuilder, polyline: &PolyLine) {
    if polyline.points.is_empty() {
        session.set_size(polyline.entity.clone(), 0.0, 0.0);
        return;
    }

    // Find the actual bounding box of all points
    let mut min_x = Float::INFINITY;
    let mut min_y = Float::INFINITY;
    let mut max_x = Float::NEG_INFINITY;
    let mut max_y = Float::NEG_INFINITY;

    for point in polyline.points.iter() {
        min_x = min_x.min(point.0);
        min_y = min_y.min(point.1);
        max_x = max_x.max(point.0);
        max_y = max_y.max(point.1);
    }

    let width = max_x - min_x;
    let height = max_y - min_y;

    // Set the polyline size to its actual bounding box
    session.set_size(polyline.entity.clone(), width, height);
}

/**
 * Layout for the FreeContainer
 * Children have absolute positions relative to the container
 * The container size is determined by the maximum extent of its children
*/
pub fn layout_free_container(session: &mut DiagramBuilder, container: &FreeContainer) {
    let mut max_width = 0.0;
    let mut max_height = 0.0;

    for (child_id, desired_position) in &container.children {
        // TODO: This can be set on creation time
        session.set_position(child_id.clone(), desired_position.0, desired_position.1);

        // FIX: Use effective bounds instead of raw size
        let child_bounds = session.get_effective_bounds(child_id.clone());

        // Calculate the extent based on position + effective bounds dimensions
        let right = desired_position.0 + child_bounds.width; // Use width from bounds
        let bottom = desired_position.1 + child_bounds.height; // Use height from bounds

        if right > max_width {
            max_width = right;
        }
        if bottom > max_height {
            max_height = bottom;
        }
    }

    session.set_size(container.entity.clone(), max_width, max_height);
}

pub fn layout_arc(session: &mut DiagramBuilder, shape_arc: &ShapeArc) {
    let diameter = shape_arc.radius * 2.0;
    session.set_size(shape_arc.entity.clone(), diameter, diameter);
}

//TODO: Hay que cambiar, layout no debe crear el constraint system
// el constraint system se registra en el builder
pub fn layout_constraint_container(session: &mut DiagramBuilder, container: &ConstraintLayoutContainer)-> anyhow::Result<()>{
    println!("layout_constraint_container called");
    let child_sizes:Vec<(String, (Float,Float))> = container.children
        .iter()
        .filter_map(|child_id| {
            Some((child_id.clone(), session.get_size(child_id.clone()).clone()))
        }).collect();
        
    let system = session.get_constraint_system_mut(container.entity.clone());

    // Use existing sizes as suggestions
    // at this point children already have their sizes calculated
    for (child_id, (w,h)) in child_sizes{
            system.suggest_size(child_id.as_str(), w, h).map_err(|e| anyhow::anyhow!("Failed to suggest size for entity {:?}", e))?;
    }

    // Solve constraints
    let results = system.solve()?;

    // Apply results
    let mut container_width = 0.0;
    let mut container_height = 0.0;

    // Negative positions for children are problematic, we compensate by adding an offset
    // if the element that's most to the left has -10, all elements will be added 10 to x

    let mut min_x:Float = INFINITY;
    let mut min_y:Float = INFINITY;

    for(_, (x,y,_,_)) in results.clone() {
        min_x = min_x.min(x);
        min_y = min_y.min(y)
    }

    let offset_x = if min_x < 0.0 {
        min_x.abs()
    } else {
        0.0
    };

    let offset_y = if min_y < 0.0 {
        min_y.abs()
    } else {
        0.0
    };

    println!("offset_x: {}", offset_x);
    println!("offset_y: {}", offset_y);

    // Set final position and size for children
    for (entity_id, (x,y,width,height)) in results {
        println!("constraint variable: {}, x:{}, y:{}, w:{}, h:{}", entity_id.clone(), x, y, width, height);
        session.set_position(entity_id.clone(), x + offset_x, y+ offset_y);
        session.set_size(entity_id.clone(), width, height);
    
        let right = x + offset_x + width;
        let bottom = y + offset_y + height;
        if right > container_width {
            container_width = right;
        }

        if bottom > container_height {
            container_height = bottom;
        }
    }

    println!("container size calculated: {},{}", container_width, container_height);
    session.set_size(container.entity.clone(), container_width, container_height);
    Ok(())
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BoundingBox {
    pub x: Float,
    pub y: Float,
    pub width: Float,
    pub height: Float,
}

//Calculate the layout for a tree of elements
pub fn layout_tree_node(session: &mut DiagramBuilder, root: &DiagramTreeNode) -> BoundingBox {
    //start with the bottom elements
    for child in &root.children {
        println!("Layout child: {:?}", child);
        layout_tree_node(session, child);
        //print size and position of the child

        let child_size = session.get_size(child.entity_id.clone());
        let child_pos = session.get_position(child.entity_id.clone());
        println!("Child size: {:?}", child_size);
        println!("Child pos: {:?}", child_pos);
    }

    //Once the children are laid out, we can layout the current element
    //use methods in the layout module
    match root.entity_type {
        EntityType::SpacerShape => {
            let spacer = session.get_spacer(root.entity_id.clone()).clone();
            layout_spacer(session, &spacer);
        }
        EntityType::TextShape => {
            {
                //get the Shape text entity
                let text = session.get_text(root.entity_id.clone()).clone();
                layout_text(session, &text);
            }
        }
        EntityType::BoxShape => {
            //get the Shape box entity
            let box_shape = session.get_box(root.entity_id.clone()).clone();
            layout_box(session, &box_shape);
        }

        EntityType::RectShape => {
            //get the Rect entity
            let rect = session.get_rectangle(root.entity_id.clone()).clone();
            layout_rect(session, &rect);
        }

        EntityType::LineShape => {
            //get the Shape line entity
            let line = session.get_line(root.entity_id.clone()).clone();
            layout_line(session, &line);
        }
        EntityType::ArrowShape => {
            //get the Shape arrow entity
            let arrow = session.get_arrow(root.entity_id.clone()).clone();
            layout_arrow(session, &arrow);
        }
        EntityType::EllipseShape => {
            //get the Shape ellipse entity
            let ellipse = session.get_ellipse(root.entity_id.clone()).clone();
            layout_ellipse(session, &ellipse);
        }
        EntityType::ImageShape => {
            //get the Shape image entity
            let image = session.get_image(root.entity_id.clone()).clone();
            layout_image(session, &image);
        }
        EntityType::VerticalStackShape => {
            //get the VerticalStack entity
            let vertical_stack = session.get_vertical_stack(root.entity_id.clone()).clone();
            layout_vertical_stack(session, &vertical_stack);
        }

        EntityType::HorizontalStackShape => {
            //get the HorizontalStack entity
            let horizontal_stack = session.get_horizontal_stack(root.entity_id.clone()).clone();
            layout_horizontal_stack(session, &horizontal_stack);
        }

        EntityType::TableShape => {
            //get the Table entity
            let table = session.get_table(root.entity_id.clone()).clone();
            layout_table(session, &table);
        }

        EntityType::GroupShape => {
            //get the Group entity
            let group = session.get_group(root.entity_id.clone()).clone();
            layout_group(session, &group);
        }

        EntityType::PolyLine => {
            let polyline = session.get_polyline(root.entity_id.clone()).clone();
            layout_polyline(session, &polyline);
        }
        EntityType::FreeContainer => {
            let container = session.get_free_container(root.entity_id.clone()).clone();
            layout_free_container(session, &container);
        }

        EntityType::ConstraintLayoutContainer => {
            let container = session.get_constraint_layout(root.entity_id.clone()).clone();
            layout_constraint_container(session, &container);
        }

        EntityType::ArcShape => {
            let arc = session.get_arc(root.entity_id.clone()).clone();
            layout_arc(session, &arc);
        }

        //if not recognized, show the name of it in the panic
        _ => panic!("Unknown entity type: {:?}", root.entity_type),
    }

    session.get_effective_bounds(root.entity_id.clone())
}

//import textoptions defined in src/components/mod.rs
use crate::components::{BoxOptions, TextOptions};
//Test that a box with a text inside is correctly laid out
#[test]
fn test_layout_box_with_text() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //print box options
    println!("--box options: {:?}", box_options);

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());
    //assert equal positions

    // assert the box size is greater than the text size
    println!("box size: {:?}", box_size);
    println!("text size: {:?}", text_size);
    // and the text size should not be zero
    assert!(text_size.0 > 0.0);
    assert_eq!(box_size.0, 30.0);
    assert!(box_size.1 > text_size.1);
}

#[test]
fn test_box_fixed_size() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        width_behavior: SizeBehavior::Fixed(100.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());

    //assert equal positions
    // Assert that the text is centered within the box
    assert_eq!(
        text_position.0,
        box_options.padding
            + (box_options.width_behavior.unwrap_fixed().unwrap()
                - box_options.padding * 2.0
                - text_size.0)
                / 2.0
    );
    assert_eq!(
        text_position.1,
        box_options.padding
            + (box_options.height_behavior.unwrap_fixed().unwrap()
                - box_options.padding * 2.0
                - text_size.1)
                / 2.0
    );
    assert_eq!(box_position, (0.0, 0.0));

    // assert the box size is equal to the fixed size
    assert_eq!(box_size.0, 100.0);
    assert_eq!(box_size.1, 50.0);
}

===/src/constraints/mod.rs===
use crate::components::*;
use anyhow::Result;
use cassowary::strength::{MEDIUM, REQUIRED, STRONG, WEAK};
use cassowary::{AddEditVariableError, Constraint, Solver, Variable, WeightedRelation::*};
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub enum SimpleConstraint {
    // ===== BASIC ALIGNMENT CONSTRAINTS =====
    AlignLeft(EntityID, EntityID),
    /// Align the right edges of two entities  
    AlignRight(EntityID, EntityID),
    /// Align the top edges of two entities
    AlignTop(EntityID, EntityID),
    /// Align the bottom edges of two entities
    AlignBottom(EntityID, EntityID),
    /// Align the horizontal centers of two entities
    AlignCenterHorizontal(EntityID, EntityID),
    /// Align the vertical centers of two entities
    AlignCenterVertical(EntityID, EntityID),

    // ===== DIRECTIONAL POSITIONING CONSTRAINTS =====
    /// First entity is to the right of the second entity
    RightOf(EntityID, EntityID),
    /// First entity is to the left of the second entity
    LeftOf(EntityID, EntityID),
    /// First entity is above the second entity
    Above(EntityID, EntityID),
    /// First entity is below the second entity
    Below(EntityID, EntityID),

    // ===== SPACING CONSTRAINTS =====
    /// Fixed horizontal spacing between two entities (gap between right edge of first and left edge of second)
    HorizontalSpacing(EntityID, EntityID, Float),
    /// Fixed vertical spacing between two entities (gap between bottom edge of first and top edge of second)
    VerticalSpacing(EntityID, EntityID, Float),
    /// Fixed distance between the centers of two entities
    FixedDistance(EntityID, EntityID, Float),

    // ===== SIZE RELATIONSHIP CONSTRAINTS =====
    /// Two entities have the same width
    SameWidth(EntityID, EntityID),
    /// Two entities have the same height
    SameHeight(EntityID, EntityID),
    /// Two entities have the same width and height
    SameSize(EntityID, EntityID),
    /// First entity's width is proportional to second entity's width by the given ratio
    ProportionalWidth(EntityID, EntityID, Float),
    /// First entity's height is proportional to second entity's height by the given ratio
    ProportionalHeight(EntityID, EntityID, Float),

    // ===== ADVANCED LAYOUT CONSTRAINTS =====
    /// Maintain a specific aspect ratio (width/height) for an entity
    AspectRatio(EntityID, Float),
    /// Evenly distribute entities horizontally with equal spacing
    DistributeHorizontally(Vec<EntityID>),
    /// Evenly distribute entities vertically with equal spacing
    DistributeVertically(Vec<EntityID>),
    /// Stack entities horizontally with specified spacing between them
    StackHorizontal(Vec<EntityID>, Float),
    /// Stack entities vertically with specified spacing between them
    StackVertical(Vec<EntityID>, Float),
}

pub struct ConstraintSystem {
    solver: Solver,
    variables: HashMap<String, EntityVars>,
}

struct EntityVars {
    x: Variable,
    y: Variable,
    width: Variable,
    height: Variable,
}

impl ConstraintSystem {
    pub fn new() -> Self {
        Self {
            solver: Solver::new(),
            variables: HashMap::new(),
        }
    }

    pub fn add_entity(&mut self, id: String) -> anyhow::Result<()> {
        let vars = EntityVars {
            x: Variable::new(),
            y: Variable::new(),
            width: Variable::new(),
            height: Variable::new(),
        };

        // Ensure positive sizes
        self.solver
            .add_constraint(vars.width | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add width constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.height | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add height constraint: {:?}", e))?;

        // Mark editable variables
        self.solver
            .add_constraint(vars.width | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add width >= 0 constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.height | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add height >= 0 constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.x | EQ(WEAK) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add default x constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.y | EQ(WEAK) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add default y constraint: {:?}", e))?;

        self.variables.insert(id, vars);
        Ok(())
    }

    pub fn add_constraint(&mut self, constraint: SimpleConstraint) -> Result<()> {
        match constraint {
            SimpleConstraint::AlignLeft(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                self.solver
                    .add_constraint(vars1.x | EQ(REQUIRED) | vars2.x)
                    .map_err(|e| anyhow::anyhow!("Failed to add align left constraint: {:?}", e))?;
            }

            SimpleConstraint::AlignRight(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Right edge = x + width, so: x1 + width1 = x2 + width2
                self.solver
                    .add_constraint(
                        (vars1.x + vars1.width) | EQ(REQUIRED) | (vars2.x + vars2.width),
                    )
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add align right constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::AlignTop(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                self.solver
                    .add_constraint(vars1.y | EQ(REQUIRED) | vars2.y)
                    .map_err(|e| anyhow::anyhow!("Failed to add align top constraint: {:?}", e))?;
            }

            SimpleConstraint::AlignBottom(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Bottom edge = y + height, so: y1 + height1 = y2 + height2
                self.solver
                    .add_constraint(
                        (vars1.y + vars1.height) | EQ(REQUIRED) | (vars2.y + vars2.height),
                    )
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add align bottom constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::AlignCenterHorizontal(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Horizontal center = x + width/2, so: x1 + width1/2 = x2 + width2/2
                self.solver
                    .add_constraint(
                        (vars1.x + vars1.width * 0.5)
                            | EQ(REQUIRED)
                            | (vars2.x + vars2.width * 0.5),
                    )
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add align center horizontal constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::AlignCenterVertical(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Vertical center = y + height/2, so: y1 + height1/2 = y2 + height2/2
                self.solver
                    .add_constraint(
                        (vars1.y + vars1.height * 0.5)
                            | EQ(REQUIRED)
                            | (vars2.y + vars2.height * 0.5),
                    )
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add align center vertical constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::RightOf(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                self.solver
                    .add_constraint(vars1.x | EQ(REQUIRED) | vars2.x + vars2.width)
                    .map_err(|e| anyhow::anyhow!("Failed to add rightOf constraint: {:?}", e))?;
            }

            SimpleConstraint::LeftOf(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                self.solver
                    .add_constraint(vars1.x | EQ(REQUIRED) | vars2.x - vars1.width)
                    .map_err(|e| anyhow::anyhow!("Failed to add leftOf constraint: {:?}", e))?;
            }

            SimpleConstraint::Below(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                self.solver
                    .add_constraint(vars1.y | EQ(REQUIRED) | vars2.y + vars2.height)
                    .map_err(|e| anyhow::anyhow!("Failed to add bottomOf constraint: {:?}", e))?;
            }
            SimpleConstraint::Above(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                self.solver
                    .add_constraint(vars1.y | EQ(REQUIRED) | vars2.y - vars2.height)
                    .map_err(|e| anyhow::anyhow!("Failed to add bottomOf constraint: {:?}", e))?;
            }

            SimpleConstraint::HorizontalSpacing(id1, id2, spacing) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Horizontal spacing: gap between right edge of first and left edge of second
                // x2 = x1 + width1 + spacing
                self.solver
                    .add_constraint(vars2.x | EQ(REQUIRED) | (vars1.x + vars1.width + spacing))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add horizontal spacing constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::VerticalSpacing(id1, id2, spacing) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Vertical spacing: gap between bottom edge of first and top edge of second
                // y2 = y1 + height1 + spacing
                self.solver
                    .add_constraint(vars2.y | EQ(REQUIRED) | (vars1.y + vars1.height + spacing))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add vertical spacing constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::FixedDistance(id1, id2, distance) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");

                // Fixed distance between centers of two entities
                // Distance = sqrt((cx2 - cx1)² + (cy2 - cy1)²)
                // Since Cassowary is a linear solver, we can't directly implement sqrt.
                // We'll use the Manhattan distance as an approximation, or implement
                // a more sophisticated approach using auxiliary variables.

                // For now, let's implement using Manhattan distance (|dx| + |dy| = distance)
                // This is a reasonable approximation for many layout purposes.

                // Create auxiliary variables for the center positions
                let center1_x = Variable::new();
                let center1_y = Variable::new();
                let center2_x = Variable::new();
                let center2_y = Variable::new();

                // Define centers
                self.solver
                    .add_constraint(center1_x | EQ(REQUIRED) | (vars1.x + vars1.width * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center1_x constraint: {:?}", e))?;
                self.solver
                    .add_constraint(center1_y | EQ(REQUIRED) | (vars1.y + vars1.height * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center1_y constraint: {:?}", e))?;
                self.solver
                    .add_constraint(center2_x | EQ(REQUIRED) | (vars2.x + vars2.width * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center2_x constraint: {:?}", e))?;
                self.solver
                    .add_constraint(center2_y | EQ(REQUIRED) | (vars2.y + vars2.height * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center2_y constraint: {:?}", e))?;

                // For Manhattan distance approximation:
                // We'll enforce that the total horizontal and vertical distance equals the target distance
                // This works well for cases where entities are primarily aligned horizontally or vertically

                // Create auxiliary variables for absolute differences
                let dx_pos = Variable::new(); // max(center2_x - center1_x, 0)
                let dx_neg = Variable::new(); // max(center1_x - center2_x, 0)
                let dy_pos = Variable::new(); // max(center2_y - center1_y, 0)
                let dy_neg = Variable::new(); // max(center1_y - center2_y, 0)

                // Ensure non-negative auxiliary variables
                self.solver
                    .add_constraint(dx_pos | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dx_pos >= 0 constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(dx_neg | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dx_neg >= 0 constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(dy_pos | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dy_pos >= 0 constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(dy_neg | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dy_neg >= 0 constraint: {:?}", e)
                    })?;

                // Define the absolute differences
                self.solver
                    .add_constraint((center2_x - center1_x) | EQ(REQUIRED) | (dx_pos - dx_neg))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dx difference constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint((center2_y - center1_y) | EQ(REQUIRED) | (dy_pos - dy_neg))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dy difference constraint: {:?}", e)
                    })?;

                // Manhattan distance constraint: |dx| + |dy| = distance
                self.solver
                    .add_constraint((dx_pos + dx_neg + dy_pos + dy_neg) | EQ(REQUIRED) | distance)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add manhattan distance constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::SameWidth(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Both entities must have identical widths
                self.solver
                    .add_constraint(vars1.width | EQ(REQUIRED) | vars2.width)
                    .map_err(|e| anyhow::anyhow!("Failed to add same width constraint: {:?}", e))?;
            }

            SimpleConstraint::SameHeight(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Both entities must have identical heights
                self.solver
                    .add_constraint(vars1.height | EQ(REQUIRED) | vars2.height)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add same height constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::SameSize(id1, id2) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // Both entities must have identical width AND height
                self.solver
                    .add_constraint(vars1.width | EQ(REQUIRED) | vars2.width)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add same size width constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(vars1.height | EQ(REQUIRED) | vars2.height)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add same size height constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::ProportionalWidth(id1, id2, ratio) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // First entity's width = second entity's width * ratio
                // width1 = width2 * ratio
                self.solver
                    .add_constraint(vars1.width | EQ(REQUIRED) | (vars2.width * ratio))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add proportional width constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::ProportionalHeight(id1, id2, ratio) => {
                let vars1 = self.variables.get(&id1).expect("Entity not found");
                let vars2 = self.variables.get(&id2).expect("Entity not found");
                // First entity's height = second entity's height * ratio
                // height1 = height2 * ratio
                self.solver
                    .add_constraint(vars1.height | EQ(REQUIRED) | (vars2.height * ratio))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add proportional height constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::AspectRatio(id, ratio) => {
                let vars = self.variables.get(&id).expect("Entity not found");
                // Maintain aspect ratio: width / height = ratio
                // Rearranged: width = height * ratio
                self.solver
                    .add_constraint(vars.width | EQ(REQUIRED) | (vars.height * ratio))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add aspect ratio constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::DistributeHorizontally(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!(
                        "DistributeHorizontally requires at least 2 entities"
                    ));
                }

                // Since container size is calculated from children positions,
                // distribution means: equal spacing between consecutive entities
                // The container will size itself to fit all distributed children

                for i in 1..entities.len() {
                    let prev_vars = self
                        .variables
                        .get(&entities[i - 1])
                        .expect("Previous entity not found");
                    let curr_vars = self
                        .variables
                        .get(&entities[i])
                        .expect("Current entity not found");

                    if i == 1 {
                        // First spacing - this becomes our reference spacing
                        continue;
                    }

                    // All spacings must be equal
                    // spacing_i = spacing_1 for all i
                    let prev_prev_vars = self
                        .variables
                        .get(&entities[i - 2])
                        .expect("Previous-previous entity not found");

                    // Current spacing = Previous spacing
                    // (curr.x - prev.x - prev.width) = (prev.x - prev_prev.x - prev_prev.width)
                    let spacing_current = curr_vars.x - prev_vars.x - prev_vars.width;
                    let spacing_reference = prev_vars.x - prev_prev_vars.x - prev_prev_vars.width;

                    self.solver
                        .add_constraint(spacing_current | EQ(REQUIRED) | spacing_reference)
                        .map_err(|e| {
                            anyhow::anyhow!(
                                "Failed to add horizontal distribution constraint: {:?}",
                                e
                            )
                        })?;
                }
            }

            SimpleConstraint::DistributeVertically(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!(
                        "DistributeVertically requires at least 2 entities"
                    ));
                }

                // Since container size is calculated from children positions,
                // vertical distribution means: equal spacing between consecutive entities
                // The container will size itself to fit all distributed children

                for i in 1..entities.len() {
                    let prev_vars = self
                        .variables
                        .get(&entities[i - 1])
                        .expect("Previous entity not found");
                    let curr_vars = self
                        .variables
                        .get(&entities[i])
                        .expect("Current entity not found");

                    if i == 1 {
                        // First spacing becomes our reference spacing
                        continue;
                    }

                    // All spacings must be equal
                    let prev_prev_vars = self
                        .variables
                        .get(&entities[i - 2])
                        .expect("Previous-previous entity not found");

                    // Current spacing = Reference spacing
                    // (curr.y - prev.y - prev.height) = (prev.y - prev_prev.y - prev_prev.height)
                    let spacing_current = curr_vars.y - prev_vars.y - prev_vars.height;
                    let spacing_reference = prev_vars.y - prev_prev_vars.y - prev_prev_vars.height;

                    self.solver
                        .add_constraint(spacing_current | EQ(REQUIRED) | spacing_reference)
                        .map_err(|e| {
                            anyhow::anyhow!(
                                "Failed to add vertical distribution constraint: {:?}",
                                e
                            )
                        })?;
                }
            }

            SimpleConstraint::StackHorizontal(entities, spacing) => {
                if entities.is_empty() {
                    return Err(anyhow::anyhow!(
                        "StackHorizontal requires at least 1 entity"
                    ));
                }

                // Stack entities horizontally with fixed spacing between them
                // entity[i+1].x = entity[i].x + entity[i].width + spacing
                for i in 1..entities.len() {
                    let prev_vars = self
                        .variables
                        .get(&entities[i - 1])
                        .expect("Previous entity not found");
                    let curr_vars = self
                        .variables
                        .get(&entities[i])
                        .expect("Current entity not found");

                    // Current entity starts where previous entity ends plus spacing
                    self.solver
                        .add_constraint(
                            curr_vars.x | EQ(REQUIRED) | (prev_vars.x + prev_vars.width + spacing),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add horizontal stack constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::StackVertical(entities, spacing) => {
                if entities.is_empty() {
                    return Err(anyhow::anyhow!("StackVertical requires at least 1 entity"));
                }

                // Stack entities vertically with fixed spacing between them
                // entity[i+1].y = entity[i].y + entity[i].height + spacing
                for i in 1..entities.len() {
                    let prev_vars = self
                        .variables
                        .get(&entities[i - 1])
                        .expect("Previous entity not found");
                    let curr_vars = self
                        .variables
                        .get(&entities[i])
                        .expect("Current entity not found");

                    // Current entity starts where previous entity ends plus spacing
                    self.solver
                        .add_constraint(
                            curr_vars.y | EQ(REQUIRED) | (prev_vars.y + prev_vars.height + spacing),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add vertical stack constraint: {:?}", e)
                        })?;
                }
            }
        }
        Ok(())
    }

    pub fn solve(&mut self) -> Result<HashMap<String, (f32, f32, f32, f32)>> {
        self.solver.fetch_changes();
        let mut results = HashMap::new();
        for (id, vars) in &self.variables {
            let x = self.solver.get_value(vars.x) as f32;
            let y = self.solver.get_value(vars.y) as f32;
            let width = self.solver.get_value(vars.width) as f32;
            let height = self.solver.get_value(vars.height) as f32;
            results.insert(id.clone(), (x, y, width, height));
        }
        Ok(results)
    }

    pub fn suggest_size(
        &mut self,
        id: &str,
        width: f32,
        height: f32,
    ) -> Result<(), cassowary::SuggestValueError> {
        println!("Suggest_size called {} {} {}", id, width, height);
        if let Some(vars) = self.variables.get(id) {
            let _ = self
                .solver
                .add_constraint(vars.width | EQ(STRONG) | (width as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested width constraint: {:?}", e));
            let _ = self
                .solver
                .add_constraint(vars.height | EQ(STRONG) | (height as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested height constraint: {:?}", e));
        }

        Ok(())
    }

    pub fn suggest_position(
        &mut self,
        id: &str,
        x: f32,
        y: f32,
    ) -> Result<(), cassowary::SuggestValueError> {
        if let Some(vars) = self.variables.get(id) {
            let _ = self
                .solver
                .add_constraint(vars.x | EQ(MEDIUM) | (x as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested x constraint: {:?}", e));
            let _ = self
                .solver
                .add_constraint(vars.y | EQ(MEDIUM) | (y as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested y constraint: {:?}", e));
        }
        Ok(())
    }
}

===/src/lib.rs===

pub use crate::diagram_builder::{DiagramBuilder};
pub use crate::components::*;
pub use crate::constraints::*;
pub use crate::layout::*;
pub use crate::utils::*;
pub use crate::renderer_base::*;

pub mod diagram_builder;
pub mod utils;
pub mod components;
pub mod constraints;
pub mod layout;
pub mod renderer_base;
pub mod parser;
pub mod transform;

#[cfg(test)]
mod tests;

===/src/tests/rotation_tests.rs===
#[cfg(test)]
mod simple_rotation_test {
    use crate::transform::Transform;
    use crate::{Fill, RectOptions, SizeBehavior};
    use crate::{DiagramBuilder, layout::layout_tree_node};

    #[test]
    fn test_90_degree_rotation_bounding_box() {
        println!("🧪 Testing 90° rotation bounding box...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create a 100x50 rectangle (wide rectangle)
        let rect_opts = RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(50.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "darkblue".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        };
        
        let rect = builder.new_rectangle("test_rect".to_string(), rect_opts);
        
        // Apply 90° rotation
        let rotation_transform = Transform::rotation(90.0);
        builder.set_transform("test_rect".to_string(), rotation_transform);
        
        // Layout the rectangle
        layout_tree_node(&mut builder, &rect);
        
        // Get the effective bounds
        let bounds = builder.get_effective_bounds("test_rect".to_string());
        
        println!("📏 Original size: 100x50 (wide rectangle)");
        println!("📐 Rotation: 90°");
        println!("📦 Effective bounds: w={:.1}, h={:.1}", bounds.width, bounds.height);
        
        // After 90° rotation: width and height should swap
        // Original: 100 wide, 50 tall → Rotated: 50 wide, 100 tall
        assert_eq!(bounds.width as i32, 50, "90° rotated width should be 50, got {:.1}", bounds.width);
        assert_eq!(bounds.height as i32, 100, "90° rotated height should be 100, got {:.1}", bounds.height);
        
        println!("✅ 90° rotation test passed! Dimensions swapped correctly.");
    }
}


#[cfg(test)]
mod debug_rotation_positioning {
    use super::*;
    use crate::transform::Transform;
    use crate::{Fill, HorizontalAlignment, RectOptions, SizeBehavior, VerticalAlignment};
    use crate::{DiagramBuilder, layout::layout_tree_node};

    #[test]
    fn test_debug_rotation_positioning() {
        println!("🧪 Debugging rotation positioning...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create the same setup as your JSONL test
        let normal_rect = builder.new_rectangle("normal_rect".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("red".to_string()),
            stroke_color: "darkred".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        let rotated_rect = builder.new_rectangle("rotated_rect".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "darkblue".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        let normal_rect2 = builder.new_rectangle("normal_rect2".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("green".to_string()),
            stroke_color: "darkgreen".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        // Apply rotation to middle rectangle
        let rotation_transform = Transform::rotation(45.0);
        builder.set_transform("rotated_rect".to_string(), rotation_transform);
        
        println!("🔍 BEFORE LAYOUT:");
        println!("  Normal rect bounds: {:?}", builder.get_effective_bounds("normal_rect".to_string()));
        println!("  Rotated rect bounds: {:?}", builder.get_effective_bounds("rotated_rect".to_string()));
        println!("  Normal rect2 bounds: {:?}", builder.get_effective_bounds("normal_rect2".to_string()));
        
        // Create horizontal stack
        let hstack = builder.new_hstack("root".to_string(), 
                                       vec![normal_rect, rotated_rect, normal_rect2], 
                                       VerticalAlignment::Center);
        
        // Layout the stack
        layout_tree_node(&mut builder, &hstack);
        
        println!("🔍 AFTER LAYOUT:");
        println!("  Normal rect position: {:?}", builder.get_position("normal_rect".to_string()));
        println!("  Normal rect bounds: {:?}", builder.get_effective_bounds("normal_rect".to_string()));
        
        println!("  Rotated rect position: {:?}", builder.get_position("rotated_rect".to_string()));
        println!("  Rotated rect bounds: {:?}", builder.get_effective_bounds("rotated_rect".to_string()));
        println!("  Rotated rect transform: {:?}", builder.get_transform("rotated_rect".to_string()));
        
        println!("  Normal rect2 position: {:?}", builder.get_position("normal_rect2".to_string()));
        println!("  Normal rect2 bounds: {:?}", builder.get_effective_bounds("normal_rect2".to_string()));
        
        println!("  Stack total size: {:?}", builder.get_size("root".to_string()));
        
        // Check if there's overlap
        let rect1_bounds = builder.get_effective_bounds("normal_rect".to_string());
        let rect2_bounds = builder.get_effective_bounds("rotated_rect".to_string());
        let rect3_bounds = builder.get_effective_bounds("normal_rect2".to_string());
        
        println!("🔍 OVERLAP CHECK:");
        println!("  Rect1 occupies: x={:.1} to x={:.1}", rect1_bounds.x, rect1_bounds.x + rect1_bounds.width);
        println!("  Rect2 occupies: x={:.1} to x={:.1}", rect2_bounds.x, rect2_bounds.x + rect2_bounds.width);
        println!("  Rect3 occupies: x={:.1} to x={:.1}", rect3_bounds.x, rect3_bounds.x + rect3_bounds.width);
        
        // Check for actual overlap
        let rect1_end = rect1_bounds.x + rect1_bounds.width;
        let rect2_start = rect2_bounds.x;
        let rect2_end = rect2_bounds.x + rect2_bounds.width;
        let rect3_start = rect3_bounds.x;
        
        if rect2_start < rect1_end {
            println!("❌ OVERLAP DETECTED: Rect2 starts at {:.1} but Rect1 ends at {:.1}", rect2_start, rect1_end);
        } else {
            println!("✅ No overlap between Rect1 and Rect2");
        }
        
        if rect3_start < rect2_end {
            println!("❌ OVERLAP DETECTED: Rect3 starts at {:.1} but Rect2 ends at {:.1}", rect3_start, rect2_end);
        } else {
            println!("✅ No overlap between Rect2 and Rect3");
        }
    }
}
===/src/tests/mod.rs===
pub mod rotation_tests;
===/src/components/mod.rs===
pub mod table;

use crate::constraints::{ConstraintSystem, SimpleConstraint};
use core::fmt;
use std::{any::Any, collections::HashMap, sync::Arc};

use serde_json::{Map, Value};

pub use crate::components::table::*;
//new type EntityID that is a u64
pub type EntityID = String;
pub type Float = f32;

//Export table and table options

pub trait Entity {
    fn get_id(&self) -> EntityID;
    fn get_type(&self) -> EntityType;
    //as_any
    fn as_any(&self) -> &dyn Any;
}

pub struct Point {
    pub x: Float,
    pub y: Float,
}

//impl clone
impl Clone for Point {
    fn clone(&self) -> Self {
        Point {
            x: self.x,
            y: self.y,
        }
    }
}

//impl new
impl Point {
    pub fn new(x: Float, y: Float) -> Self {
        Point { x, y }
    }
}

pub struct Size {
    pub w: Float,
    pub h: Float,
}

//impl clone
impl Clone for Size {
    fn clone(&self) -> Self {
        Size {
            w: self.w,
            h: self.h,
        }
    }
}

//impl new
impl Size {
    pub fn new(w: Float, h: Float) -> Self {
        Size { w, h }
    }
}

//Note: add new items to the end of the enum to avoid breaking the serialization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EntityType {
    BoxShape,
    RectShape,
    TextShape,
    LineShape,
    ArrowShape,
    EllipseShape,
    ImageShape,
    GroupShape,
    VerticalStackShape,
    HorizontalStackShape,
    TableShape,
    TextLine,
    PolyLine,
    FreeContainer,
    ArcShape,
    SpacerShape,
    ConstraintLayoutContainer,
}

#[derive(Debug, Copy, PartialEq)]
pub enum SizeBehavior {
    /// Fixed size - element has a predetermined size that doesn't change
    Fixed(Float),
    /// Content size - element sizes itself based on its content (current default behavior)
    Content,
    /// Grow size - element takes all available space from its parent
    Grow,
}

impl Default for SizeBehavior {
    fn default() -> Self {
        SizeBehavior::Content
    }
}

impl Eq for SizeBehavior {}

impl Clone for SizeBehavior {
    fn clone(&self) -> Self {
        match self {
            SizeBehavior::Fixed(v) => SizeBehavior::Fixed(*v),
            SizeBehavior::Content => SizeBehavior::Content,
            SizeBehavior::Grow => SizeBehavior::Grow,
        }
    }
}

impl SizeBehavior {
    pub fn unwrap_fixed(&self) -> Result<f32, &'static str> {
        match self {
            SizeBehavior::Fixed(val) => Ok(*val),
            _ => Err("Called unwrap_fixed on non-Fixed SizeBehavior"),
        }
    }
}

// Add spacer component
pub struct ShapeSpacer {
    pub entity: EntityID,
    pub spacer_options: SpacerOptions,
}

impl ShapeSpacer {
    pub fn new(entity: EntityID, spacer_options: SpacerOptions) -> ShapeSpacer {
        ShapeSpacer {
            entity,
            spacer_options,
        }
    }
}

impl Clone for ShapeSpacer {
    fn clone(&self) -> Self {
        ShapeSpacer {
            entity: self.entity.clone(),
            spacer_options: self.spacer_options.clone(),
        }
    }
}

#[derive(Default, Debug)]
pub struct SpacerOptions {
    pub width: Float,
    pub height: Float,
    pub direction: SpacerDirection, // Horizontal, Vertical, or Both
}

impl Clone for SpacerOptions {
    fn clone(&self) -> Self {
        SpacerOptions {
            width: self.width,
            height: self.height,
            direction: self.direction.clone(),
        }
    }
}

#[derive(Debug)]
pub enum SpacerDirection {
    Horizontal, // Takes up width, minimal height
    Vertical,   // Takes up height, minimal width
    Both,       // Takes up both dimensions
}

impl Default for SpacerDirection {
    fn default() -> Self {
        SpacerDirection::Vertical
    }
}

impl Clone for SpacerDirection {
    fn clone(&self) -> Self {
        match self {
            SpacerDirection::Horizontal => SpacerDirection::Horizontal,
            SpacerDirection::Vertical => SpacerDirection::Vertical,
            SpacerDirection::Both => SpacerDirection::Both,
        }
    }
}

/**
 * Boxes show a rectangle around the wrapped entity
 */
#[derive(Debug)]
pub struct ShapeBox {
    pub entity: EntityID,
    //Each box wraps another entity
    pub wrapped_entity: EntityID,
    pub box_options: BoxOptions,
}

impl Clone for ShapeBox {
    fn clone(&self) -> Self {
        ShapeBox {
            entity: self.entity.clone(),
            wrapped_entity: self.wrapped_entity.clone(),
            box_options: self.box_options.clone(),
        }
    }
}

impl Entity for ShapeBox {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::BoxShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeBox {
    pub fn new(entity: EntityID, wrapped_entity: EntityID, box_options: BoxOptions) -> ShapeBox {
        ShapeBox {
            entity,
            wrapped_entity,
            box_options,
        }
    }
}

#[derive(Debug)]
pub enum GradientStop {
    ColorStop { offset: Float, color: String },
    OpacityStop { offset: Float, opacity: Float },
}

#[derive(Debug)]
pub struct LinearGradient {
    pub x1: Float,
    pub y1: Float,
    pub x2: Float,
    pub y2: Float,
    pub stops: Vec<GradientStop>,
}

impl LinearGradient {
    pub fn new(x1: Float, y1: Float, x2: Float, y2: Float, stops: Vec<GradientStop>) -> Self {
        LinearGradient {
            x1,
            y1,
            x2,
            y2,
            stops,
        }
    }
}

impl Clone for GradientStop {
    fn clone(&self) -> Self {
        match self {
            GradientStop::ColorStop { offset, color } => GradientStop::ColorStop {
                offset: *offset,
                color: color.clone(),
            },
            GradientStop::OpacityStop { offset, opacity } => GradientStop::OpacityStop {
                offset: *offset,
                opacity: *opacity,
            },
        }
    }
}

#[derive(Debug)]
pub struct RadialGradient {
    pub cx: Float,
    pub cy: Float,
    pub r: Float,
    pub stops: Vec<GradientStop>,
}

impl Clone for RadialGradient {
    fn clone(&self) -> Self {
        RadialGradient {
            cx: self.cx,
            cy: self.cy,
            r: self.r,
            stops: self.stops.clone(),
        }
    }
}

impl Clone for LinearGradient {
    fn clone(&self) -> Self {
        LinearGradient {
            x1: self.x1,
            y1: self.y1,
            x2: self.x2,
            y2: self.y2,
            stops: self.stops.clone(),
        }
    }
}

#[derive(Debug)]
pub enum Fill {
    Color(String),
    LinearGradient(LinearGradient),
    RadialGradient(RadialGradient),
}

impl Clone for Fill {
    fn clone(&self) -> Self {
        match self {
            Fill::Color(color) => Fill::Color(color.clone()),
            Fill::LinearGradient(gradient) => Fill::LinearGradient(gradient.clone()),
            Fill::RadialGradient(gradient) => Fill::RadialGradient(gradient.clone()),
        }
    }
}
//default trait for fill
impl Default for Fill {
    fn default() -> Self {
        Fill::Color(String::from("white"))
    }
}

//display for fill
impl fmt::Display for Fill {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Fill::Color(color) => write!(f, "{}", color),
            Fill::LinearGradient(gradient) => write!(f, "{:?}", gradient),
            Fill::RadialGradient(gradient) => write!(f, "{:?}", gradient),
        }
    }
}

impl PartialEq for Fill {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Fill::Color(a), Fill::Color(b)) => a == b,
            (Fill::LinearGradient(a), Fill::LinearGradient(b)) => a == b,
            (Fill::RadialGradient(a), Fill::RadialGradient(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for Fill {}

impl PartialEq for LinearGradient {
    fn eq(&self, other: &Self) -> bool {
        self.x1 == other.x1
            && self.y1 == other.y1
            && self.x2 == other.x2
            && self.y2 == other.y2
            && self.stops == other.stops
    }
}

impl Eq for LinearGradient {}

impl PartialEq for RadialGradient {
    fn eq(&self, other: &Self) -> bool {
        self.cx == other.cx && self.cy == other.cy && self.r == other.r && self.stops == other.stops
    }
}

impl Eq for RadialGradient {}

impl PartialEq for GradientStop {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                GradientStop::ColorStop {
                    offset: a_offset,
                    color: a_color,
                },
                GradientStop::ColorStop {
                    offset: b_offset,
                    color: b_color,
                },
            ) => a_offset == b_offset && a_color == b_color,
            (
                GradientStop::OpacityStop {
                    offset: a_offset,
                    opacity: a_opacity,
                },
                GradientStop::OpacityStop {
                    offset: b_offset,
                    opacity: b_opacity,
                },
            ) => a_offset == b_offset && a_opacity == b_opacity,
            _ => false,
        }
    }
}

impl Eq for GradientStop {}

#[derive(Debug)]
pub struct BoxOptions {
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub padding: Float,
    pub border_radius: Float,
    // Add size behavior fields
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
}

impl Clone for BoxOptions {
    fn clone(&self) -> Self {
        BoxOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            padding: self.padding,
            border_radius: self.border_radius,
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
        }
    }
}

impl Default for BoxOptions {
    fn default() -> Self {
        BoxOptions::new()
    }
}

impl BoxOptions {
    pub fn new() -> BoxOptions {
        BoxOptions {
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            padding: 10.0,
            border_radius: 0.0,
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
        }
    }
}

/* A group of entities */

//RectOptions
#[derive(Default, Debug)]
pub struct RectOptions {
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub border_radius: Float,
}

impl Clone for RectOptions {
    fn clone(&self) -> Self {
        RectOptions {
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            border_radius: self.border_radius,
        }
    }
}

impl RectOptions {
    pub fn new() -> RectOptions {
        RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(100.0),
            // Default fill color is white
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            border_radius: 0.0,
        }
    }
}

pub struct ShapeRect {
    pub entity: EntityID,
    pub rect_options: RectOptions,
}

impl ShapeRect {
    pub fn new(entity: EntityID, rect_options: RectOptions) -> ShapeRect {
        ShapeRect {
            entity,
            rect_options,
        }
    }
}

impl Clone for ShapeRect {
    fn clone(&self) -> Self {
        ShapeRect {
            entity: self.entity.clone(),
            rect_options: self.rect_options.clone(),
        }
    }
}

impl Entity for ShapeRect {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::RectShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

/* A group of entities */
pub struct ShapeGroup {
    pub entity: EntityID,
    pub elements: Vec<EntityID>,
}

impl Clone for ShapeGroup {
    fn clone(&self) -> Self {
        ShapeGroup {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
        }
    }
}

impl Entity for ShapeGroup {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::GroupShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

// Represents a line after adding breaks
#[derive(Debug)]
pub struct TextLine {
    pub entity: EntityID,
    pub text: String,
}

impl Clone for TextLine {
    fn clone(&self) -> Self {
        TextLine {
            entity: self.entity.clone(),
            text: self.text.clone(),
        }
    }
}

impl Entity for TextLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
//add copy trait
#[derive(Debug)]
pub struct ShapeText {
    pub entity: EntityID,
    pub text: String,
    pub text_options: TextOptions,
    pub lines: Vec<EntityID>,
}

impl Clone for ShapeText {
    fn clone(&self) -> Self {
        ShapeText {
            entity: self.entity.clone(),
            text: self.text.clone(),
            text_options: self.text_options.clone(),
            lines: self.lines.clone(),
        }
    }
}

impl ShapeText {
    pub fn new(
        entity: EntityID,
        text: &str,
        text_options: TextOptions,
        lines: &[EntityID],
    ) -> ShapeText {
        ShapeText {
            entity,
            text: text.to_string(),
            text_options,
            lines: lines.to_vec(),
        }
    }
}

impl Entity for ShapeText {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

//struct with text options: font family, font size
#[derive(Default, Debug)]
pub struct TextOptions {
    pub font_family: String,
    pub font_size: f32,
    pub text_color: String,
    // (number of max characters per line)used to know when to insert breaks
    pub line_width: usize,
    pub line_spacing: f32, // spacing between lines
}

impl Clone for TextOptions {
    fn clone(&self) -> Self {
        TextOptions {
            font_family: self.font_family.clone(),
            font_size: self.font_size,
            text_color: self.text_color.clone(),
            line_width: self.line_width,
            line_spacing: self.line_spacing,
        }
    }
}

impl TextOptions {
    pub fn new() -> TextOptions {
        TextOptions {
            font_family: String::from("Roboto"),
            font_size: 12.0,
            text_color: String::from("black"),
            line_width: 20,
            line_spacing: 0.0,
        }
    }
}

pub enum HorizontalAlignment {
    Left,
    Center,
    Right,
}

impl Clone for HorizontalAlignment {
    fn clone(&self) -> Self {
        match self {
            HorizontalAlignment::Left => HorizontalAlignment::Left,
            HorizontalAlignment::Center => HorizontalAlignment::Center,
            HorizontalAlignment::Right => HorizontalAlignment::Right,
        }
    }
}

pub struct VerticalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub horizontal_alignment: HorizontalAlignment,
}

impl Clone for VerticalStack {
    fn clone(&self) -> Self {
        VerticalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            horizontal_alignment: self.horizontal_alignment.clone(),
        }
    }
}

impl Entity for VerticalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::VerticalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub enum VerticalAlignment {
    Top,
    Center,
    Bottom,
}

impl Clone for VerticalAlignment {
    fn clone(&self) -> Self {
        match self {
            VerticalAlignment::Top => VerticalAlignment::Top,
            VerticalAlignment::Center => VerticalAlignment::Center,
            VerticalAlignment::Bottom => VerticalAlignment::Bottom,
        }
    }
}
impl fmt::Display for VerticalAlignment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerticalAlignment::Top => write!(f, "Top"),
            VerticalAlignment::Center => write!(f, "Center"),
            VerticalAlignment::Bottom => write!(f, "Bottom"),
        }
    }
}
//enum for horizontal stack

pub struct HorizontalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub vertical_alignment: VerticalAlignment, // Optional vertical alignment (e.g., "top", "center", "bottom")
}

impl Clone for HorizontalStack {
    fn clone(&self) -> Self {
        HorizontalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            vertical_alignment: self.vertical_alignment.clone(),
        }
    }
}

impl Entity for HorizontalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::HorizontalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ShapeLine {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub line_options: LineOptions,
}

impl Clone for ShapeLine {
    fn clone(&self) -> Self {
        ShapeLine {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            line_options: self.line_options.clone(),
        }
    }
}

impl ShapeLine {
    pub fn new(
        line_id: EntityID,
        start: (Float, Float),
        end: (Float, Float),
        options: LineOptions,
    ) -> ShapeLine {
        ShapeLine {
            entity: line_id,
            start,
            end,
            line_options: options,
        }
    }
}

impl Entity for ShapeLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::LineShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct LineOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for LineOptions {
    fn clone(&self) -> Self {
        LineOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl LineOptions {
    pub fn new() -> LineOptions {
        LineOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct PolyLine {
    pub entity: EntityID,
    pub points: Vec<(Float, Float)>,
    pub line_options: LineOptions,
}

impl PolyLine {
    pub fn new(
        entity: EntityID,
        points: Vec<(Float, Float)>,
        line_options: LineOptions,
    ) -> PolyLine {
        PolyLine {
            entity,
            points,
            line_options,
        }
    }
}

impl Entity for PolyLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::PolyLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl Clone for PolyLine {
    fn clone(&self) -> Self {
        PolyLine {
            entity: self.entity.clone(),
            points: self.points.clone(),
            line_options: self.line_options.clone(),
        }
    }
}

pub struct ShapeArrow {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub arrow_options: ArrowOptions,
}

impl Clone for ShapeArrow {
    fn clone(&self) -> Self {
        ShapeArrow {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            arrow_options: self.arrow_options.clone(),
        }
    }
}

impl Entity for ShapeArrow {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArrowShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct ArrowOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
    pub arrow_size: Float,
}

impl Clone for ArrowOptions {
    fn clone(&self) -> Self {
        ArrowOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            arrow_size: self.arrow_size,
        }
    }
}

impl ArrowOptions {
    pub fn new() -> ArrowOptions {
        ArrowOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            arrow_size: 10.0,
        }
    }
}

pub struct ShapeEllipse {
    pub entity: EntityID,
    pub radius: (Float, Float),
    pub ellipse_options: EllipseOptions,
}

impl Clone for ShapeEllipse {
    fn clone(&self) -> Self {
        ShapeEllipse {
            entity: self.entity.clone(),
            radius: self.radius,
            ellipse_options: self.ellipse_options.clone(),
        }
    }
}

impl ShapeEllipse {
    pub fn new(
        entity: EntityID,
        radius: (Float, Float),
        ellipse_options: EllipseOptions,
    ) -> ShapeEllipse {
        ShapeEllipse {
            entity,
            radius,
            ellipse_options,
        }
    }
}

impl Entity for ShapeEllipse {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::EllipseShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct EllipseOptions {
    //TODO: convert to Fill
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for EllipseOptions {
    fn clone(&self) -> Self {
        EllipseOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl EllipseOptions {
    pub fn new() -> EllipseOptions {
        EllipseOptions {
            fill_color: String::from("white"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct ShapeImage {
    pub entity: EntityID,
    //base64 encoded image or empty if using file_path
    pub image: String,
    //path to image file on disk (optional)
    pub file_path: Option<String>,
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
}

impl Clone for ShapeImage {
    fn clone(&self) -> Self {
        ShapeImage {
            entity: self.entity.clone(),
            image: self.image.clone(),
            file_path: self.file_path.clone(),
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
        }
    }
}

impl Entity for ShapeImage {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ImageShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeImage {
    pub fn new(entity: EntityID, image: String, size: (SizeBehavior, SizeBehavior)) -> ShapeImage {
        ShapeImage {
            entity,
            image,
            file_path: None,
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }

    pub fn from_file(
        entity: EntityID,
        file_path: String,
        size: (SizeBehavior, SizeBehavior),
    ) -> ShapeImage {
        ShapeImage {
            entity,
            image: String::new(), // Empty as we're using file_path instead
            file_path: Some(file_path),
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }
}

// A container that uses constraints to position its children
pub struct ConstraintLayoutContainer {
    pub entity: EntityID,
    pub children: Vec<EntityID>,
}

impl Clone for ConstraintLayoutContainer {
    fn clone(&self) -> Self {
        ConstraintLayoutContainer {
            entity: self.entity.clone(),
            children: self.children.clone(),
        }
    }
}


impl Entity for ConstraintLayoutContainer {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ConstraintLayoutContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ConstraintLayoutContainer {
    pub fn new(entity: EntityID, children: Vec<String>)->Self{
        ConstraintLayoutContainer{
            entity: entity,
            children: children,
        }
    }
}

/// A container that allows children to be positioned with absolute coordinates
/// Children's positions are relative to the container's top-left corner
pub struct FreeContainer {
    pub entity: EntityID,
    pub children: Vec<(EntityID, (Float, Float))>, // Each child has a position relative to the container
    pub background_color: Option<String>,          // Optional background color
    pub border_color: Option<String>,              // Optional border color
    pub border_width: Float,                       // Border width (0 for no border)
}

impl Clone for FreeContainer {
    fn clone(&self) -> Self {
        FreeContainer {
            entity: self.entity.clone(),
            children: self.children.clone(),
            background_color: self.background_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
        }
    }
}

impl Entity for FreeContainer {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::FreeContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl FreeContainer {
    /// Create a new empty FreeContainer
    pub fn new(entity: EntityID) -> Self {
        FreeContainer {
            entity,
            children: Vec::new(),
            background_color: None,
            border_color: None,
            border_width: 0.0,
        }
    }

    /// Add a child to the container at the specified position
    pub fn add_child(&mut self, child_id: EntityID, position: (Float, Float)) {
        self.children.push((child_id, position));
    }

    /// Add multiple children at once with their positions
    pub fn with_children(
        mut self,
        children_with_positions: Vec<(EntityID, (Float, Float))>,
    ) -> Self {
        self.children.extend(children_with_positions);
        self
    }

    /// Set background color
    pub fn with_background_color(mut self, color: &str) -> Self {
        self.background_color = Some(color.to_string());
        self
    }

    /// Set border properties
    pub fn with_border(mut self, color: &str, width: Float) -> Self {
        self.border_color = Some(color.to_string());
        self.border_width = width;
        self
    }
}

// Arc options structure
#[derive(Default, Debug)]
pub struct ArcOptions {
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub filled: bool, // Whether to fill the arc sector or just draw the outline
}

impl Clone for ArcOptions {
    fn clone(&self) -> Self {
        ArcOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            filled: self.filled,
        }
    }
}

impl ArcOptions {
    pub fn new() -> ArcOptions {
        ArcOptions {
            fill_color: String::from("none"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            filled: false,
        }
    }
}

// Arc shape structure
pub struct ShapeArc {
    pub entity: EntityID,
    pub radius: Float,      // Radius of the arc
    pub start_angle: Float, // Start angle in degrees
    pub end_angle: Float,   // End angle in degrees
    pub arc_options: ArcOptions,
}

impl Clone for ShapeArc {
    fn clone(&self) -> Self {
        ShapeArc {
            entity: self.entity.clone(),
            radius: self.radius,
            start_angle: self.start_angle,
            end_angle: self.end_angle,
            arc_options: self.arc_options.clone(),
        }
    }
}

impl ShapeArc {
    pub fn new(
        entity: EntityID,
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        arc_options: ArcOptions,
    ) -> ShapeArc {
        ShapeArc {
            entity,
            radius,
            start_angle,
            end_angle,
            arc_options,
        }
    }

    /// Normalize angles to 0-360 degree range
    pub fn normalize_angles(&self) -> (Float, Float) {
        let mut start = self.start_angle % 360.0;
        let mut end = self.end_angle % 360.0;

        if start < 0.0 {
            start += 360.0;
        }
        if end < 0.0 {
            end += 360.0;
        }

        (start, end)
    }

    /// Calculate the angle sweep of the arc
    pub fn angle_sweep(&self) -> Float {
        let (start, end) = self.normalize_angles();
        if end > start {
            end - start
        } else {
            360.0 - start + end
        }
    }

    /// Check if this is a major arc (> 180 degrees)
    pub fn is_major_arc(&self) -> bool {
        self.angle_sweep() > 180.0
    }
}

impl Entity for ShapeArc {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArcShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

/// Type alias for custom component factory functions
/// Takes a map of attributes and a mutable reference to DiagramBuilder
/// Returns a Result with either a DiagramTreeNode or an error message
pub type CustomComponentFactory = Arc<
    dyn Fn(
            &Map<String, Value>,
            &mut crate::DiagramBuilder,
        ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
        + Send
        + Sync,
>;

/// Registry for custom components
pub struct CustomComponentRegistry {
    factories: HashMap<String, CustomComponentFactory>,
}

impl CustomComponentRegistry {
    pub fn new() -> Self {
        Self {
            factories: HashMap::new(),
        }
    }

    /// Register a new custom component with the given identifier and factory function
    pub fn register<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &Map<String, Value>,
                &mut crate::DiagramBuilder,
            ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
            + Send
            + Sync
            + 'static,
    {
        self.factories
            .insert(component_type.to_string(), Arc::new(factory));
    }

    /// Create a component instance using the registered factory
    pub fn create_component(
        &self,
        component_type: &str,
        attributes: &Map<String, Value>,
        builder: &mut crate::DiagramBuilder,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        match self.factories.get(component_type) {
            Some(factory) => factory(attributes, builder),
            None => Err(format!("Unknown custom component type: {}", component_type)),
        }
    }

    /// Check if a component type is registered
    pub fn has_component(&self, component_type: &str) -> bool {
        self.factories.contains_key(component_type)
    }

    /// Get all registered component types
    pub fn get_registered_types(&self) -> Vec<&String> {
        self.factories.keys().collect()
    }

    pub fn get(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &serde_json::Map<String, serde_json::Value>,
                    &mut crate::diagram_builder::DiagramBuilder,
                ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
                + Send
                + Sync,
        >,
    > {
        self.factories.get(component_type)
    }
}

impl Default for CustomComponentRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions for extracting common attribute types
impl CustomComponentRegistry {
    /// Helper to extract a string attribute with a default value
    pub fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    /// Helper to extract a float attribute with a default value
    pub fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    /// Helper to extract a boolean attribute with a default value
    pub fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    /// Helper to extract an integer attribute with a default value
    pub fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }
}

#[cfg(test)]
mod custom_component_tests {
    use super::*;
    use crate::*;
    use serde_json::json;

    /// Test custom component: Badge
    /// Creates a rounded box with text and a colored background
    fn create_badge_component(
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        // Extract attributes with defaults
        let text = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("Badge")
            .to_string();

        let id = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string();

        let textNode = builder.new_text(id, &text, TextOptions::default());
        Ok(textNode)
    }

    #[test]
    fn test_custom_component_registry() {
        let mut registry = CustomComponentRegistry::new();

        // Register badge component
        registry.register("badge", create_badge_component);

        // Test that components are registered
        assert!(registry.has_component("badge"));
        assert!(!registry.has_component("unknown"));

        // Test getting registered types
        let types = registry.get_registered_types();
        assert_eq!(types.len(), 1);
        assert!(types.contains(&&"badge".to_string()));
    }

    #[test]
    fn test_create_badge_component() {
        let mut registry = CustomComponentRegistry::new();
        registry.register("badge", create_badge_component);

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));

        // Create badge with custom attributes
        let attrs = json!({
            "text": "NEW",
            "background_color": "red",
            "text_color": "white",
            "font_size": 14.0,
            "padding": 6.0,
            "border_radius": 20.0
        });

        let attrs_map = attrs.as_object().unwrap();
        let badge = registry.create_component("badge", attrs_map, &mut builder);

        assert!(badge.is_ok());
        let badge_node = badge.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::TextShape);
    }
}

===/src/components/table.rs===

//use EntityID
use crate::components::*;


pub struct TableOptions {
    pub fill_color: String,
    pub header_fill_color: String,
    pub border_color: String,
    pub border_width: usize,
    pub cell_padding: usize,
}

/* A table contains a list of rows, each row has a cell 
* which is a group that contains other elements.

Tables are defined with an array of cells and the number of columns
*/
pub struct Table {
    pub entity: EntityID,
    pub cols: usize, 
    pub cells: Vec<EntityID>,
    pub col_lines: Vec<EntityID>,
    pub row_lines: Vec<EntityID>,
    pub header_rect: EntityID,
    pub table_options: TableOptions,
}

//new


impl Clone for Table {
    fn clone(&self) -> Self {
        Table {
            entity: self.entity.clone(),
            cols: self.cols,
            cells: self.cells.clone(),
            col_lines: self.col_lines.clone(),
            row_lines: self.row_lines.clone(),
            table_options: self.table_options.clone(),
            header_rect: self.header_rect.clone(),
        }
    }
}

//constructor that receives only the table options
impl Table {
    pub fn new(entity: EntityID,cells: Vec<EntityID>, col_lines: Vec<EntityID>, row_lines: Vec<EntityID>, cols: usize, header_rect: EntityID, table_options: TableOptions) -> Table {
        Table {
            entity,
            cols,
            cells,
            col_lines,
            row_lines ,
            header_rect, 
            table_options,
        }
    }
}

impl Entity for Table {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TableShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}




//defaults
impl Default for TableOptions {
    fn default() -> Self {
        TableOptions {
            fill_color: String::from("white"),
            border_color: String::from("black"),
            header_fill_color: String::from("lightgray"),
            border_width: 1,
            cell_padding: 20,
        }
    }
}

impl Clone for TableOptions {
    fn clone(&self) -> Self {
        TableOptions {
            fill_color: self.fill_color.clone(),
            header_fill_color: self.header_fill_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
            cell_padding: self.cell_padding,
        }
    }
}

===/src/renderer_base.rs===
use std::{error::Error, fmt, io::Write};

use crate::{DiagramBuilder, diagram_builder::DiagramTreeNode};

#[derive(Debug)]
pub struct RendererError {
    message: String,
}

impl RendererError {
    pub fn new(message: &str) -> RendererError {
        RendererError {
            message: message.to_string(),
        }
    }
}

impl fmt::Display for RendererError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for RendererError {}

pub trait Renderer<W: Write> {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError>;
}

===/src/transform.rs===
// In src/transform.rs (new file)
use std::f32::consts::PI;

use crate::{BoundingBox, Float};

#[derive(Debug, Clone, PartialEq)]
pub struct Transform {
    // 2D transform matrix [a, b, c, d, e, f]
    // | a  c  e |   | x |   | a*x + c*y + e |
    // | b  d  f | * | y | = | b*x + d*y + f |
    // | 0  0  1 |   | 1 |   |       1       |
    pub matrix: [Float; 6],
}

impl Transform {
    pub fn identity() -> Self {
        Transform {
            matrix: [1.0, 0.0, 0.0, 1.0, 0.0, 0.0], // [a, b, c, d, e, f]
        }
    }
    
    pub fn translation(tx: Float, ty: Float) -> Self {
        Transform {
            matrix: [1.0, 0.0, 0.0, 1.0, tx, ty],
        }
    }
    
    pub fn rotation(angle_degrees: Float) -> Self {
        let angle_rad = angle_degrees * PI / 180.0;
        let cos_a = angle_rad.cos();
        let sin_a = angle_rad.sin();
        Transform {
            matrix: [cos_a, sin_a, -sin_a, cos_a, 0.0, 0.0],
        }
    }
    
    pub fn scale(sx: Float, sy: Float) -> Self {
        Transform {
            matrix: [sx, 0.0, 0.0, sy, 0.0, 0.0],
        }
    }
    
    pub fn combine(&self, other: &Transform) -> Transform {
        // Matrix multiplication: self * other
        let [a1, b1, c1, d1, e1, f1] = self.matrix;
        let [a2, b2, c2, d2, e2, f2] = other.matrix;
        
        Transform {
            matrix: [
                a1 * a2 + c1 * b2,           // a
                b1 * a2 + d1 * b2,           // b
                a1 * c2 + c1 * d2,           // c
                b1 * c2 + d1 * d2,           // d
                a1 * e2 + c1 * f2 + e1,      // e
                b1 * e2 + d1 * f2 + f1,      // f
            ],
        }
    }
    
    pub fn transform_point(&self, x: Float, y: Float) -> (Float, Float) {
        let [a, b, c, d, e, f] = self.matrix;
        (
            a * x + c * y + e,
            b * x + d * y + f,
        )
    }
    
    pub fn transform_rect(&self, x: Float, y: Float, width: Float, height: Float) -> BoundingBox {
        // Transform all four corners and find axis-aligned bounding box
        let corners = [
            (x, y),
            (x + width, y),
            (x + width, y + height),
            (x, y + height),
        ];
        
        let transformed_corners: Vec<(Float, Float)> = corners
            .iter()
            .map(|(px, py)| self.transform_point(*px, *py))
            .collect();
        
        let min_x = transformed_corners.iter().map(|(x, _)| *x).fold(Float::INFINITY, f32::min);
        let max_x = transformed_corners.iter().map(|(x, _)| *x).fold(Float::NEG_INFINITY, f32::max);
        let min_y = transformed_corners.iter().map(|(_, y)| *y).fold(Float::INFINITY, f32::min);
        let max_y = transformed_corners.iter().map(|(_, y)| *y).fold(Float::NEG_INFINITY, f32::max);
        
        BoundingBox {
            x: min_x,
            y: min_y,
            width: max_x - min_x,
            height: max_y - min_y,
        }
    }
    
     pub fn to_svg_string(&self) -> String {
        let [a, b, c, d, e, f] = self.matrix;
        
        // If it's just a translation, use the simpler translate syntax
        if a == 1.0 && b == 0.0 && c == 0.0 && d == 1.0 {
            if e == 0.0 && f == 0.0 {
                String::new() // Identity transform
            } else {
                format!("translate({} {})", e, f)
            }
        } else {
            // Full matrix transform
            format!("matrix({} {} {} {} {} {})", a, b, c, d, e, f)
        }
    }
}
===/src/parser.rs===
use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

use crate::transform::Transform;
use crate::{components::*, diagram_builder::*, DiagramBuilder, SimpleConstraint};

/// Simplified JSON Lines entity with only essential fields
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonEntity {
    pub id: String,
    #[serde(rename = "type")]
    pub entity_type: String,

    // All attributes go into this single map - much cleaner!
    #[serde(flatten)]
    pub attributes: Map<String, Value>,
}

impl Default for JsonEntity {
    fn default() -> Self {
        Self {
            id: String::new(),
            entity_type: String::new(),
            attributes: Map::new(),
        }
    }
}

// Add this enum after JsonEntity struct
#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(tag = "type")]
pub enum ConstraintDeclaration {
    #[serde(rename = "align_left")]
    AlignLeft { entities: Vec<String> },
    #[serde(rename = "align_right")]
    AlignRight { entities: Vec<String> },
    #[serde(rename = "align_top")]
    AlignTop { entities: Vec<String> },
    #[serde(rename = "align_bottom")]
    AlignBottom { entities: Vec<String> },
    #[serde(rename = "align_center_horizontal")]
    AlignCenterHorizontal { entities: Vec<String> },
    #[serde(rename = "align_center_vertical")]
    AlignCenterVertical { entities: Vec<String> },
    #[serde(rename = "right_of")]
    RightOf { entities: Vec<String> },
    #[serde(rename = "left_of")]
    LeftOf { entities: Vec<String> },
    #[serde(rename = "above")]
    Above { entities: Vec<String> },
    #[serde(rename = "below")]
    Below { entities: Vec<String> },
    #[serde(rename = "horizontal_spacing")]
    HorizontalSpacing {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "vertical_spacing")]
    VerticalSpacing {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "stack_horizontal")]
    StackHorizontal {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "stack_vertical")]
    StackVertical {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "fixed_distance")]
    FixedDistance {
        entities: Vec<String>,
        distance: Float,
    },
    #[serde(rename = "same_width")]
    SameWidth { entities: Vec<String> },
    #[serde(rename = "same_height")]
    SameHeight { entities: Vec<String> },
    #[serde(rename = "same_size")]
    SameSize { entities: Vec<String> },
    #[serde(rename = "proportional_width")]
    ProportionalWidth { entities: Vec<String>, ratio: Float },
    #[serde(rename = "proportional_height")]
    ProportionalHeight { entities: Vec<String>, ratio: Float },
    #[serde(rename = "aspect_ratio")]
    AspectRatio { entity: String, ratio: Float },
    #[serde(rename = "distribute_horizontally")]
    DistributeHorizontally { entities: Vec<String> },
    #[serde(rename = "distribute_vertically")]
    DistributeVertically { entities: Vec<String> },
}

fn convert_constraint_declaration(
    decl: &ConstraintDeclaration,
) -> Result<SimpleConstraint, JsonLinesError> {
    match decl {
        ConstraintDeclaration::AlignLeft { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "align_left requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::AlignLeft(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::AlignRight { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "align_right requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::AlignRight(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::AlignTop { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "align_top requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::AlignTop(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::AlignBottom { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "align_bottom requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::AlignBottom(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::AlignCenterHorizontal { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "align_center_horizontal requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::AlignCenterHorizontal(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::AlignCenterVertical { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "align_center_vertical requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::AlignCenterVertical(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::RightOf { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "right_of requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::RightOf(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::LeftOf { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "left_of requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::LeftOf(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::Above { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "above requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::Above(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::Below { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "below requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::Below(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::HorizontalSpacing { entities, spacing } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "horizontal_spacing requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::HorizontalSpacing(
                entities[0].clone(),
                entities[1].clone(),
                *spacing,
            ))
        }
        ConstraintDeclaration::VerticalSpacing { entities, spacing } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "vertical_spacing requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::VerticalSpacing(
                entities[0].clone(),
                entities[1].clone(),
                *spacing,
            ))
        }
        ConstraintDeclaration::StackHorizontal { entities, spacing } => {
            if entities.len() < 2 {
                return Err(JsonLinesError::ConstraintError(
                    "stack_horizontal requires at least 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::StackHorizontal(
                entities.clone(),
                *spacing,
            ))
        }
        ConstraintDeclaration::StackVertical { entities, spacing } => {
            if entities.len() < 2 {
                return Err(JsonLinesError::ConstraintError(
                    "stack_vertical requires at least 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::StackVertical(entities.clone(), *spacing))
        }
        ConstraintDeclaration::FixedDistance { entities, distance } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "fixed_distance requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::FixedDistance(
                entities[0].clone(),
                entities[1].clone(),
                *distance,
            ))
        }
        ConstraintDeclaration::SameWidth { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "same_width requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::SameWidth(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::SameHeight { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "same_height requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::SameHeight(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::SameSize { entities } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "same_size requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::SameSize(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::ProportionalWidth { entities, ratio } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "proportional_width requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::ProportionalWidth(
                entities[0].clone(),
                entities[1].clone(),
                *ratio,
            ))
        }
        ConstraintDeclaration::ProportionalHeight { entities, ratio } => {
            if entities.len() != 2 {
                return Err(JsonLinesError::ConstraintError(
                    "proportional_height requires exactly 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::ProportionalHeight(
                entities[0].clone(),
                entities[1].clone(),
                *ratio,
            ))
        }
        ConstraintDeclaration::AspectRatio { entity, ratio } => {
            Ok(SimpleConstraint::AspectRatio(entity.clone(), *ratio))
        }
        ConstraintDeclaration::DistributeHorizontally { entities } => {
            if entities.len() < 2 {
                return Err(JsonLinesError::ConstraintError(
                    "distribute_horizontally requires at least 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::DistributeHorizontally(entities.clone()))
        }
        ConstraintDeclaration::DistributeVertically { entities } => {
            if entities.len() < 2 {
                return Err(JsonLinesError::ConstraintError(
                    "distribute_vertically requires at least 2 entities".to_string(),
                ));
            }
            Ok(SimpleConstraint::DistributeVertically(entities.clone()))
        }
    }
}

// Helper functions for attribute extraction with multiple attribute name support
fn get_string_attr(attrs: &Map<String, Value>, keys: &[&str], default: &str) -> String {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(s) = value.as_str() {
                return if s.is_empty() && !default.is_empty() {
                    default.to_string()
                } else {
                    s.to_string()
                };
            }
        }
    }
    default.to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, keys: &[&str], default: f64) -> Float {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(f) = value.as_f64() {
                return f as Float;
            }
        }
    }
    default as Float
}

fn get_int_attr(attrs: &Map<String, Value>, keys: &[&str], default: i64) -> i64 {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(i) = value.as_i64() {
                return i;
            }
        }
    }
    default
}

fn get_bool_attr(attrs: &Map<String, Value>, keys: &[&str], default: bool) -> bool {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(b) = value.as_bool() {
                return b;
            }
        }
    }
    default
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<String>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
    })
}

fn get_point_attr(
    attrs: &Map<String, Value>,
    x_keys: &[&str],
    y_keys: &[&str],
    default: (Float, Float),
) -> (Float, Float) {
    let x = get_float_attr(attrs, x_keys, default.0 as f64);
    let y = get_float_attr(attrs, y_keys, default.1 as f64);
    (x, y)
}

fn get_points_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<(Float, Float)>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| {
                    item.as_array().and_then(|point_arr| {
                        if point_arr.len() >= 2 {
                            let x = point_arr[0].as_f64().unwrap_or(0.0) as Float;
                            let y = point_arr[1].as_f64().unwrap_or(0.0) as Float;
                            Some((x, y))
                        } else {
                            None
                        }
                    })
                })
                .collect()
        })
    })
}

/// Parse a unified width/height value that can be either a number (fixed) or string (behavior)
fn parse_unified_dimension(attrs: &Map<String, Value>, keys: &[&str]) -> SizeBehavior {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            match value {
                Value::Number(num) => {
                    if let Some(float_val) = num.as_f64() {
                        return SizeBehavior::Fixed(float_val as Float);
                    }
                }
                Value::String(behavior) => {
                    return match behavior.to_lowercase().as_str() {
                        "content" | "auto" => SizeBehavior::Content,
                        "grow" => SizeBehavior::Grow,
                        _ => {
                            // Try to parse as number string
                            if let Ok(parsed) = behavior.parse::<Float>() {
                                SizeBehavior::Fixed(parsed)
                            } else {
                                SizeBehavior::Content
                            }
                        }
                    };
                }
                _ => {}
            }
        }
    }
    SizeBehavior::Content // Default
}
fn parse_transform_attributes(
    obj: &Map<String, Value>,
    session: &mut DiagramBuilder,
    entity_id: EntityID,
) {
    println!("🔍 Parsing transforms for entity: {}", entity_id);
    println!(
        "🔍 Available attributes: {:?}",
        obj.keys().collect::<Vec<_>>()
    );

    let mut transform = Transform::identity();

    // Parse individual transform properties
    // Store container-relative position separately
    if let Some(x) = obj.get("x").and_then(|v| v.as_f64()) {
        if let Some(y) = obj.get("y").and_then(|v| v.as_f64()) {
            session.set_container_relative_position(entity_id.clone(), x as Float, y as Float);
        }
    }

    if let Some(rotation) = obj
        .get("rotation")
        .or_else(|| obj.get("rotate"))
        .and_then(|v| v.as_f64())
    {
        println!(
            "🔄 Found rotation: {} degrees for entity {}",
            rotation, entity_id
        );
        transform = transform.combine(&Transform::rotation(rotation as Float));
    } else {
        println!("❌ No rotation found for entity {}", entity_id);
    }

    if let Some(scale) = obj.get("scale") {
        match scale {
            Value::Number(s) => {
                let s = s.as_f64().unwrap_or(1.0) as Float;
                println!("📏 Found uniform scale: {}", s);
                transform = transform.combine(&Transform::scale(s, s));
            }
            Value::Array(arr) if arr.len() >= 2 => {
                let sx = arr[0].as_f64().unwrap_or(1.0) as Float;
                let sy = arr[1].as_f64().unwrap_or(1.0) as Float;
                println!("📏 Found scale: [{}, {}]", sx, sy);
                transform = transform.combine(&Transform::scale(sx, sy));
            }
            _ => {}
        }
    }

    // Parse CSS-style transform string
    if let Some(transform_str) = obj.get("transform").and_then(|v| v.as_str()) {
        if let Ok(parsed_transform) = parse_css_transform(transform_str) {
            transform = transform.combine(&parsed_transform);
        }
    }

    println!("📐 Final transform for {}: {:?}", entity_id, transform);
    session.set_transform(entity_id, transform);
}

// Parse CSS-style transform strings like "rotate(45deg) scale(1.5) translate(10px, 20px)"
fn parse_css_transform(transform_str: &str) -> Result<Transform, String> {
    // Implementation would parse CSS transform functions
    // For now, simplified version:
    let result = Transform::identity();

    // This is a simplified parser - full implementation would be more robust
    if transform_str.contains("rotate(") {
        // Extract rotation value...
    }

    Ok(result)
}

/// Parser for JSON Lines diagram format
pub struct JsonLinesParser {
    entities: HashMap<String, JsonEntity>,
}

impl JsonLinesParser {
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
        }
    }

    /// Parse from a string containing JSON Lines
    pub fn parse_string(&mut self, input: &str) -> Result<String, JsonLinesError> {
        let mut root_id = None;

        for (line_num, line) in input.lines().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from a file
    pub fn parse_file(&mut self, file_path: &str) -> Result<String, JsonLinesError> {
        let file = File::open(file_path).map_err(|e| JsonLinesError::IoError(e.to_string()))?;
        let reader = BufReader::new(file);
        let mut root_id = None;

        for (line_num, line_result) in reader.lines().enumerate() {
            let line = line_result.map_err(|e| JsonLinesError::IoError(e.to_string()))?;
            let line = line.trim();

            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(&line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from an iterator of lines (useful for streaming)
    pub fn parse_lines<I>(&mut self, lines: I) -> Result<String, JsonLinesError>
    where
        I: IntoIterator<Item = String>,
    {
        let mut root_id = None;

        for (line_num, line) in lines.into_iter().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Build the diagram tree from parsed entities
    pub fn build(
        &self,
        root_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        self.build_entity(root_id, builder)
    }

    fn build_entity(
        &self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        // Clone the entity type to avoid borrow conflicts
        let component_type = entity.entity_type.clone();
        let attributes = entity.attributes.clone();

        // Check for custom components FIRST - they get the raw attributes map
        if builder.has_custom_component(&component_type) {
            return builder
                .create_custom_component(&component_type, &attributes)
                .map_err(|e| JsonLinesError::InvalidStructure(e));
        }

        // Handle built-in components using attribute helpers
        match entity.entity_type.as_str() {
            "spacer" => {
                let width = get_float_attr(&entity.attributes, &["width"], 1.0);
                let height = get_float_attr(&entity.attributes, &["height"], 20.0);
                let direction = get_string_attr(&entity.attributes, &["direction"], "vertical");

                // Determine spacer direction and final dimensions
                let spacer_direction = match direction.as_str() {
                    "horizontal" => SpacerDirection::Horizontal,
                    "both" => SpacerDirection::Both,
                    _ => SpacerDirection::Vertical, // default
                };

                let spacer_options = SpacerOptions {
                    width,
                    height,
                    direction: spacer_direction,
                };

                Ok(builder.new_spacer(entity_id.to_string(), spacer_options))
            }

            "text" => {
                let content = get_string_attr(&entity.attributes, &["content", "text"], "");
                if content.is_empty() {
                    return Err(JsonLinesError::MissingAttribute(
                        "content or text".to_string(),
                    ));
                }

                let options = TextOptions {
                    font_size: get_float_attr(&entity.attributes, &["font_size"], 12.0),
                    text_color: get_string_attr(
                        &entity.attributes,
                        &["color", "text_color"],
                        "black",
                    ),
                    font_family: get_string_attr(&entity.attributes, &["font_family"], "Arial"),
                    line_width: get_int_attr(&entity.attributes, &["line_width"], 200) as usize,
                    line_spacing: get_float_attr(&entity.attributes, &["line_spacing"], 0.0),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_text(entity_id.to_string(), &content, options))
            }

            "box" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                if children.len() != 1 {
                    return Err(JsonLinesError::InvalidStructure(
                        "Box must have exactly one child".to_string(),
                    ));
                }

                let child = self.build_entity(&children[0], builder)?;

                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = BoxOptions {
                    padding: get_float_attr(&entity.attributes, &["padding"], 0.0),
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                    width_behavior,
                    height_behavior,
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_box(entity_id.to_string(), child, options))
            }

            "vstack" => {
                let halign = match get_string_attr(
                    &entity.attributes,
                    &["h_align", "horizontal_alignment"],
                    "center",
                )
                .as_str()
                {
                    "left" => HorizontalAlignment::Left,
                    "center" => HorizontalAlignment::Center,
                    "right" => HorizontalAlignment::Right,
                    _ => HorizontalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_vstack(entity_id.to_string(), child_nodes?, halign))
            }

            "hstack" => {
                let valign = match get_string_attr(
                    &entity.attributes,
                    &["v_align", "vertical_alignment"],
                    "center",
                )
                .as_str()
                {
                    "top" => VerticalAlignment::Top,
                    "center" => VerticalAlignment::Center,
                    "bottom" => VerticalAlignment::Bottom,
                    _ => VerticalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_hstack(entity_id.to_string(), child_nodes?, valign))
            }

            "group" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();
                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_group(entity_id.to_string(), child_nodes?))
            }

            "rect" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = RectOptions {
                    width_behavior,
                    height_behavior,
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                };
                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_rectangle(entity_id.to_string(), options))
            }

            "line" => {
                let start_point = get_point_attr(
                    &entity.attributes,
                    &["start_x", "x1"],
                    &["start_y", "y1"],
                    (0.0, 0.0),
                );
                let end_point = get_point_attr(
                    &entity.attributes,
                    &["end_x", "x2"],
                    &["end_y", "y2"],
                    (0.0, 0.0),
                );

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_line(entity_id.to_string(), start_point, end_point, options))
            }

            "ellipse" => {
                let radius = get_point_attr(
                    &entity.attributes,
                    &["rx", "radius_x"],
                    &["ry", "radius_y"],
                    (25.0, 25.0),
                );

                let options = EllipseOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color", "background"],
                        "white",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color", "border_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["stroke_width", "border_width"],
                        1.0,
                    ),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_elipse(entity_id.to_string(), radius, options))
            }

            "arc" => {
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let start_angle =
                    get_float_attr(&entity.attributes, &["start_angle", "start"], 0.0);
                let end_angle = get_float_attr(&entity.attributes, &["end_angle", "end"], 90.0);

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_arc(
                    entity_id.to_string(),
                    radius,
                    start_angle,
                    end_angle,
                    options,
                ))
            }

            // Complete fixed semicircle section for parser.rs
            "semicircle" => {
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let facing_up = get_bool_attr(&entity.attributes, &["facing_up", "up"], true);

                let (start, end) = if facing_up {
                    (180.0, 360.0) // FIXED: Top semicircle should be 180° to 360°
                } else {
                    (0.0, 180.0) // FIXED: Bottom semicircle should be 0° to 180°
                };

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_arc(entity_id.to_string(), radius, start, end, options))
            }

            "quarter_circle" => {
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let quadrant = get_int_attr(&entity.attributes, &["quadrant"], 1) as u8;

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_quarter_circle(entity_id.to_string(), radius, quadrant, options))
            }

            "image" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let src = get_string_attr(&entity.attributes, &["src"], "");
                let file_path = get_string_attr(&entity.attributes, &["file_path"], "");

                if !src.is_empty() {
                    parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                    Ok(builder.new_image(
                        entity_id.to_string(),
                        &src,
                        (width_behavior, height_behavior),
                    ))
                } else if !file_path.is_empty() {
                    parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());
                    Ok(builder.new_image_from_file(
                        entity_id.to_string(),
                        &file_path,
                        (width_behavior, height_behavior),
                    ))
                } else {
                    Err(JsonLinesError::MissingAttribute(
                        "src or file_path".to_string(),
                    ))
                }
            }

            "table" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;
                let cols = get_int_attr(&entity.attributes, &["cols", "columns"], 1) as usize;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                let options = TableOptions {
                    header_fill_color: get_string_attr(
                        &entity.attributes,
                        &["header_fill_color", "header_background"],
                        "lightgray",
                    ),
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill_color", "background"],
                        "white",
                    ),
                    border_color: get_string_attr(&entity.attributes, &["border_color"], "black"),
                    border_width: get_int_attr(&entity.attributes, &["border_width"], 1) as usize,
                    cell_padding: get_int_attr(&entity.attributes, &["cell_padding", "padding"], 20)
                        as usize,
                };

                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_table(entity_id.to_string(), child_nodes?, cols, options))
            }

            "polyline" => {
                let points = get_points_attr(&entity.attributes, "points")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("points".to_string()))?;

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_polyline(entity_id.to_string(), points, options))
            }

            "free_container" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let mut positioned_children = Vec::new();
                for child_id in children {
                    let _child_entity = self
                        .entities
                        .get(&child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;

                    let child_node = self.build_entity(&child_id, builder)?;
                    let pos = builder.get_container_relative_position(&child_id);
                    println!(
                        "📍 Free container adding child: {} at position: ({}, {})",
                        child_id, pos.x, pos.y
                    );

                    positioned_children.push((child_node, (pos.x, pos.y)));
                }
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_free_container(entity_id.to_string(), positioned_children))
            }

            "constraint_container" => {
                let children = get_array_attr(&entity.attributes, "children").unwrap_or_default();

                // Parse inline constraints if present
                let mut constraints = Vec::new();
                if let Some(constraints_attr) = entity.attributes.get("constraints") {
                    if let Some(constraints_array) = constraints_attr.as_array() {
                        for constraint_val in constraints_array {
                            if let Ok(constraint_decl) =
                                serde_json::from_value::<ConstraintDeclaration>(
                                    constraint_val.clone(),
                                )
                            {
                                let simple_constraint =
                                    convert_constraint_declaration(&constraint_decl)?;
                                constraints.push(simple_constraint);
                            }
                        }
                    }
                }

                let mut children_with_pos = Vec::new();
                for child_id in children {
                    let _child_entity = self
                        .entities
                        .get(&child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;

                    let child_node = self.build_entity(&child_id, builder)?;
                    let pos = builder.get_container_relative_position(&child_id);

                    // For constraint containers, position is optional (constraints determine positioning)
                    let suggest_pos = if pos.x != 0.0 || pos.y != 0.0 {
                        Some(pos)
                    } else {
                        None
                    };

                    children_with_pos.push((child_node, suggest_pos));
                }

                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_constraint_layout_container(
                    entity_id.to_string(),
                    children_with_pos,
                    constraints,
                ))
            }
            _ => Err(JsonLinesError::UnknownEntityType(
                entity.entity_type.clone(),
            )),
        }
    }

    /// Validate that all child references exist
    pub fn validate(&self) -> Result<(), JsonLinesError> {
        for (id, entity) in &self.entities {
            if let Some(children) = get_array_attr(&entity.attributes, "children") {
                for child_id in children {
                    if !self.entities.contains_key(&child_id) {
                        return Err(JsonLinesError::MissingChild {
                            parent: id.clone(),
                            child: child_id,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    /// Get all entity IDs
    pub fn get_entity_ids(&self) -> Vec<&String> {
        self.entities.keys().collect()
    }
}

/// Builder for creating JSON Lines diagrams
pub struct JsonLinesBuilder {
    entities: Vec<JsonEntity>,
}

impl JsonLinesBuilder {
    pub fn new() -> Self {
        Self {
            entities: Vec::new(),
        }
    }

    /// Create a text entity
    pub fn text(&mut self, id: String, content: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a styled text entity
    pub fn text_styled(
        &mut self,
        id: String,
        content: &str,
        font_size: f64,
        color: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));
        attrs.insert(
            "font_size".to_string(),
            Value::Number(serde_json::Number::from_f64(font_size).unwrap()),
        );
        attrs.insert("color".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a box entity
    pub fn box_with(
        &mut self,
        id: String,
        child: String,
        padding: f64,
        background: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(vec![Value::String(child)]),
        );
        attrs.insert(
            "padding".to_string(),
            Value::Number(serde_json::Number::from_f64(padding).unwrap()),
        );
        attrs.insert(
            "background".to_string(),
            Value::String(background.to_string()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "box".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a vertical stack
    pub fn vstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "vstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a horizontal stack
    pub fn hstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "hstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a rectangle
    pub fn rect(&mut self, id: String, width: f64, height: f64, color: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "width".to_string(),
            Value::Number(serde_json::Number::from_f64(width).unwrap()),
        );
        attrs.insert(
            "height".to_string(),
            Value::Number(serde_json::Number::from_f64(height).unwrap()),
        );
        attrs.insert("background".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "rect".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a custom component entity
    pub fn custom_component(
        &mut self,
        id: String,
        component_type: &str,
        attributes: Map<String, Value>,
    ) -> String {
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: component_type.to_string(),
            attributes,
        });
        id
    }

    /// Build and return the JSON Lines string
    pub fn build(&self) -> Result<String, serde_json::Error> {
        let mut lines = Vec::new();
        for entity in &self.entities {
            lines.push(serde_json::to_string(entity)?);
        }
        Ok(lines.join("\n"))
    }

    /// Write to a file
    pub fn write_to_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::create(file_path)?;
        for entity in &self.entities {
            writeln!(file, "{}", serde_json::to_string(entity)?)?;
        }
        Ok(())
    }

    /// Get the root entity ID (first entity)
    pub fn root_id(&self) -> Option<String> {
        self.entities.first().map(|e| e.id.clone())
    }
}

#[derive(Debug)]
pub enum JsonLinesError {
    ParseError { line: usize, message: String },
    EntityNotFound(String),
    MissingAttribute(String),
    InvalidStructure(String),
    UnknownEntityType(String),
    MissingChild { parent: String, child: String },
    NoEntities,
    IoError(String),
    ConstraintError(String),
}

impl std::fmt::Display for JsonLinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsonLinesError::ParseError { line, message } => {
                write!(f, "Parse error on line {}: {}", line, message)
            }
            JsonLinesError::EntityNotFound(id) => write!(f, "Entity not found: {}", id),
            JsonLinesError::MissingAttribute(attr) => {
                write!(f, "Missing required attribute: {}", attr)
            }
            JsonLinesError::InvalidStructure(msg) => write!(f, "Invalid structure: {}", msg),
            JsonLinesError::UnknownEntityType(t) => write!(f, "Unknown entity type: {}", t),
            JsonLinesError::MissingChild { parent, child } => {
                write!(f, "Parent {} references missing child {}", parent, child)
            }
            JsonLinesError::NoEntities => write!(f, "No entities found"),
            JsonLinesError::IoError(msg) => write!(f, "IO error: {}", msg),
            JsonLinesError::ConstraintError(msg) => write!(f, "Constraint error: {}", msg),
        }
    }
}

impl std::error::Error for JsonLinesError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::DiagramBuilder;
    use serde_json::json;

    #[test]
    fn test_simplified_json_lines_parsing() {
        let input = r#"
{"id":"root","type":"box","padding":10,"background":"white","children":["text1"]}
{"id":"text1","type":"text","content":"Hello World","font_size":16,"color":"blue"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        assert_eq!(root_id, "root");

        parser.validate().unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let _diagram = parser.build(&root_id, &mut builder).unwrap();
    }

    #[test]
    fn test_attribute_aliases() {
        // Test that multiple attribute names work for the same concept
        let input = r#"
{"id":"box1","type":"box","padding":5,"background_color":"red","children":["text1"]}
{"id":"text1","type":"text","text":"Using text instead of content","text_color":"white"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_custom_component_access() {
        // Test that custom components get all attributes
        fn test_component(
            attrs: &Map<String, Value>,
            _builder: &mut DiagramBuilder,
        ) -> Result<DiagramTreeNode, String> {
            // Should be able to access any attribute
            assert!(attrs.contains_key("custom_prop"));
            assert!(attrs.contains_key("width"));
            assert!(attrs.contains_key("background"));

            // Return a dummy node for testing
            Ok(DiagramTreeNode::new(
                EntityType::TextShape,
                "test_component".to_string(),
            ))
        }

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("test_comp", test_component);

        let input = r#"{"id":"test1","type":"test_comp","width":200,"background":"blue","custom_prop":"value"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_streaming_parse() {
        let lines = vec![
            r#"{"id":"e1","type":"text","content":"Hello"}"#.to_string(),
            r#"{"id":"e2","type":"text","content":"World"}"#.to_string(),
            r#"{"id":"e3","type":"hstack","children":["e1","e2"]}"#.to_string(),
        ];

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_lines(lines).unwrap();
        assert_eq!(root_id, "e1");
        parser.validate().unwrap();
    }

    #[test]
    fn test_builder_api() {
        let mut builder = JsonLinesBuilder::new();

        let title = builder.text_styled("title".to_string(), "Document Title", 18.0, "blue");
        let left_text = builder.text("left_text".to_string(), "Left Panel");
        let right_text = builder.text("right_text".to_string(), "Right Panel");

        let left_box = builder.box_with("left_box".to_string(), left_text, 10.0, "lightblue");
        let right_box = builder.box_with("right_box".to_string(), right_text, 10.0, "lightgreen");

        let content = builder.hstack("content".to_string(), vec![left_box, right_box]);
        let footer = builder.text_styled("footer".to_string(), "Footer", 12.0, "gray");

        let _root = builder.vstack("root".to_string(), vec![title, content, footer]);

        let jsonl = builder.build().unwrap();
        println!("Generated JSON Lines:\n{}", jsonl);

        // Parse it back to verify
        let mut parser = JsonLinesParser::new();
        parser.parse_string(&jsonl).unwrap();
        parser.validate().unwrap();
    }

    #[test]
    fn test_complex_attributes() {
        // Test points for polyline
        let input = r#"{"id":"poly1","type":"polyline","points":[[0,0],[10,10],[20,0]],"stroke_color":"red"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_size_behaviors() {
        // Test different size behavior specifications
        let input = r#"
{"id":"box1","type":"box","width":"content","height":100,"children":["text1"]}
{"id":"text1","type":"text","content":"Auto-sized"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }
}

// Example of what an LLM might generate with the new simplified format
pub fn example_llm_generated_jsonl() -> &'static str {
    r#"{"id":"document","type":"box","padding":20,"background":"white","border_color":"gray","children":["layout"]}
{"id":"layout","type":"vstack","children":["header","body","footer"]}
{"id":"header","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"body","type":"hstack","children":["sidebar","main"]}
{"id":"sidebar","type":"box","padding":15,"background":"lightgray","children":["nav"]}
{"id":"nav","type":"vstack","children":["link1","link2","link3"]}
{"id":"link1","type":"text","content":"Home","color":"blue"}
{"id":"link2","type":"text","content":"About","color":"blue"}
{"id":"link3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":15,"background":"white","children":["content"]}
{"id":"content","type":"vstack","children":["article_title","article_body"]}
{"id":"article_title","type":"text","content":"Article Title","font_size":18}
{"id":"article_body","type":"text","content":"This is the main content of the article..."}
{"id":"footer","type":"text","content":"Copyright 2024","font_size":10,"color":"gray"}"#
}

#[cfg(test)]
mod transform_debug_tests {
    use super::*;
    use crate::DiagramBuilder;

    #[test]
    fn test_transform_parsing_debug() {
        println!("🧪 Testing transform parsing...");

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));

        // Create a simple JSON object with rotation
        let mut attributes = serde_json::Map::new();
        attributes.insert(
            "rotation".to_string(),
            serde_json::Value::Number(serde_json::Number::from(45)),
        );
        attributes.insert(
            "width".to_string(),
            serde_json::Value::Number(serde_json::Number::from(60)),
        );
        attributes.insert(
            "height".to_string(),
            serde_json::Value::Number(serde_json::Number::from(40)),
        );

        println!("🔍 Attributes: {:?}", attributes);

        // Test the function directly
        parse_transform_attributes(&attributes, &mut builder, "test_entity".to_string());

        // Check if the transform was applied
        let transform = builder.get_transform("test_entity".to_string());
        println!("📐 Result transform: {:?}", transform);

        // Check if it's not just identity
        let is_identity = transform.matrix[0] == 1.0
            && transform.matrix[1] == 0.0
            && transform.matrix[2] == 0.0
            && transform.matrix[3] == 1.0
            && transform.matrix[4] == 0.0
            && transform.matrix[5] == 0.0;

        println!("❓ Is identity transform: {}", is_identity);
        assert!(
            !is_identity,
            "Transform should not be identity - rotation should be applied!"
        );
    }

    #[test]
    fn test_full_parser_with_rotation() {
        println!("🧪 Testing full parser with rotation...");

        let input = r#"{"id":"test_rect","type":"rect","width":60,"height":40,"background":"red","rotation":45}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));

        let diagram = parser.build(&root_id, &mut builder).unwrap();

        // Check the transform
        let transform = builder.get_transform("test_rect".to_string());
        println!("📐 Full parser result transform: {:?}", transform);

        let is_identity = transform.matrix[0] == 1.0
            && transform.matrix[1] == 0.0
            && transform.matrix[2] == 0.0
            && transform.matrix[3] == 1.0
            && transform.matrix[4] == 0.0
            && transform.matrix[5] == 0.0;

        println!("❓ Full parser - Is identity transform: {}", is_identity);
        assert!(!is_identity, "Full parser should apply rotation!");
    }
}

// Also add this debug function to see what's happening during build_entity calls:
impl JsonLinesParser {
    // Add this method to your existing JsonLinesParser impl
    pub fn debug_build_entity(
        &mut self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        println!("🏗️ Building entity: {}", entity_id);

        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        println!("🏗️ Entity type: {}", entity.entity_type);
        println!(
            "🏗️ Entity attributes: {:?}",
            entity.attributes.keys().collect::<Vec<_>>()
        );

        // Check if rotation attribute exists
        if let Some(rotation_value) = entity.attributes.get("rotation") {
            println!("🔄 Found rotation attribute: {:?}", rotation_value);
        } else {
            println!("❌ No rotation attribute found");
        }

        // Call the original build_entity
        self.build_entity(entity_id, builder)
    }
}

===/src/utils.rs===
use crate::components::*;

===/src/diagram_builder.rs===
use std::{collections::HashMap, hash::Hash, rc::Rc, sync::Arc};

/**
 * This object encapsulates diagram creation logic.
 * Usage:
 *```rust
 * let builder = DiagramBuilder::new();
 * let group = builder.new_group(
 *   builder.new_box(builder.new_text("Hello World!"), BoxOptions{fill_color: "white".to_string(), stroke_color: "black".to_string(), stroke_width: 1.0, padding: 10.0, round_corners: false, border_radius: 0.0}),
 * );
 *
 *
 *
 */
//use TextOptions
use crate::{components::*, transform::Transform, BoundingBox, ConstraintSystem, SimpleConstraint};

pub struct DiagramBuilder {
    pub measure_text: Option<fn(&str, &TextOptions) -> (Float, Float)>,
    pub entities: Vec<EntityID>,
    // Maps entity IDs to their positions in the container (used in free containers)
    pub container_relative_positions: HashMap<EntityID, Point>,
    pub sizes: HashMap<EntityID, Size>,
    // Maps entity IDS to their transforms for positioning, rotation, scaling, etc.
    pub transforms: HashMap<EntityID, Transform>,
    pub entityTypes: HashMap<EntityID, EntityType>,

    // Components
    boxes: HashMap<EntityID, ShapeBox>,
    rectangles: HashMap<EntityID, ShapeRect>,
    groups: HashMap<EntityID, ShapeGroup>,
    texts: HashMap<EntityID, ShapeText>,
    textlines: HashMap<EntityID, TextLine>,
    horizontal_stacks: HashMap<EntityID, HorizontalStack>,
    vertical_stacks: HashMap<EntityID, VerticalStack>,
    ellipses: HashMap<EntityID, ShapeEllipse>,
    lines: HashMap<EntityID, ShapeLine>,
    arrows: HashMap<EntityID, ShapeArrow>,
    tables: HashMap<EntityID, Table>,
    images: HashMap<EntityID, ShapeImage>,
    polylines: HashMap<EntityID, PolyLine>,
    free_containers: HashMap<EntityID, FreeContainer>,
    constraint_layout_containers: HashMap<EntityID, ConstraintLayoutContainer>,
    constraint_systems: HashMap<EntityID, ConstraintSystem>,
    arcs: HashMap<EntityID, ShapeArc>,
    spacers: HashMap<EntityID, ShapeSpacer>,
    pub custom_components: CustomComponentRegistry,
}

// Stores the type of entity and the index of the entity in the corresponding vector
// Used when building the diagram tree.
#[derive(Debug, Clone)]
pub struct DiagramTreeNode {
    pub entity_type: EntityType,
    // Index of the entity in the corresponding vector
    pub entity_id: EntityID,
    pub children: Vec<Box<DiagramTreeNode>>,
}

impl DiagramTreeNode {
    pub fn new(entity_type: EntityType, id: EntityID) -> DiagramTreeNode {
        DiagramTreeNode {
            entity_type,
            entity_id: id,
            children: Vec::new(),
        }
    }

    fn add_child(&mut self, child: DiagramTreeNode) {
        self.children.push(Box::new(child));
    }
}

/* New architecture (data driven)
 * We have an array of entities, each entity is an id
 * The id has 64 bits, we can use 32 bits for the type and 32 bits for the index
 * To get the type: id >> 32
 * To get the index: id & 0xFFFFFFFF
 * We have a type enum with all the types
*/

impl DiagramBuilder {
    pub fn new() -> DiagramBuilder {
        DiagramBuilder {
            entityTypes: HashMap::<EntityID, EntityType>::new(),
            measure_text: Some(|_text, _text_options| (0.0, 0.0)),
            entities: Vec::new(),
            // store desired positions relative to the container
            container_relative_positions: HashMap::new(),
            sizes: HashMap::new(),
            transforms: HashMap::new(),
            boxes: HashMap::new(),
            rectangles: HashMap::new(),
            groups: HashMap::new(),
            texts: HashMap::new(),
            textlines: HashMap::new(),
            horizontal_stacks: HashMap::new(),
            vertical_stacks: HashMap::new(),
            ellipses: HashMap::new(),
            lines: HashMap::new(),
            arrows: HashMap::new(),
            tables: HashMap::new(),
            images: HashMap::new(),
            polylines: HashMap::new(),
            free_containers: HashMap::new(),
            constraint_layout_containers: HashMap::new(),
            constraint_systems: HashMap::new(),
            arcs: HashMap::new(),
            spacers: HashMap::new(),

            custom_components: CustomComponentRegistry::new(),
        }
    }

    pub fn clear_cache(&mut self) {
        // Clear core entity data
        self.entities.clear();
        self.container_relative_positions.clear();
        self.sizes.clear();
        self.entityTypes.clear();

        // Clear all component hashmaps
        self.boxes.clear();
        self.rectangles.clear();
        self.groups.clear();
        self.texts.clear();
        self.textlines.clear();
        self.horizontal_stacks.clear();
        self.vertical_stacks.clear();
        self.ellipses.clear();
        self.lines.clear();
        self.arrows.clear();
        self.tables.clear();
        self.images.clear();
        self.polylines.clear();
        self.free_containers.clear();
        self.arcs.clear();

        // Note: We don't clear custom_components as those are reusable function definitions
        // Note: We don't clear measure_text function as it should persist across diagrams

        println!("DiagramBuilder cache cleared - all entities and components removed");
    }

    pub fn clear_entities_only(&mut self) {
        self.entities.clear();
        self.sizes.clear();
        self.entityTypes.clear();
        self.container_relative_positions.clear();
        println!("DiagramBuilder entities cleared (components preserved)");
    }

    /// Register a custom component with the builder
    pub fn register_custom_component<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &serde_json::Map<String, serde_json::Value>,
                &mut DiagramBuilder,
            ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
            + Send
            + Sync
            + 'static,
    {
        self.custom_components.register(component_type, factory);
    }

    /// Check if a custom component is registered
    pub fn has_custom_component(&self, component_type: &str) -> bool {
        self.custom_components.has_component(component_type)
    }

    pub fn get_custom_component_types(&self) -> Vec<&String> {
        self.custom_components.get_registered_types()
    }

    pub fn create_custom_component(
        &mut self,
        component_type: &str,
        options: &serde_json::Map<String, serde_json::Value>,
    ) -> Result<DiagramTreeNode, String> {
        if !self.custom_components.has_component(component_type) {
            return Err(format!(
                "Custom component '{}' not registered",
                component_type
            ));
        }

        let factory = { self.custom_components.get(component_type).unwrap().clone() };

        factory(options, self)
    }

    /* Create a new entity of a given type
     * Returns the id of the new entity
     * We have another array with the positions of the entities
     * in the same index. So they are fast to access
     */
    pub fn new_entity(&mut self, id: EntityID, entity_type: EntityType) -> EntityID {
        println!("Creating new entity with id {}", id);
        self.entities.push(id.clone());
        self.sizes.insert(id.clone(), Size::new(0.0, 0.0));
        self.entityTypes.insert(id.clone(), entity_type.clone());
        if !self.transforms.contains_key(&id) {
            self.transforms.insert(id.clone(), Transform::identity());
        }
        id
    }

    //set the measure_text function
    pub fn set_measure_text_fn(&mut self, measure_text: fn(&str, &TextOptions) -> (Float, Float)) {
        println!("Setting measure text function");
        self.measure_text = Option::Some(measure_text);
    }

    // Replace position methods with transform methods
    pub fn get_transform(&self, entity_id: EntityID) -> Transform {
        self.transforms
            .get(&entity_id)
            .cloned()
            .unwrap_or_else(Transform::identity)
    }

    pub fn set_transform(&mut self, entity_id: EntityID, transform: Transform) {
        self.transforms.insert(entity_id, transform);
    }

    // Convenience methods for common operations
    pub fn get_position(&self, entity_id: EntityID) -> (Float, Float) {
        let transform = self.get_transform(entity_id);
        (transform.matrix[4], transform.matrix[5]) // e, f components
    }

    // pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
    //     let current = self.get_transform(entity_id.clone()).clone();
    //     let translation = Transform::translation(x, y);
    //     // Preserve existing transform but update translation
    //     let mut new_transform = current;
    //     new_transform.matrix[4] = x; // e
    //     new_transform.matrix[5] = y; // f
    //     self.set_transform(entity_id, new_transform);
    // }

    pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        let current = self.get_transform(entity_id.clone());
        println!(
            "📍 set_position called for {} - pos: ({}, {}) - before: {:?}",
            entity_id, x, y, current
        );

        // Preserve existing rotation/scale, just update translation
        let mut new_transform = current;
        new_transform.matrix[4] = x; // e - translation X
        new_transform.matrix[5] = y; // f - translation Y

        println!(
            "📍 set_position result for {} - after: {:?}",
            entity_id, new_transform
        );
        self.set_transform(entity_id, new_transform);
    }

    // Set the position relative to the container  (used in free containers)
    pub fn set_container_relative_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        self.container_relative_positions
            .insert(entity_id, Point::new(x, y));
    }

    pub fn get_container_relative_position(&self, entity_id: &EntityID) -> Point {
        self.container_relative_positions
            .get(entity_id)
            .cloned()
            .unwrap_or(Point::new(0.0, 0.0))
    }

    pub fn set_rotation(&mut self, entity_id: EntityID, angle_degrees: Float) {
        let pos = self.get_position(entity_id.clone());
        let size = self.get_size(entity_id.clone());

        // Rotate around center of element
        let center_x = size.0 / 2.0;
        let center_y = size.1 / 2.0;

        let translate_to_origin = Transform::translation(-center_x, -center_y);
        let rotation = Transform::rotation(angle_degrees);
        let translate_back = Transform::translation(center_x, center_y);
        let position = Transform::translation(pos.0, pos.1);

        // FIXED: Correct order - center operations first, then position
        let transform = translate_to_origin
            .combine(&rotation)
            .combine(&translate_back)
            .combine(&position);

        self.set_transform(entity_id, transform);
    }

    pub fn set_scale(&mut self, entity_id: EntityID, sx: Float, sy: Float) {
        let current = self.get_transform(entity_id.clone()).clone();
        let scale = Transform::scale(sx, sy);
        self.set_transform(entity_id, current.combine(&scale));
    }

    // Get effective bounding box considering transform
    pub fn get_effective_bounds(&self, entity_id: EntityID) -> BoundingBox {
        let transform = self.get_transform(entity_id.clone());
        let size = self.get_size(entity_id);
        transform.transform_rect(0.0, 0.0, size.0, size.1)
    }

    //get the size of an entity
    pub fn get_size(&self, entity_id: EntityID) -> (Float, Float) {
        let size = self.sizes.get(&entity_id).unwrap();
        (size.w, size.h)
    }

    pub fn set_size(&mut self, entity_id: EntityID, width: Float, height: Float) {
        let size = self.sizes.get_mut(&entity_id).unwrap();
        size.w = width;
        size.h = height;
    }

    pub fn new_spacer(&mut self, id: EntityID, options: SpacerOptions) -> DiagramTreeNode {
        let spacer_id = self.new_entity(id, EntityType::SpacerShape);
        let spacer = ShapeSpacer::new(spacer_id.clone(), options);
        self.spacers.insert(spacer_id.clone(), spacer);
        DiagramTreeNode::new(EntityType::SpacerShape, spacer_id)
    }

    /**
     * Architecture note:
     * the new_element methods should only create the necessary elements
     * without calculating the position and size.
     * That will be done in the layout layer.
     */

    // Wraps an element in a box
    pub fn new_box(
        &mut self,
        id: EntityID,
        child: DiagramTreeNode,
        options: BoxOptions,
    ) -> DiagramTreeNode {
        let box_id = self.new_entity(id.clone(), EntityType::BoxShape);

        let sbox = ShapeBox::new(box_id.clone(), child.entity_id.clone(), options);
        self.boxes.insert(box_id.clone(), sbox);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::BoxShape,
            entity_id: box_id.clone(),
            children: Vec::new(),
        };
        node.children.push(Box::new(child.clone()));
        node
    }

    // Add the new_arc method
    pub fn new_arc(
        &mut self,
        id: EntityID,
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let arc_id = self.new_entity(id, EntityType::ArcShape);
        let arc = ShapeArc::new(arc_id.clone(), radius, start_angle, end_angle, options);
        self.arcs.insert(arc_id.clone(), arc);
        DiagramTreeNode::new(EntityType::ArcShape, arc_id)
    }

    // Add convenience methods for common arc types
    pub fn new_arc_degrees(
        &mut self,
        id: EntityID,
        radius: Float,
        start_degrees: Float,
        end_degrees: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        self.new_arc(id, radius, start_degrees, end_degrees, options)
    }

    pub fn new_semicircle(
        &mut self,
        id: EntityID,
        radius: Float,
        facing_up: bool,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = if facing_up {
            (0.0, 180.0) // Top semicircle
        } else {
            (180.0, 360.0) // Bottom semicircle
        };
        self.new_arc(id, radius, start, end, options)
    }

    pub fn new_quarter_circle(
        &mut self,
        id: EntityID,
        radius: Float,
        quadrant: u8, // 1=top-right, 2=top-left, 3=bottom-left, 4=bottom-right
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = match quadrant {
            1 => (0.0, 90.0),    // Top-right
            2 => (90.0, 180.0),  // Top-left
            3 => (180.0, 270.0), // Bottom-left
            4 => (270.0, 360.0), // Bottom-right
            _ => (0.0, 90.0),    // Default to top-right
        };
        self.new_arc(id, radius, start, end, options)
    }

    // Creates a new Vertical stack.
    pub fn new_vstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        horizontal_alignment: HorizontalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::VerticalStackShape);
        let mut vstack = VerticalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            horizontal_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::VerticalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            vstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.vertical_stacks.insert(stack_id.clone(), vstack);

        node
    }

    // Creates a new Vertical stack.
    pub fn new_hstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        vertical_alignment: VerticalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::HorizontalStackShape);
        let mut hstack = HorizontalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            vertical_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::HorizontalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            hstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.horizontal_stacks.insert(stack_id, hstack);

        node
    }

    pub fn new_rectangle(&mut self, id: EntityID, options: RectOptions) -> DiagramTreeNode {
        let rect_id = self.new_entity(id.clone(), EntityType::RectShape);
        let rect = ShapeRect::new(rect_id.clone(), options);
        self.rectangles.insert(rect_id.clone(), rect);
        DiagramTreeNode::new(EntityType::RectShape, rect_id.clone())
    }

    // Creates a new Text element
    // text: the text to display
    // options: the options for the text
    // ```rust
    // let text = session.new_text("Hello World", TextOptions::new());
    // ```
    pub fn new_text(&mut self, id: EntityID, text: &str, options: TextOptions) -> DiagramTreeNode {
        let text_id = self.new_entity(id, EntityType::TextShape);
        //create the lines
        let text_lines = textwrap::wrap(&text, options.line_width);
        let lines: Vec<EntityID> = text_lines
            .iter()
            .enumerate()
            .map(|(i, line)| {
                let line_id = format!("text-{}-line-{}", text_id.clone(), i); // Generate a new ID for each line using the index
                self.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line.to_string(),
                };
                self.textlines.insert(line_id.clone(), text_line.clone());
                line_id
            })
            .collect();

        let text = ShapeText::new(text_id.clone(), text, options, &lines);
        self.texts.insert(text_id.clone(), text);
        DiagramTreeNode::new(EntityType::TextShape, text_id)
    }

    pub fn new_line(
        &mut self,
        id: EntityID,
        start: (Float, Float),
        end: (Float, Float),
        options: LineOptions,
    ) -> DiagramTreeNode {
        let line_id = self.new_entity(id, EntityType::LineShape);
        let line = ShapeLine::new(line_id.clone(), start, end, options);
        self.lines.insert(line_id.clone(), line);
        println!("Creating new line with id {}", line_id.clone());
        DiagramTreeNode::new(EntityType::LineShape, line_id)
    }

    pub fn new_elipse(
        &mut self,
        id: EntityID,
        radius: (Float, Float),
        options: EllipseOptions,
    ) -> DiagramTreeNode {
        let ellipse_id = self.new_entity(id, EntityType::EllipseShape);
        let ellipse = ShapeEllipse::new(ellipse_id.clone(), radius, options);
        self.ellipses.insert(ellipse_id.clone(), ellipse);
        DiagramTreeNode::new(EntityType::EllipseShape, ellipse_id.clone())
    }

    pub fn new_image(
        &mut self,
        id: EntityID,
        image_data: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::new(image_id.clone(), image_data.to_string(), size);
        self.images.insert(image_id.clone(), image);
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    pub fn new_image_from_file(
        &mut self,
        id: EntityID,
        file_path: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::from_file(image_id.clone(), file_path.to_string(), size);
        self.images.insert(image_id.clone(), image.clone());
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    // Creates a new Group.
    pub fn new_group(&mut self, id: EntityID, children: Vec<DiagramTreeNode>) -> DiagramTreeNode {
        let group_id = self.new_entity(id, EntityType::GroupShape);
        let mut sgroup = ShapeGroup {
            entity: group_id.clone(),
            elements: Vec::new(),
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::GroupShape,
            entity_id: group_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            sgroup.elements.push(child.entity_id.clone());
            node.add_child(child.clone())
        }

        self.groups.insert(group_id, sgroup);

        node
    }

    pub fn new_table(
        &mut self,
        id: EntityID,
        cells: Vec<DiagramTreeNode>,
        cols: usize,
        options: TableOptions,
    ) -> DiagramTreeNode {
        let mut cell_ids = Vec::new();
        for cell in &cells {
            cell_ids.push(cell.entity_id.clone());
        }
        //create entities for the col and row lines
        let mut col_lines = Vec::new();
        for i in 0..cols {
            let line_id = format!("{}-col-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(line_id.clone(), (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id.clone(), line);
            col_lines.push(line_id.clone());
        }
        let num_rows = cells.len() / cols;
        let mut row_lines = Vec::new();
        for i in 0..num_rows + 1 {
            let line_id = format!("{}-row-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(line_id.clone(), (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id.clone(), line);
            row_lines.push(line_id.clone());
        }

        //Add a rectangle for the header row
        let header_id = format!("{}-header", id);
        self.new_entity(header_id.clone(), EntityType::RectShape);
        // Create the rectangle for the header row
        let header = self.new_rectangle(
            header_id,
            RectOptions {
                fill_color: Fill::Color(options.header_fill_color.clone()),
                stroke_color: String::from("black"),
                stroke_width: 1.0,
                ..Default::default()
            },
        );

        let table_id = format!("{}-table", id.clone());
        self.new_entity(table_id.clone(), EntityType::TableShape);
        let table = Table::new(
            table_id.clone(),
            cell_ids,
            col_lines.clone(),
            row_lines.clone(),
            cols,
            header.entity_id.clone(),
            options.clone(),
        );

        self.tables.insert(table_id.clone(), table);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::TableShape,
            entity_id: table_id.clone(),
            children: Vec::new(),
        };

        // Add the header before the cells, otherwise it can cover the cells
        node.add_child(DiagramTreeNode::new(
            EntityType::RectShape,
            header.entity_id.clone(),
        ));

        for child in cells {
            node.add_child(child)
        }

        //add the lines
        for line in col_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }
        for line in row_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }

        node
    }

    pub fn new_polyline(
        &mut self,
        id: EntityID,
        points: Vec<(Float, Float)>,
        options: LineOptions,
    ) -> DiagramTreeNode {
        self.new_entity(id.clone(), EntityType::PolyLine);
        let polyline = PolyLine::new(id.clone(), points, options);
        self.polylines.insert(id.clone(), polyline);
        DiagramTreeNode::new(EntityType::PolyLine, id.clone())
    }

    /// Creates a new FreeContainer with all children at once
    pub fn new_free_container(
        &mut self,
        id: EntityID,
        children_with_positions: Vec<(DiagramTreeNode, (Float, Float))>,
    ) -> DiagramTreeNode {
        let container_id = self.new_entity(id.clone(), EntityType::FreeContainer);

        // Create the free container
        let mut container = FreeContainer::new(container_id.clone());

        // Create the node for the tree
        let mut node = DiagramTreeNode {
            entity_type: EntityType::FreeContainer,
            entity_id: container_id.clone(),
            children: Vec::new(),
        };

        // Add all children with their positions
        for (child, position) in children_with_positions {
            container.add_child(child.entity_id.clone(), position);
            node.add_child(child);
        }

        // Store the container
        self.free_containers.insert(container_id.clone(), container);

        node
    }

    /**
     * A constraint layout uses cassowary constraints to calculate some
     * of the positions and sizes of elements.
     * Some elements may contain initial coordinates while others
     * will get their positions from the constrain system solution
     */
    pub fn new_constraint_layout_container(
        &mut self,
        id: EntityID,
        // The children may have relative coordinates set, but may not (when calculated by constraints)
        children: Vec<(DiagramTreeNode, Option<Point>)>,
        constraints: Vec<crate::SimpleConstraint>,
    ) -> DiagramTreeNode {
        // Create container elem
        let id = self.new_entity(id.clone(), EntityType::ConstraintLayoutContainer);
        let children = Rc::new(children);

        let children_ids = children.clone().iter().map(|(node, _) | {
            node.entity_id.clone()
        }).collect::<Vec<String>>();

        let children_nodes = children.clone().iter().map(|(node,_) | {
            Box::new(node.clone())
        }).collect::<Vec<Box<DiagramTreeNode>>>();

        let container = ConstraintLayoutContainer::new(id.clone(),children_ids.clone().to_vec());

        // Setup constraint system
        
        // register entities in the constrain system and suggest positions
        let mut cs = ConstraintSystem::new();
        for (node, pos) in children.clone().to_vec() {
            if let Err(e) = cs.add_entity(node.entity_id.clone()) {
                eprintln!("Failed to add entity to constrain system: {}", node.entity_id.clone());
            }
            // suggest position if there's one
            if let Some(p) = pos {
                 let _ = cs.suggest_position(&node.entity_id.clone(), p.x, p.y);
            }
        }

        // register constraints
        for constraint in constraints {
            let _ = cs.add_constraint(constraint);
        }

        // Store the constraint system
        self.constraint_systems.insert(id.clone(), cs);
        self.constraint_layout_containers.insert(id.clone(), container);

        // Add children to system
        DiagramTreeNode {
            entity_type: EntityType::ConstraintLayoutContainer,
            entity_id: id.clone(),
            children: children_nodes,

         }
    }
}

// element list accessors
impl DiagramBuilder {
    pub fn get_text(&self, id: EntityID) -> &ShapeText {
        &self.texts[&id]
    }

    pub fn add_text(&mut self, id: EntityID, text: ShapeText) {
        self.texts.insert(id, text);
    }

    pub fn get_group(&self, id: EntityID) -> &ShapeGroup {
        &self.groups[&id]
    }

    pub fn get_horizontal_stack(&self, id: EntityID) -> &HorizontalStack {
        &self.horizontal_stacks[&id]
    }

    pub fn get_vertical_stack(&self, id: EntityID) -> &VerticalStack {
        &self.vertical_stacks[&id]
    }

    pub fn get_ellipse(&self, id: EntityID) -> &ShapeEllipse {
        &self.ellipses[&id]
    }

    pub fn get_line(&self, id: EntityID) -> &ShapeLine {
        &self.lines[&id]
    }

    pub fn get_rectangle(&self, id: EntityID) -> &ShapeRect {
        &self.rectangles[&id]
    }

    pub fn get_text_line(&self, id: EntityID) -> &TextLine {
        &self.textlines[&id]
    }
    pub fn add_text_line(&mut self, id: EntityID, text_line: TextLine) {
        self.textlines.insert(id, text_line);
    }
    pub fn get_text_line_mut(&mut self, id: EntityID) -> Option<&mut TextLine> {
        self.textlines.get_mut(&id)
    }

    pub fn get_arrow(&self, id: EntityID) -> &ShapeArrow {
        &self.arrows[&id]
    }

    pub fn get_table(&self, id: EntityID) -> &Table {
        &self.tables[&id]
    }

    pub fn get_image(&self, id: EntityID) -> &ShapeImage {
        &self.images[&id]
    }

    pub fn get_box(&self, id: EntityID) -> &ShapeBox {
        &self.boxes[&id]
    }

    pub fn get_polyline(&self, id: EntityID) -> &PolyLine {
        &self.polylines[&id]
    }

    pub fn get_free_container(&self, id: EntityID) -> &FreeContainer {
        &self.free_containers[&id]
    }

    pub fn get_free_container_mut(&mut self, id: EntityID) -> &mut FreeContainer {
        self.free_containers.get_mut(&id).unwrap()
    }

    pub fn get_constraint_layout(&self, id: EntityID) -> &ConstraintLayoutContainer {
        &self.constraint_layout_containers[&id]
    }

    pub fn get_constraint_layout_mut(&mut self, id: EntityID) -> &mut ConstraintLayoutContainer {
        self.constraint_layout_containers.get_mut(&id).unwrap()
    }

    pub fn get_constraint_system(&mut self, id: EntityID) -> &ConstraintSystem {
        self.constraint_systems.get(&id).unwrap()
    }

     pub fn get_constraint_system_mut(&mut self, id: EntityID) -> &mut ConstraintSystem {
        self.constraint_systems.get_mut(&id).unwrap()
    }

    pub fn get_arc(&self, id: EntityID) -> &ShapeArc {
        &self.arcs[&id]
    }

    pub fn get_spacer(&self, id: EntityID) -> &ShapeSpacer {
        &self.spacers[&id]
    }

    pub fn get_custom_component(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &serde_json::Map<String, serde_json::Value>,
                    &mut DiagramBuilder,
                ) -> Result<DiagramTreeNode, String>
                + Send
                + Sync,
        >,
    > {
        self.custom_components.get(component_type)
    }
}

//test
#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_session() {
        let mut session = DiagramBuilder::new();

        session.set_measure_text_fn(|text, text_options| {
            let textW: Float = text.len() as Float * text_options.font_size as Float;

            (textW, text_options.font_size.into())
        });
        let (w, h) = session.measure_text.unwrap()(
            "hello",
            &TextOptions {
                font_size: 12.0,
                ..Default::default()
            },
        );
        assert_eq!(w, 60.0);
        assert_eq!(h, 12.0);
    }
}

//Component registration tests
#[cfg(test)]
mod component_registration_tests {
    use serde_json::{json, Map, Value};

    use super::*;

    /// Custom Component 1: Badge
    /// Creates a rounded pill-shaped element with text
    fn create_badge_component(
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, String> {
        println!("🏷️  Creating badge component with attrs: {:?}", attrs);

        // Extract attributes
        let text = get_string_attr(attrs, "text", "Badge");
        let background = get_string_attr(attrs, "background", "blue");
        let color = get_string_attr(attrs, "color", "white");
        let font_size = get_float_attr(attrs, "font_size", 12.0);
        let padding = get_float_attr(attrs, "padding", 8.0);

        // Create text element
        let text_options = TextOptions {
            font_family: "Arial".to_string(),
            font_size,
            text_color: color,
            line_width: 200,
            line_spacing: 0.0,
        };
        let text_node = builder.new_text("text".to_string(), &text, text_options);

        // Wrap in rounded box
        let box_options = BoxOptions {
            fill_color: Fill::Color(background),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            padding,
            border_radius: font_size,               // Make it pill-shaped
            width_behavior: SizeBehavior::Content,  // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
        };
        let badge = builder.new_box("container".to_string(), text_node, box_options);

        println!("✅ Badge '{}' created successfully", text);
        Ok(badge)
    }

    // Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
    fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
        let badge_node = result.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::BoxShape);
        assert!(builder.has_custom_component("badge"));
        let badge = builder.get_box(badge_node.entity_id);
        assert_eq!(
            badge.box_options.fill_color,
            Fill::Color("blue".to_string())
        );
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 1);
        assert!(builder.has_custom_component("badge"));
    }
}


===/svg_renderer.txt===
===/Cargo.toml===
[package]
name = "svg_renderer"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
volare_engine_layout = { path = "../volare_engine_layout" }
base64 = "0.21"

[lib]
name = "svg_renderer"
path = "src/lib.rs"
===/test_viewer/index.html===
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>SVG Renderer Test Viewer</title>
   <style>
    @font-face {
    font-family: 'Roboto';
    src: url('Roboto-Regular.ttf') format('truetype');
    }

   </style>
</head>
<body>
    <form id="svg-form">
        <label for="svg-source">Paste SVG here:</label>
        <textarea id="svg-source" spellcheck="false" wrap="off" autocapitalize="none" autocomplete="off" autocorrect="off" autofocus="true" placeholder="Paste SVG here..."></textarea>
        <input type="submit" value="Render">
    </form>
    <div id="svg-container"></div>
    <script type="module">
        const svgSource = document.getElementById('svg-source');
        const svgContainer = document.getElementById('svg-container');
        const form = document.getElementById('svg-form');

        form.addEventListener('submit', (event) => {
            event.preventDefault();
            svgContainer.innerHTML = svgSource.value;
        });
    </script> 
    
</body>
</html>

===/src/lib.rs===
use std::io::Write;
use volare_engine_layout::diagram_builder::DiagramTreeNode;
use volare_engine_layout::FreeContainer;
use volare_engine_layout::*;
//use error
use crate::transform::Transform;
use std::io::Error;

pub struct SVGRenderer;

impl<W: Write> Renderer<W> for SVGRenderer {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError> {
        let mut svg = String::new();
        let root_bounds = session.get_effective_bounds(diagram_node.entity_id.clone());
        svg.push_str(&format!(
            r#"<svg width="{}" height="{}" viewBox="{} {} {} {}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">"#,
            root_bounds.width, root_bounds.height,
            root_bounds.x, root_bounds.y, root_bounds.width, root_bounds.height
        ));
        svg.push_str(render_node(diagram_node, session).as_str());
        //close svg tag
        svg.push_str("</svg>");
        svg.push_str("\n");

        // Properly handle the result from writing to the stream
        stream
            .write_all(svg.as_bytes())
            .map_err(|e| RendererError::new(&e.to_string()))?;

        Ok(())
    }
}

// Render a node and its children
fn render_node<'a>(node: &DiagramTreeNode, session: &DiagramBuilder) -> String {
    let mut svg = String::new();

    let entity_id = node.entity_id.clone();

    match node.entity_type {
        EntityType::GroupShape => {
            render_group(session, &mut svg, entity_id, node);
        }
        EntityType::BoxShape => {
            render_box(session, &mut svg, entity_id, node);
        }
        EntityType::TextShape => {
            render_text(session, &mut svg, entity_id, node);
        }
        EntityType::VerticalStackShape => {
            render_vertical_stack(session, &mut svg, entity_id, node);
        }
        EntityType::HorizontalStackShape => {
            render_horizontal_stack(session, &mut svg, entity_id, node);
        }
        EntityType::LineShape => {
            render_line(session, &mut svg, entity_id, node);
        }
        EntityType::ArrowShape => {
            render_arrow(session, &mut svg, entity_id, node);
        }
        EntityType::EllipseShape => {
            render_ellipse(session, &mut svg, entity_id, node);
        }
        //table
        EntityType::TableShape => {
            render_table(session, &mut svg, entity_id, node);
        }
        //Image
        EntityType::ImageShape => {
            render_image(session, &mut svg, entity_id, node);
        }

        EntityType::PolyLine => {
            render_polyline(session, &mut svg, entity_id, node);
        }

        EntityType::FreeContainer => {
            render_free_container(session, &mut svg, entity_id, node);
        }

        EntityType::ConstraintLayoutContainer => {
            render_constraint_layout_container(session, &mut svg, entity_id, node);
        }

        EntityType::RectShape => {
            render_rectangle(session, &mut svg, entity_id, node);
        }

        EntityType::ArcShape => {
            render_arc(session, &mut svg, entity_id, node);
        }

        _ => {}
    }

    svg
}

fn render_box(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let size = session.get_size(entity_id.clone());
    let box_shape = session.get_box(node.entity_id.clone());

    let mut box_content = String::new();

    // Draw box rectangle
    match &box_shape.box_options.fill_color {
        Fill::Color(color) => {
            box_content.push_str(&format!(
                r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" rx="{}" ry="{}" />"#,
                size.0, size.1, color,
                box_shape.box_options.stroke_color,
                box_shape.box_options.stroke_width,
                box_shape.box_options.border_radius,
                box_shape.box_options.border_radius
            ));
        }
        _ => {
            // TODO: Handle gradients
        }
    }

    // Render children
    if !node.children.is_empty() {
        let first_child = &node.children[0];
        box_content.push_str(&render_node(first_child, session));
    }

    render_with_transform(session, svg, entity_id, &box_content);
}

fn render_vertical_stack(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let mut stack_content = String::new();

    for child in node.children.iter() {
        stack_content.push_str(&render_node(child, session));
    }

    render_with_transform(session, svg, entity_id, &stack_content);
}

fn render_horizontal_stack(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let mut stack_content = String::new();

    for child in node.children.iter() {
        stack_content.push_str(&render_node(child, session));
    }

    render_with_transform(session, svg, entity_id, &stack_content);
}

fn render_polyline(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let polyline_shape = session.get_polyline(node.entity_id.clone());

    let points_str = polyline_shape
        .points
        .iter()
        .map(|&(x, y)| format!("{},{}", x, y))
        .collect::<Vec<_>>()
        .join(" ");

    let polyline_content = format!(
        r#"<polyline points="{}" stroke="{}" stroke-width="{}" fill="none" />"#,
        points_str,
        polyline_shape.line_options.stroke_color,
        polyline_shape.line_options.stroke_width
    );

    render_with_transform(session, svg, entity_id, &polyline_content);
}

fn render_free_container(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let size = session.get_size(entity_id.clone());
    let container = session.get_free_container(entity_id.clone());

    let mut container_content = String::new();

    // If there's a background color, draw a rectangle with it
    if let Some(bg_color) = &container.background_color {
        container_content.push_str(&format!(
            r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" />"#,
            size.0, size.1, bg_color
        ));
    }

    // Render all children
    for child in node.children.iter() {
        container_content.push_str(&render_node(child, session));
    }

    render_with_transform(session, svg, entity_id, &container_content);
}



fn render_constraint_layout_container(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let size = session.get_size(entity_id.clone());
    let container = session.get_constraint_layout(entity_id.clone());

    //No background rectangle

    let mut container_content = String::new();

    // Render all children
    for child in node.children.iter() {
        container_content.push_str(&render_node(child, session));
    }

    render_with_transform(session, svg, entity_id, &container_content);
}

fn render_image(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let size = session.get_size(entity_id.clone());
    let image_shape = session.get_image(node.entity_id.clone());

    // Handle the Option<String> file_path
    let image_src = match &image_shape.file_path {
        Some(file_path) => {
            if file_path.starts_with("data:") {
                file_path.clone()
            } else {
                match read_image_file_as_data_url(file_path) {
                    Ok(data_url) => data_url,
                    Err(_) => {
                        // Fallback to file path if reading fails
                        file_path.clone()
                    }
                }
            }
        }
        None => {
            // No file path provided, use empty string or placeholder
            String::new()
        }
    };

    let image_content = format!(
        r#"<image x="0" y="0" width="{}" height="{}" xlink:href="{}" />"#,
        size.0, size.1, image_src
    );

    render_with_transform(session, svg, entity_id, &image_content);
}

// Helper function to read an image file and convert it to a data URL
fn read_image_file_as_data_url(file_path: &str) -> Result<String, std::io::Error> {
    use base64::engine::general_purpose::STANDARD as BASE64;
    use base64::Engine;
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;

    // Read the file
    let mut file = File::open(file_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;

    // Determine mime type based on file extension
    let mime_type = match Path::new(file_path)
        .extension()
        .and_then(|ext| ext.to_str())
    {
        Some("png") => "image/png",
        Some("jpg") | Some("jpeg") => "image/jpeg",
        Some("svg") => "image/svg+xml",
        Some("gif") => "image/gif",
        Some("webp") => "image/webp",
        _ => "application/octet-stream", // Default mime type
    };

    // Encode as base64 and create data URL
    let base64_data = BASE64.encode(&buffer);
    let data_url = format!("data:{};base64,{}", mime_type, base64_data);

    Ok(data_url)
}
// Fixed render_line function for svg_renderer/src/lib.rs
fn render_line(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let line_shape = session.get_line(node.entity_id.clone());

    let line_content = format!(
        r#"<line x1="{}" y1="{}" x2="{}" y2="{}" stroke="{}" stroke-width="{}" />"#,
        line_shape.start.0,
        line_shape.start.1,
        line_shape.end.0,
        line_shape.end.1,
        line_shape.line_options.stroke_color,
        line_shape.line_options.stroke_width
    );

    render_with_transform(session, svg, entity_id, &line_content);
}

fn render_rectangle(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let size = session.get_size(entity_id.clone());
    let rect_shape = session.get_rectangle(node.entity_id.clone());

    let rect_content = format!(
        r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" rx="{}" ry="{}" />"#,
        size.0,
        size.1,
        match &rect_shape.rect_options.fill_color {
            Fill::Color(color) => color.clone(),
            _ => "white".to_string(), // TODO: Handle gradients
        },
        rect_shape.rect_options.stroke_color,
        rect_shape.rect_options.stroke_width,
        rect_shape.rect_options.border_radius,
        rect_shape.rect_options.border_radius
    );

    render_with_transform(session, svg, entity_id, &rect_content);
}

fn render_arrow(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let arrow_shape = session.get_arrow(node.entity_id.clone());

    let arrow_content = format!(
        r#"<line x1="{}" y1="{}" x2="{}" y2="{}" stroke="{}" stroke-width="{}" />"#,
        arrow_shape.start.0,
        arrow_shape.start.1,
        arrow_shape.end.0,
        arrow_shape.end.1,
        arrow_shape.arrow_options.stroke_color,
        arrow_shape.arrow_options.stroke_width
    );

    render_with_transform(session, svg, entity_id, &arrow_content);
}

fn render_ellipse(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let ellipse_shape = session.get_ellipse(node.entity_id.clone());

    // Center the ellipse within its own coordinate space
    // The ellipse should be centered within its bounding box
    let cx = ellipse_shape.radius.0; // Center X = radius X
    let cy = ellipse_shape.radius.1; // Center Y = radius Y

    let ellipse_content = format!(
        r#"<ellipse cx="{}" cy="{}" rx="{}" ry="{}" stroke="{}" stroke-width="{}" fill="{}" />"#,
        cx,
        cy,
        ellipse_shape.radius.0,
        ellipse_shape.radius.1,
        ellipse_shape.ellipse_options.stroke_color,
        ellipse_shape.ellipse_options.stroke_width,
        ellipse_shape.ellipse_options.fill_color
    );

    render_with_transform(session, svg, entity_id, &ellipse_content);
}

fn render_group(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let mut group_content = String::new();

    for child in node.children.iter() {
        group_content.push_str(&render_node(child, session));
    }

    render_with_transform(session, svg, entity_id, &group_content);
}

fn render_table(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let size = session.get_size(entity_id.clone());
    let table_shape = session.get_table(node.entity_id.clone());

    let mut table_content = String::new();

    // Render container rect element
    table_content.push_str(&format!(
        r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" />"#,
        size.0,
        size.1,
        table_shape.table_options.fill_color,
        table_shape.table_options.border_color,
        table_shape.table_options.border_width
    ));

    // Render header, cells, lines, etc. Should have been added to the node
    for child in node.children.iter() {
        table_content.push_str(&render_node(child, session));
    }

    render_with_transform(session, svg, entity_id, &table_content);
}

// Then update the render_text function to use it:
fn render_text(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    let text_shape = session.get_text(node.entity_id.clone());
    let size = session.get_size(entity_id.clone());

    let mut text_content = format!(
        r#"<text x="0" y="0" fill="{}" font-size="{}px" font-family="{}">"#,
        text_shape.text_options.text_color,
        text_shape.text_options.font_size,
        text_shape.text_options.font_family
    );

    // Render lines
    for line_id in text_shape.lines.iter() {
        let line = session.get_text_line(line_id.clone());
        let line_pos = session.get_position(line.entity.clone());

        text_content.push_str(&format!(
            r#"<tspan x="{}" y="{}" alignment-baseline="hanging">"#,
            line_pos.0, line_pos.1
        ));

        let escaped_text = if line.text.trim().is_empty() {
            "&#8203;".to_string()
        } else {
            escape_xml(&line.text)
        };

        text_content.push_str(&escaped_text);
        text_content.push_str("</tspan>");
    }
    text_content.push_str("</text>");

    render_with_transform(session, svg, entity_id, &text_content);
}
fn render_arc(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    node: &DiagramTreeNode,
) {
    use std::f32::consts::PI;

    let arc_shape = session.get_arc(node.entity_id.clone());
    let size = session.get_size(entity_id.clone());

    // Center the arc within its bounding box (like ellipses do)
    let center_x = size.0 / 2.0;  // Same as ellipse: radius
    let center_y = size.1 / 2.0;  // Same as ellipse: radius

    // Get normalized angles
    let (start_angle, end_angle) = arc_shape.normalize_angles();
    let sweep = arc_shape.angle_sweep();

    // Convert to radians for calculations
    let start_rad = start_angle * PI / 180.0;
    let end_rad = end_angle * PI / 180.0;

    // Calculate start and end points relative to the centered position
    let start_x = center_x + arc_shape.radius * start_rad.cos();
    let start_y = center_y + arc_shape.radius * start_rad.sin();
    let end_x = center_x + arc_shape.radius * end_rad.cos();
    let end_y = center_y + arc_shape.radius * end_rad.sin();

    // Determine if this is a large arc (> 180 degrees)
    let large_arc_flag = if sweep > 180.0 { 1 } else { 0 };

    // Always sweep in positive direction (clockwise in SVG coordinates)
    let sweep_flag = 1;

    let arc_content = if (sweep - 360.0).abs() < 0.1 {
        // Special case for full circles (360°)
        if arc_shape.arc_options.filled {
            // Filled circle
            format!(
                r#"<circle cx="{}" cy="{}" r="{}" fill="{}" stroke="{}" stroke-width="{}" />"#,
                center_x,
                center_y,
                arc_shape.radius,
                arc_shape.arc_options.fill_color,
                arc_shape.arc_options.stroke_color,
                arc_shape.arc_options.stroke_width
            )
        } else {
            // Unfilled circle
            format!(
                r#"<circle cx="{}" cy="{}" r="{}" fill="none" stroke="{}" stroke-width="{}" />"#,
                center_x,
                center_y,
                arc_shape.radius,
                arc_shape.arc_options.stroke_color,
                arc_shape.arc_options.stroke_width
            )
        }
    } else if arc_shape.arc_options.filled {
        // For filled arcs, create a path that includes the center (pie slice)
        format!(
            r#"<path d="M {} {} L {} {} A {} {} 0 {} {} {} {} Z" fill="{}" stroke="{}" stroke-width="{}" />"#,
            center_x,
            center_y, // Move to center
            start_x,
            start_y, // Line to start point
            arc_shape.radius,
            arc_shape.radius, // Arc radii
            large_arc_flag,
            sweep_flag, // Arc flags
            end_x,
            end_y, // Arc end point
            arc_shape.arc_options.fill_color,
            arc_shape.arc_options.stroke_color,
            arc_shape.arc_options.stroke_width
        )
    } else {
        // For unfilled arcs, just draw the arc
        format!(
            r#"<path d="M {} {} A {} {} 0 {} {} {} {}" fill="none" stroke="{}" stroke-width="{}" />"#,
            start_x,
            start_y, // Move to start point
            arc_shape.radius,
            arc_shape.radius, // Arc radii
            large_arc_flag,
            sweep_flag, // Arc flags
            end_x,
            end_y, // Arc end point
            arc_shape.arc_options.stroke_color,
            arc_shape.arc_options.stroke_width
        )
    };

    render_with_transform(session, svg, entity_id, &arc_content);
}

#[test]
fn test_render_arc() {
    let mut session = DiagramBuilder::new();
    let options = ArcOptions {
        fill_color: "blue".to_string(),
        stroke_color: "black".to_string(),
        stroke_width: 2.0,
        filled: false,
    };

    let arc = session.new_arc(
        "arc".to_string(),
        30.0, // radius
        0.0,  // start angle
        90.0, // end angle
        options,
    );

    let node = render_node(&arc, &session);

    assertIsSameSVG(
        &node,
        r##"<g transform="translate(0 0)">
            <path d="M 80 50 A 30 30 0 0 1 50 80" fill="none" stroke="black" stroke-width="2" />
        </g>"##,
    );
    assert!(node.contains("stroke=\"black\""));
}

//test that groups are rendered correctly
#[test]
fn test_render_group() {
    let mut session = DiagramBuilder::new();
    let group = session.new_group("group".to_string(), Vec::new());
    let node = render_node(&group, &session);
    assert_eq!(node, r#"<g transform="translate(0 0)" ></g>"#);
}

//test that BoxShape with wrapped group is rendered correctly
#[test]
fn test_render_box_with_rect_in_group() {
    let mut session = DiagramBuilder::new();

    let rect = session.new_rectangle(
        "rect1".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(50.0),
            fill_color: Fill::Color("black".to_string()),
            stroke_color: String::from("magenta"),
            stroke_width: 1.0,
            border_radius: 1.0,
        },
    );

    let group = session.new_group("group".to_string(), vec![rect]);

    let box_ = session.new_box(
        "box_".to_string(),
        group,
        BoxOptions {
            fill_color: Fill::Color("white".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            padding: 2.0,
            border_radius: 0.0,
            width_behavior: SizeBehavior::Content, // 100 + 2*2 (padding)
            height_behavior: SizeBehavior::Content, // 50 + 2
        },
    );

    layout_tree_node(&mut session, &box_);

    let node = render_node(&box_, &session);
    assertIsSameSVG(
        &node,
        r#"
    <g transform="translate(0 0)" >
        <rect x="0" y="0" width="104" height="54" fill="white" stroke="black" stroke-width="1" rx="0" ry="0" />
            <g transform="translate(2 2)" >
                <g transform="translate(0 0)">
                    <rect x="0" y="0" width="100" height="50" fill="black" stroke="magenta" stroke-width="1" rx="1" ry="1" />
                </g>
            </g>
     </g>"#,
    );
}

// Add this helper function
fn render_with_transform(
    session: &DiagramBuilder,
    svg: &mut String,
    entity_id: EntityID,
    content: &str,
) {
    let transform = session.get_transform(entity_id.clone());
    let transform_str = transform.to_svg_string();
    println!("transform for entity {} {}", entity_id.clone(), transform_str);


    if transform_str.is_empty() {
        // No transform, use simple group
        svg.push_str("<g>");
    } else {
        // Apply transform
        svg.push_str(&format!(r#"<g transform="{}">"#, transform_str));
    }

    svg.push_str(content);
    svg.push_str("</g>");
}

fn escape_xml(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&apos;")
}

fn assertIsSameSVG(a: &str, b: &str) {
    // Normalize whitespace and compare
    let strA = a.chars().filter(|c| !c.is_whitespace()).collect::<String>();
    let strB = b.chars().filter(|c| !c.is_whitespace()).collect::<String>();
    assert_eq!(
        strA.replace('\n', "").replace('\r', ""),
        strB.replace('\n', "").replace('\r', "")
    );
}


