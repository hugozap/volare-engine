===/image_renderer.txt===
===/cargo.toml===
[package]
name = "image_renderer"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
volare_engine_layout = { path = "../volare_engine_layout" }
image = "0.23"
imageproc = "0.22"
rusttype = "0.9"
bresenham = "0.1.1"
base64 = "0.21"

[lib]
name = "image_renderer"
path = "src/lib.rs"
===/src/lib.rs===
use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};
use bresenham::Bresenham;
use image::{DynamicImage, GenericImageView, Rgba, RgbaImage};
use imageproc::drawing::{draw_filled_rect_mut, draw_hollow_rect_mut, draw_text_mut};
use imageproc::rect::Rect;
use rusttype::{Font, Scale};
use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use volare_engine_layout::Float;

use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, Fill, Renderer,
    RendererError,
};

/**
 * This is the PNG renderer. It will render the diagram to a PNG stream.
 */

pub struct PNGRenderer;

impl<W: Write> Renderer<W> for PNGRenderer {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError> {
        let root_size = session.get_size(diagram_node.entity_id.clone());

        // Use a scaling factor for higher resolution output but don't scale too much
        // 1.5 is a good balance between quality and maintaining layout proportions
        // TODO: Esto debe ser un parametro?
        let scaling_factor = 1.5;

        // Calculate image dimensions with scaling
        let width = ((root_size.0 * scaling_factor).ceil() as u32).max(200);
        let height = ((root_size.1 * scaling_factor).ceil() as u32).max(200);

        // Debug output
        println!("Creating PNG image with dimensions: {}x{}", width, height);

        // Create an image with a white background
        let mut imgbuf = RgbaImage::from_fn(width, height, |_, _| Rgba([255, 255, 255, 255]));

        // Draw a border to see image bounds (for debugging)
        let border_color = Rgba([200, 200, 200, 255]);
        for x in 0..width {
            imgbuf.put_pixel(x, 0, border_color);
            imgbuf.put_pixel(x, height - 1, border_color);
        }
        for y in 0..height {
            imgbuf.put_pixel(0, y, border_color);
            imgbuf.put_pixel(width - 1, y, border_color);
        }

        // Pass scaling factor to the render function
        render_node(
            diagram_node,
            session,
            &mut imgbuf,
            (0.0, 0.0),
            scaling_factor,
        );

        // Write the PNG image to the stream
        let encoder = image::png::PngEncoder::new(stream);
        encoder
            .encode(
                imgbuf.as_raw(),
                imgbuf.width(),
                imgbuf.height(),
                image::ColorType::Rgba8,
            )
            .map_err(|e| RendererError::new(&e.to_string()))?;

        Ok(())
    }
}

// Render a node and its children
fn render_node(
    node: &DiagramTreeNode,
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    parent_offset: (Float, Float),
    scale: Float,
) {
    let entity_id = node.entity_id.clone();
    let pos = session.get_position(entity_id.clone());

    // Calculate absolute position by adding parent offset, then apply scaling
    let abs_pos = (
        (parent_offset.0 + pos.0) * scale,
        (parent_offset.1 + pos.1) * scale,
    );

    // Debug output to track node positioning
    let size = session.get_size(entity_id.clone());
    println!(
        "Rendering node type: {:?}, id: {}, pos: ({:.1}, {:.1}), size: ({:.1}, {:.1})",
        node.entity_type,
        entity_id.clone(),
        abs_pos.0,
        abs_pos.1,
        size.0,
        size.1
    );

    match node.entity_type {
        EntityType::GroupShape => {
            render_group(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::BoxShape => {
            render_box(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::TextShape => {
            render_text(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::VerticalStackShape => {
            render_vertical_stack(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::HorizontalStackShape => {
            render_horizontal_stack(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::ImageShape => {
            render_image(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::TableShape => {
            // Get table properties
            let table_shape = session.get_table(entity_id.clone());
            let size = session.get_size(entity_id.clone());

            // Apply scaling factor to dimensions
            let width = (size.0 * scale).ceil() as u32;
            let height = (size.1 * scale).ceil() as u32;
            let x = abs_pos.0.round() as i32;
            let y = abs_pos.1.round() as i32;

            if x >= 0
                && y >= 0
                && width > 0
                && height > 0
                && x + width as i32 <= imgbuf.width() as i32
                && y + height as i32 <= imgbuf.height() as i32
            {
                // Draw table outer border with specified color
                let border_color = parse_color(&table_shape.table_options.border_color);
                let border_width = (table_shape.table_options.border_width as f32 * scale) as u32;

                // Draw outer border (make it thicker for visibility)
                let rect = Rect::at(x, y).of_size(width, height);
                for i in 0..border_width {
                    if i < border_width {
                        let inner_rect = Rect::at(x + i as i32, y + i as i32)
                            .of_size(width - 2 * i, height - 2 * i);
                        draw_hollow_rect_mut(imgbuf, inner_rect, border_color);
                    }
                }

                // Draw header area
                let header_rect = session.get_size(table_shape.header_rect.clone());
                let header_height = (header_rect.1 * scale).ceil() as u32;
                if header_height > 0 {
                    // Get the exact header color from the options
                    let header_fill_color =
                        parse_color(&table_shape.table_options.header_fill_color);

                    // Debug print the header color
                    println!(
                        "Table header color: {}",
                        table_shape.table_options.header_fill_color
                    );

                    // Fill the header area
                    let header_rect = Rect::at(x, y).of_size(width, header_height);
                    draw_filled_rect_mut(imgbuf, header_rect, header_fill_color);
                    draw_hollow_rect_mut(imgbuf, header_rect, border_color);
                }

                // Use the predefined grid lines from the table
                // This uses the actual table_shape.col_lines and table_shape.row_lines
                // instead of trying to infer them from child positions

                // Draw column lines (vertical dividers)
                for col_line_id in &table_shape.col_lines {
                    // Get the position of this column line
                    let line_pos = session.get_position(col_line_id.clone());
                    let line_size = session.get_size(col_line_id.clone());

                    // Calculate the absolute x position with scaling
                    let line_x = (abs_pos.0 + line_pos.0 * scale as f32).round() as i32;

                    // Only draw if the line is within the image bounds
                    if line_x >= 0 && line_x < imgbuf.width() as i32 {
                        // Draw a vertical line from top to bottom of table
                        for i in 0..height {
                            let y_pos = y + i as i32;
                            if y_pos >= 0 && y_pos < imgbuf.height() as i32 {
                                imgbuf.put_pixel(line_x as u32, y_pos as u32, border_color);
                            }
                        }
                    }
                }

                // Draw row lines (horizontal dividers)
                for row_line_id in &table_shape.row_lines {
                    // Get the position of this row line
                    let line_pos = session.get_position(row_line_id.clone());
                    let line_size = session.get_size(row_line_id.clone());

                    // Calculate the absolute y position with scaling
                    let line_y = (abs_pos.1 + line_pos.1 * scale as f32).round() as i32;

                    // Only draw if the line is within the image bounds
                    if line_y >= 0 && line_y < imgbuf.height() as i32 {
                        // Draw a horizontal line from left to right of table
                        for i in 0..width {
                            let x_pos = x + i as i32;
                            if x_pos >= 0 && x_pos < imgbuf.width() as i32 {
                                imgbuf.put_pixel(x_pos as u32, line_y as u32, border_color);
                            }
                        }
                    }
                }

                // Render children (cells)
                for child in node.children.iter() {
                    render_node(child, session, imgbuf, abs_pos, scale);
                }
            }
        }
        EntityType::EllipseShape => {
            // Get ellipse properties
            let ellipse_shape = session.get_ellipse(entity_id.clone());
            let size = session.get_size(entity_id.clone());

            // Apply scaling factor to dimensions
            let width = (size.0 * scale).ceil() as u32;
            let height = (size.1 * scale).ceil() as u32;
            let x = abs_pos.0.round() as i32;
            let y = abs_pos.1.round() as i32;

            if x >= 0
                && y >= 0
                && width > 0
                && height > 0
                && x + width as i32 <= imgbuf.width() as i32
                && y + height as i32 <= imgbuf.height() as i32
            {
                // Get colors from the ellipse properties
                let fill_color = parse_color(&ellipse_shape.ellipse_options.fill_color);
                let stroke_color = parse_color(&ellipse_shape.ellipse_options.stroke_color);

                // Calculate center coordinates
                let center_x = x + (width / 2) as i32;
                let center_y = y + (height / 2) as i32;
                let radius_x = (width / 2) as i32;
                let radius_y = (height / 2) as i32;

                // Draw filled ellipse first, using floating point for more accurate ellipse equation
                for py in y..y + height as i32 {
                    if py < 0 || py >= imgbuf.height() as i32 {
                        continue; // Skip if outside vertical bounds
                    }

                    for px in x..x + width as i32 {
                        if px < 0 || px >= imgbuf.width() as i32 {
                            continue; // Skip if outside horizontal bounds
                        }

                        // Calculate if this pixel is inside the ellipse using floating point
                        // for higher precision: (x/a)² + (y/b)² <= 1
                        let dx = (px - center_x) as f32;
                        let dy = (py - center_y) as f32;
                        let rx = radius_x as f32;
                        let ry = radius_y as f32;

                        let eq_value = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry);

                        if eq_value <= 1.0 {
                            imgbuf.put_pixel(px as u32, py as u32, fill_color);
                        }
                    }
                }

                // Draw the ellipse border using a modified Bresenham algorithm for smoother outlines
                // This implementation gives much higher quality anti-aliased edges
                draw_anti_aliased_ellipse(
                    imgbuf,
                    center_x,
                    center_y,
                    radius_x,
                    radius_y,
                    stroke_color,
                    (ellipse_shape.ellipse_options.stroke_width * scale as f32) as f32,
                );
            }
        }
        EntityType::PolyLine => {
            render_polyline(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }
        EntityType::FreeContainer => {
            render_free_container(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }

        EntityType::ArcShape => {
            render_arc(session, imgbuf, entity_id.clone(), node, abs_pos, scale);
        }

        // For this initial implementation, we'll skip other shapes
        _ => {}
    }
}

fn render_arc(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    use std::f32::consts::PI;
    
    let arc_shape = session.get_arc(entity_id.clone());
    let size = session.get_size(entity_id.clone());
    
    // Apply scaling factor to dimensions
    let scaled_radius = arc_shape.radius * scale;
    let center_x = (pos.0 + arc_shape.center.0 * scale) as i32;
    let center_y = (pos.1 + arc_shape.center.1 * scale) as i32;
    
    // Get colors
    let stroke_color = parse_color(&arc_shape.arc_options.stroke_color);
    let fill_color = parse_color(&arc_shape.arc_options.fill_color);
    let stroke_width = arc_shape.arc_options.stroke_width * scale;
    
    // Get normalized angles and convert to radians
    let (start_angle, end_angle) = arc_shape.normalize_angles();
    let start_rad = start_angle * PI / 180.0;
    let end_rad = end_angle * PI / 180.0;
    
    // For filled arcs, we need to fill the sector
    if arc_shape.arc_options.filled {
        render_filled_arc_sector(
            imgbuf,
            center_x,
            center_y,
            scaled_radius,
            start_rad,
            end_rad,
            fill_color,
            stroke_color,
            stroke_width,
        );
    } else {
        // For unfilled arcs, just draw the arc curve
        render_arc_curve(
            imgbuf,
            center_x,
            center_y,
            scaled_radius,
            start_rad,
            end_rad,
            stroke_color,
            stroke_width,
        );
    }
}

// Helper function to render a filled arc sector (pie slice)
fn render_filled_arc_sector(
    imgbuf: &mut RgbaImage,
    center_x: i32,
    center_y: i32,
    radius: Float,
    start_rad: Float,
    end_rad: Float,
    fill_color: Rgba<u8>,
    stroke_color: Rgba<u8>,
    stroke_width: Float,
) {
    let radius_i = radius as i32;
    
    // Fill the sector by checking each pixel in the bounding box
    for y in (center_y - radius_i)..=(center_y + radius_i) {
        for x in (center_x - radius_i)..=(center_x + radius_i) {
            if x >= 0 && x < imgbuf.width() as i32 && y >= 0 && y < imgbuf.height() as i32 {
                let dx = (x - center_x) as Float;
                let dy = (y - center_y) as Float;
                let distance = (dx * dx + dy * dy).sqrt();
                
                if distance <= radius {
                    // Calculate angle of this pixel
                    let angle = dy.atan2(dx);
                    let angle_deg = angle * 180.0 / std::f32::consts::PI;
                    let normalized_angle = if angle_deg < 0.0 { angle_deg + 360.0 } else { angle_deg };
                    
                    // Check if this angle is within our arc
                    let start_deg = start_rad * 180.0 / std::f32::consts::PI;
                    let end_deg = end_rad * 180.0 / std::f32::consts::PI;
                    
                    let angle_in_arc = if end_deg > start_deg {
                        normalized_angle >= start_deg && normalized_angle <= end_deg
                    } else {
                        normalized_angle >= start_deg || normalized_angle <= end_deg
                    };
                    
                    if angle_in_arc {
                        imgbuf.put_pixel(x as u32, y as u32, fill_color);
                    }
                }
            }
        }
    }
    
    // Draw the arc outline
    render_arc_curve(imgbuf, center_x, center_y, radius, start_rad, end_rad, stroke_color, stroke_width);
    
    // Draw lines from center to arc endpoints for filled sectors
    let start_x = center_x + (radius * start_rad.cos()) as i32;
    let start_y = center_y + (radius * start_rad.sin()) as i32;
    let end_x = center_x + (radius * end_rad.cos()) as i32;
    let end_y = center_y + (radius * end_rad.sin()) as i32;
    
    draw_anti_aliased_line(imgbuf, center_x, center_y, start_x, start_y, stroke_color, stroke_width);
    draw_anti_aliased_line(imgbuf, center_x, center_y, end_x, end_y, stroke_color, stroke_width);
}

// Helper function to render just the arc curve
fn render_arc_curve(
    imgbuf: &mut RgbaImage,
    center_x: i32,
    center_y: i32,
    radius: Float,
    start_rad: Float,
    end_rad: Float,
    stroke_color: Rgba<u8>,
    stroke_width: Float,
) {
    // Calculate the angle step based on radius for smooth curves
    let num_steps = (radius * 2.0).max(60.0) as i32; // More steps for larger arcs
    let angle_range = if end_rad > start_rad {
        end_rad - start_rad
    } else {
        (2.0 * std::f32::consts::PI) - start_rad + end_rad
    };
    
    let angle_step = angle_range / num_steps as Float;
    
    let mut prev_x = center_x + (radius * start_rad.cos()) as i32;
    let mut prev_y = center_y + (radius * start_rad.sin()) as i32;
    
    for i in 1..=num_steps {
        let current_angle = if end_rad > start_rad {
            start_rad + angle_step * i as Float
        } else {
            let angle = start_rad + angle_step * i as Float;
            if angle > 2.0 * std::f32::consts::PI {
                angle - 2.0 * std::f32::consts::PI
            } else {
                angle
            }
        };
        
        let current_x = center_x + (radius * current_angle.cos()) as i32;
        let current_y = center_y + (radius * current_angle.sin()) as i32;
        
        draw_anti_aliased_line(imgbuf, prev_x, prev_y, current_x, current_y, stroke_color, stroke_width);
        
        prev_x = current_x;
        prev_y = current_y;
    }
}

fn render_group(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    _entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    for child in node.children.iter() {
        render_node(child, session, imgbuf, pos, scale);
    }
}

fn render_box(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    let size = session.get_size(entity_id.clone());
    let box_shape = session.get_box(node.entity_id.clone());

    // Convert to i32 for drawing functions with scaling
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    // Safety check to avoid drawing outside the image bounds
    if x < 0
        || y < 0
        || width == 0
        || height == 0
        || x + width as i32 > imgbuf.width() as i32
        || y + height as i32 > imgbuf.height() as i32
    {
        // Skip this box if it's outside the bounds
        return;
    }

    let rect = Rect::at(x, y).of_size(width, height);

    // Handle fill color
    match &box_shape.box_options.fill_color {
        Fill::Color(color) => {
            let rgba = parse_color(color);
            draw_filled_rect_mut(imgbuf, rect, rgba);
        }
        // For now, we'll just use a default color for gradients
        _ => {
            draw_filled_rect_mut(imgbuf, rect, Rgba([255, 255, 255, 255]));
        }
    }

    // Draw border/stroke with scaled width
    let stroke_color = parse_color(&box_shape.box_options.stroke_color);
    let stroke_width = (box_shape.box_options.stroke_width * scale).ceil() as u32;

    // Draw border with proper thickness
    for i in 0..stroke_width {
        if i < stroke_width {
            let inner_rect =
                Rect::at(x + i as i32, y + i as i32).of_size(width - 2 * i, height - 2 * i);
            draw_hollow_rect_mut(imgbuf, inner_rect, stroke_color);
        }
    }

    // Render children inside the box, accounting for padding
    for child in node.children.iter() {
        let child_id = child.entity_id.clone();
        let child_pos = session.get_position(child_id.clone());

        // Instead of trying to be clever about nested transforms, let's use the simplest
        // and most direct approach: manually handle rendering the text here

        // Log child details
        println!(
            "Rendering box child: id={}, type={:?}, box_pos=({:.1},{:.1}), child_pos=({:.1},{:.1})",
            child_id.clone(),
            child.entity_type,
            pos.0,
            pos.1,
            child_pos.0,
            child_pos.1
        );

        // Get absolute position for child relative to box
        let abs_x = (pos.0 + child_pos.0 * scale).round() as i32;
        let abs_y = (pos.1 + child_pos.1 * scale).round() as i32;

        // Calculate absolute position without any scaling
        let adjusted_parent_offset = (pos.0 / scale, pos.1 / scale);

        // Log the adjusted values
        println!(
            "  Using adjusted_parent_offset=({:.1},{:.1})",
            adjusted_parent_offset.0, adjusted_parent_offset.1
        );

        // Render the child with the adjusted parent offset
        // TODO: Centering logic for elems inside box
        render_node(child, session, imgbuf, adjusted_parent_offset, scale);
    }
}

fn render_text(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Get the text and render it directly
    let text_shape = session.get_text(entity_id.clone());
    //get size
    let size = session.get_size(entity_id.clone());
    //TODO: dynamically load the font data!
    //let font_data = include_bytes!("../../demo/assets/Roboto-Regular.ttf");
    let font_data = include_bytes!("../../demo/assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    // Convert text color string to RGBA
    let text_color = parse_color(&text_shape.text_options.text_color);
    println!(
        "  Text: '{}', color: {}, pos: ({}, {})",
        text_shape.text, text_shape.text_options.text_color, pos.0, pos.1
    );

    // Render text directly
    // let dpi = 120.0;
    // let dpi_scale_factor = dpi / 72.0;
    // let font_size = text_shape.text_options.font_size * dpi_scale_factor;

    let font_size = text_shape.text_options.font_size;
    let font_scale = Scale::uniform(font_size * scale as f32);

    // Render each line - use position data from layout engine
    // but adjust line spacing if needed for better aesthetics
    let line_count = text_shape.lines.len();
    let line_spacing_factor = if line_count > 1 { 0.6 } else { 1.0 }; // Further reduce spacing for multi-line text in boxes

    for (i, line_id) in text_shape.lines.iter().enumerate() {
        let line = session.get_text_line(line_id.clone());
        let lineSize = session.get_size(line_id.clone());
        let line_pos = session.get_position(line_id.clone());

        // Calculate base position without any margins yet
        let base_x = (pos.0 * scale) as i32 + (line_pos.0 * scale).round() as i32;

        // For multi-line text, calculate position with adjusted spacing
        let y_pos = if i == 0 {
            // First line uses original position
            line_pos.1
        } else {
            // Subsequent lines use compressed spacing
            let prev_line_pos = session.get_position(text_shape.lines[i - 1].clone());
            prev_line_pos.1 + (line_pos.1 - prev_line_pos.1) * line_spacing_factor
        };

        let line_y = pos.0 as i32 + (y_pos * scale).round() as i32;

        // Calculate the actual rendered text width using font metrics
        // for precise centering
        //let rendered_width = get_text_width(&line.text, &font, font_scale);
        let rendered_width = lineSize.0;
        // Calculate the left-side bearing (space before the first glyph)
        // This is needed because RustType positioning doesn't always start exactly at the x position we provide
        let first_char_glyph = font
            .glyph(line.text.chars().next().unwrap_or(' '))
            .scaled(font_scale)
            .positioned(rusttype::point(0.0, 0.0));

        let left_bearing = if let Some(bb) = first_char_glyph.pixel_bounding_box() {
            bb.min.x
        } else {
            0
        };

        // Center the text horizontally within the box
        // Adjust for the bounding box left side offset
        let centered_x =
            base_x + ((lineSize.0 as f32 - rendered_width as f32) / 2.0) as i32 - left_bearing;

        // Draw the text with centered position
        draw_high_quality_text(
            imgbuf,
            &line.text,
            centered_x,
            line_y,
            &font,
            font_scale,
            text_color,
            size.0 as i32, // Use box width as max width
        );
    }
}

// Draw text with higher quality anti-aliasing
fn draw_high_quality_text(
    imgbuf: &mut RgbaImage,
    text: &str,
    x: i32,
    y: i32,
    font: &Font,
    scale: Scale,
    color: Rgba<u8>,
    _max_width: i32, // We keep this parameter for API compatibility but don't use it
) {
    // Calculate the vertical metrics once
    let v_metrics = font.v_metrics(scale);
    let offset_y = v_metrics.ascent;

    // Layout the glyphs in the text with proper positioning
    let mut caret = rusttype::point(0.0, offset_y);
    let mut last_glyph_id = None;
    let mut glyphs: Vec<rusttype::PositionedGlyph> = Vec::new();

    // Process each character for proper kerning and positioning
    for c in text.chars() {
        // Create the glyph
        let base_glyph = font.glyph(c);

        // Apply kerning if we have a previous glyph
        if let Some(previous) = last_glyph_id {
            caret.x += font.pair_kerning(scale, previous, base_glyph.id());
        }

        last_glyph_id = Some(base_glyph.id());

        // Get the advance width before we consume the glyph with scaled()
        let advance_width = base_glyph.scaled(scale).h_metrics().advance_width;

        // Position the glyph and add it to our collection
        // We need to create the glyph again since scaled() consumes it
        let positioned_glyph = font.glyph(c).scaled(scale).positioned(caret);
        glyphs.push(positioned_glyph);

        // Advance the caret using our saved advance_width
        caret.x += advance_width;
    }

    // Draw each glyph with anti-aliasing
    for glyph in &glyphs {
        if let Some(bounding_box) = glyph.pixel_bounding_box() {
            // Draw the glyph into the image
            glyph.draw(|gx, gy, glyph_opacity| {
                // Map to actual screen position
                let px = x + bounding_box.min.x + gx as i32;
                let py = y + bounding_box.min.y + gy as i32;

                // Only draw if inside image bounds
                if px >= 0 && px < imgbuf.width() as i32 && py >= 0 && py < imgbuf.height() as i32 {
                    // Create a color with adjusted alpha for anti-aliasing
                    let alpha = (glyph_opacity * color[3] as f32) as u8;
                    let antialiased_color = Rgba([color[0], color[1], color[2], alpha]);

                    // Blend with existing pixels for smoother rendering
                    blend_pixel(imgbuf, px, py, antialiased_color, glyph_opacity);
                }
            });
        }
    }
}

fn render_vertical_stack(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Draw a debug rectangle to show the stack bounds
    let size = session.get_size(entity_id.clone());
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    if x >= 0
        && y >= 0
        && width > 0
        && height > 0
        && x + width as i32 <= imgbuf.width() as i32
        && y + height as i32 <= imgbuf.height() as i32
    {
        let rect = Rect::at(x, y).of_size(width, height);
        draw_hollow_rect_mut(imgbuf, rect, Rgba([0, 0, 255, 128]));
    }

    // Render children
    for child in node.children.iter() {
        render_node(child, session, imgbuf, pos, scale);
    }
}

fn render_horizontal_stack(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Draw a debug rectangle to show the stack bounds
    let size = session.get_size(entity_id.clone());
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    if x >= 0
        && y >= 0
        && width > 0
        && height > 0
        && x + width as i32 <= imgbuf.width() as i32
        && y + height as i32 <= imgbuf.height() as i32
    {
        let rect = Rect::at(x, y).of_size(width, height);
        draw_hollow_rect_mut(imgbuf, rect, Rgba([0, 255, 0, 128]));
    }

    // Render children
    for child in node.children.iter() {
        render_node(child, session, imgbuf, pos, scale);
    }
}

fn render_polyline(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    _node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Get polyline properties
    let polyline = session.get_polyline(entity_id.clone());
    let stroke_color = parse_color(&polyline.line_options.stroke_color);
    let stroke_width = (polyline.line_options.stroke_width * scale) as f32;

    // Need at least 2 points to draw a line
    if polyline.points.len() < 2 {
        return;
    }

    // Calculate absolute position with scaling
    let abs_x = pos.0;
    let abs_y = pos.1;

    // Draw line segments connecting all points
    for i in 0..polyline.points.len() - 1 {
        let (x1, y1) = polyline.points[i];
        let (x2, y2) = polyline.points[i + 1];

        // Apply scaling and offset
        let x1_scaled = (abs_x + x1 * scale) as i32;
        let y1_scaled = (abs_y + y1 * scale) as i32;
        let x2_scaled = (abs_x + x2 * scale) as i32;
        let y2_scaled = (abs_y + y2 * scale) as i32;

        // Draw an anti-aliased line with proper thickness
        draw_anti_aliased_line(
            imgbuf,
            x1_scaled,
            y1_scaled,
            x2_scaled,
            y2_scaled,
            stroke_color,
            stroke_width,
        );
    }

    // If it's a closed path (first point == last point), we're already done
    // Otherwise, check if the polyline should be closed by connecting last point to first
    if polyline.points.len() > 2 && polyline.points[0] != polyline.points[polyline.points.len() - 1]
    {
        // If user wants a closed shape (determined by checking if the first and last points are close enough)
        // This is just a heuristic - future implementations could add an explicit "closed" property
        let first = polyline.points[0];
        let last = polyline.points[polyline.points.len() - 1];
        let distance = ((first.0 - last.0).powi(2) + (first.1 - last.1).powi(2)).sqrt();

        // If points are very close, consider it a closed shape (like a polygon)
        if distance < 5.0 {
            // Apply scaling and offset
            let x1_scaled = (abs_x + last.0 * scale) as i32;
            let y1_scaled = (abs_y + last.1 * scale) as i32;
            let x2_scaled = (abs_x + first.0 * scale) as i32;
            let y2_scaled = (abs_y + first.1 * scale) as i32;

            // Draw the closing line
            draw_anti_aliased_line(
                imgbuf,
                x1_scaled,
                y1_scaled,
                x2_scaled,
                y2_scaled,
                stroke_color,
                stroke_width,
            );
        }
    }
}

fn render_free_container(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Log debug information
    println!("==================================================");
    println!(
        "Rendering FreeContainer: id={}, pos=({:.1}, {:.1})",
        entity_id.clone(),
        pos.0,
        pos.1
    );

    // Unscale the position (since render_node applies scaling for us)
    let container_pos = session.get_position(entity_id.clone());
    let size = session.get_size(entity_id.clone());

    // Convert to i32 for drawing functions with scaling
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;

    println!("FreeContainer size: {}x{}", width, height);
    println!("FreeContainer absolute position: x={}, y={}", x, y);

    // Get the container object
    let container = session.get_free_container(entity_id.clone());

    // Draw the container background first if specified
    if let Some(bg_color) = &container.background_color {
        let fill_color = parse_color(bg_color);
        let rect = Rect::at(x, y).of_size(width, height);
        draw_filled_rect_mut(imgbuf, rect, fill_color);
        println!("Drew container background with color: {}", bg_color);
    }

    // Draw the container border if specified
    if let Some(border_color) = &container.border_color {
        if container.border_width > 0.0 {
            let stroke_color = parse_color(border_color);
            let stroke_width = (container.border_width * scale).ceil() as u32;

            // Draw border with proper thickness
            for i in 0..stroke_width {
                if i < stroke_width {
                    let inner_rect =
                        Rect::at(x + i as i32, y + i as i32).of_size(width - 2 * i, height - 2 * i);
                    draw_hollow_rect_mut(imgbuf, inner_rect, stroke_color);
                }
            }
            println!("Drew container border with color: {}", border_color);
        }
    }

    // Log the children counts
    println!(
        "Container has {} stored positions and {} children in tree",
        container.children.len(),
        node.children.len()
    );

    // Create a mapping from child entity IDs to their positions
    let mut child_positions = std::collections::HashMap::new();
    for (child_id, position) in &container.children {
        child_positions.insert(child_id.clone(), *position);
    }

    // Debug output of all children
    for (i, child) in node.children.iter().enumerate() {
        let child_id = child.entity_id.clone();
        if let Some(rel_pos) = child_positions.get(&child_id) {
            println!(
                "Child[{}]: id={}, type={:?}, stored_pos=({:.1},{:.1})",
                i, child_id, child.entity_type, rel_pos.0, rel_pos.1
            );
        } else {
            println!(
                "Child[{}]: id={}, type={:?}, NO STORED POSITION",
                i, child_id, child.entity_type
            );
        }
    }

    // Render each child with its calculated position
    for (i, child_node) in node.children.iter().enumerate() {
        let child_id = child_node.entity_id.clone();

        // Get the child's position relative to the container from the stored mapping
        if let Some(rel_pos) = child_positions.get(&child_id) {
            // Child is in the FreeContainer's children map

            // For debugging, get the child's size
            let child_size = session.get_size(child_id.clone());
            println!(
                "Child[{}]: id={}, size=({:.1},{:.1})",
                i,
                child_id.clone(),
                child_size.0,
                child_size.1
            );

            // The key fix: since render_node applies pos and scaling again,
            // we need to provide a corrected parent_offset that when combined with
            // the child's position and scaled will result in the correct absolute position

            // Get the child's original position in the session
            let original_child_pos = session.get_position(child_id.clone());

            // Calculate the expected final position we want
            let desired_final_pos = (pos.0 + rel_pos.0 * scale, pos.1 + rel_pos.1 * scale);

            // Calculate the parent_offset that will give us this position after render_node applies
            // its own calculation: abs_pos = (parent_offset + pos) * scale
            // So we need: parent_offset = desired_final_pos / scale - pos
            let adjusted_parent_offset = (
                desired_final_pos.0 / scale - original_child_pos.0,
                desired_final_pos.1 / scale - original_child_pos.1,
            );

            println!("Rendering child[{}]: desired_pos=({:.1},{:.1}), original_pos=({:.1},{:.1}), rel_pos=({:.1},{:.1})", 
                i, desired_final_pos.0, desired_final_pos.1, original_child_pos.0, original_child_pos.1, rel_pos.0, rel_pos.1);
            println!(
                "  Using adjusted_parent_offset=({:.1},{:.1})",
                adjusted_parent_offset.0, adjusted_parent_offset.1
            );

            render_node(child_node, session, imgbuf, adjusted_parent_offset, scale);
        } else {
            // Child doesn't have a stored position
            println!(
                "WARNING: Child[{}] id={} has no stored position in FreeContainer!",
                i, child_id
            );

            // For children without explicit positions in the container, we'll use their
            // original positions from the session, which might be relative to the container
            let child_pos = session.get_position(child_id);

            // Calculate the desired final position
            let desired_final_pos = (pos.0 + child_pos.0 * scale, pos.1 + child_pos.1 * scale);

            // The same adjustment as above for children with stored positions
            let adjusted_parent_offset = (
                desired_final_pos.0 / scale - child_pos.0,
                desired_final_pos.1 / scale - child_pos.1,
            );

            // Log the calculated position
            println!("Child[{}] with no stored position: desired_pos=({:.1},{:.1}), original_pos=({:.1},{:.1})", 
                     i, desired_final_pos.0, desired_final_pos.1, child_pos.0, child_pos.1);
            println!(
                "  Using adjusted_parent_offset=({:.1},{:.1})",
                adjusted_parent_offset.0, adjusted_parent_offset.1
            );

            // Render the child with the adjusted parent offset
            render_node(child_node, session, imgbuf, adjusted_parent_offset, scale);
        }
    }

    println!("==================================================");
}

fn render_image(
    session: &DiagramBuilder,
    imgbuf: &mut RgbaImage,
    entity_id: EntityID,
    _node: &DiagramTreeNode,
    pos: (Float, Float),
    scale: Float,
) {
    // Get image properties
    let image_shape = session.get_image(entity_id.clone());
    let size = session.get_size(entity_id.clone());

    // Apply scaling factor to dimensions
    let width = (size.0 * scale).ceil() as u32;
    let height = (size.1 * scale).ceil() as u32;
    let x = pos.0.round() as i32;
    let y = pos.1.round() as i32;

    // Skip if outside bounds
    if x < 0
        || y < 0
        || width == 0
        || height == 0
        || x + width as i32 > imgbuf.width() as i32
        || y + height as i32 > imgbuf.height() as i32
    {
        println!("Image outside bounds, skipping");
        return;
    }

    // Load the image either from file or base64 data
    let loaded_img = if let Some(file_path) = &image_shape.file_path {
        // Load image from file
        println!("Loading image from file: {}", file_path);
        match load_image_from_file(file_path) {
            Ok(img) => img,
            Err(e) => {
                println!("Error loading image from file: {}", e);
                // Return with a placeholder or error indicator
                draw_placeholder_image(imgbuf, x, y, width, height);
                return;
            }
        }
    } else if !image_shape.image.is_empty() {
        // Load image from base64 data
        println!("Loading image from base64 data");
        match load_image_from_base64(&image_shape.image) {
            Ok(img) => img,
            Err(e) => {
                println!("Error loading image from base64: {}", e);
                // Return with a placeholder or error indicator
                draw_placeholder_image(imgbuf, x, y, width, height);
                return;
            }
        }
    } else {
        println!("No image data or file path provided");
        // Draw an empty placeholder if no source is provided
        draw_placeholder_image(imgbuf, x, y, width, height);
        return;
    };

    // Resize the image to fit the allocated space while maintaining aspect ratio
    let resized_img = loaded_img.resize_exact(width, height, image::imageops::FilterType::Lanczos3);

    // Convert the image to an RgbaImage
    let img_rgba = resized_img.to_rgba8();

    // Draw the image onto our output buffer at the specified position
    for (ix, iy, pixel) in img_rgba.enumerate_pixels() {
        let dest_x = x + ix as i32;
        let dest_y = y + iy as i32;

        // Only draw within bounds
        if dest_x >= 0
            && dest_x < imgbuf.width() as i32
            && dest_y >= 0
            && dest_y < imgbuf.height() as i32
        {
            imgbuf.put_pixel(dest_x as u32, dest_y as u32, *pixel);
        }
    }

    // Draw a thin border around the image for visual clarity
    let border_color = Rgba([80, 80, 80, 255]);
    let rect = Rect::at(x, y).of_size(width, height);
    draw_hollow_rect_mut(imgbuf, rect, border_color);
}

// Helper function to load an image from a file
fn load_image_from_file(file_path: &str) -> Result<DynamicImage, String> {
    let path = Path::new(file_path);
    if !path.exists() {
        return Err(format!("File not found: {}", file_path));
    }

    match image::open(path) {
        Ok(img) => Ok(img),
        Err(e) => Err(format!("Failed to load image: {}", e)),
    }
}

// Helper function to load an image from base64 data
fn load_image_from_base64(base64_str: &str) -> Result<DynamicImage, String> {
    // Decode base64 string to bytes
    let img_data = match BASE64.decode(base64_str) {
        Ok(data) => data,
        Err(e) => return Err(format!("Failed to decode base64: {}", e)),
    };

    // Load image from memory
    match image::load_from_memory(&img_data) {
        Ok(img) => Ok(img),
        Err(e) => Err(format!("Failed to load image from memory: {}", e)),
    }
}

// Draw a placeholder for missing or error images
fn draw_placeholder_image(imgbuf: &mut RgbaImage, x: i32, y: i32, width: u32, height: u32) {
    // Fill with light gray
    let fill_color = Rgba([220, 220, 220, 255]);
    let rect = Rect::at(x, y).of_size(width, height);
    draw_filled_rect_mut(imgbuf, rect, fill_color);

    // Draw border
    let border_color = Rgba([150, 150, 150, 255]);
    draw_hollow_rect_mut(imgbuf, rect, border_color);

    // Draw an X from corner to corner
    if width > 10 && height > 10 {
        // Draw diagonal lines for the X
        for i in 0..width.min(height) {
            let ix = x + i as i32;
            let iy = y + i as i32;
            if ix < imgbuf.width() as i32 && iy < imgbuf.height() as i32 {
                imgbuf.put_pixel(ix as u32, iy as u32, Rgba([100, 100, 100, 255]));
            }

            let ix2 = x + i as i32;
            let iy2 = y + (height - i - 1) as i32;
            if ix2 < imgbuf.width() as i32 && iy2 >= 0 && iy2 < imgbuf.height() as i32 {
                imgbuf.put_pixel(ix2 as u32, iy2 as u32, Rgba([100, 100, 100, 255]));
            }
        }
    }
}

// Helper function to convert color string to Rgba
fn parse_color(color_str: &str) -> Rgba<u8> {
    match color_str.to_lowercase().as_str() {
        "black" => Rgba([0, 0, 0, 255]),
        "white" => Rgba([255, 255, 255, 255]),
        "red" => Rgba([255, 0, 0, 255]),
        "green" => Rgba([0, 255, 0, 255]),
        "blue" => Rgba([0, 0, 255, 255]),
        "yellow" => Rgba([255, 255, 0, 255]),
        "gray" | "grey" => Rgba([128, 128, 128, 255]),
        "lightgray" | "lightgrey" | "light gray" | "light grey" => Rgba([200, 200, 200, 255]),
        "darkgray" | "darkgrey" | "dark gray" | "dark grey" => Rgba([80, 80, 80, 255]),
        "orange" => Rgba([255, 165, 0, 255]),
        "purple" => Rgba([128, 0, 128, 255]),
        "brown" => Rgba([165, 42, 42, 255]),
        "cyan" => Rgba([0, 255, 255, 255]),
        "magenta" | "pink" => Rgba([255, 0, 255, 255]),
        _ => {
            println!("Parsing color: {}", color_str);
            // Handle hex color strings like "#RRGGBB" or "#RRGGBBAA"
            if color_str.starts_with('#') && (color_str.len() == 7 || color_str.len() == 9) {
                let r = u8::from_str_radix(&color_str[1..3], 16).unwrap_or(0);
                let g = u8::from_str_radix(&color_str[3..5], 16).unwrap_or(0);
                let b = u8::from_str_radix(&color_str[5..7], 16).unwrap_or(0);
                let a = if color_str.len() == 9 {
                    u8::from_str_radix(&color_str[7..9], 16).unwrap_or(255)
                } else {
                    255
                };
                println!("Parsed hex color to RGBA: [{}, {}, {}, {}]", r, g, b, a);
                Rgba([r, g, b, a])
            } else {
                // Return a visible color for unknown colors - use pink to make it obvious
                println!(
                    "WARNING: Unrecognized color '{}', defaulting to pink",
                    color_str
                );
                Rgba([255, 0, 255, 255])
            }
        }
    }
}

// Create an anti-aliased version of a color with adjustable alpha
fn blend_color(color: Rgba<u8>, intensity: f32) -> Rgba<u8> {
    // Calculate new alpha based on the original alpha and the intensity factor
    let alpha = (color[3] as f32 * intensity) as u8;
    Rgba([color[0], color[1], color[2], alpha])
}

// Blend a pixel with existing content for smooth anti-aliasing
fn blend_pixel(imgbuf: &mut RgbaImage, x: i32, y: i32, color: Rgba<u8>, alpha: f32) {
    if x < 0 || x >= imgbuf.width() as i32 || y < 0 || y >= imgbuf.height() as i32 {
        return;
    }

    // Get the existing pixel color
    let existing = imgbuf.get_pixel(x as u32, y as u32);

    // Alpha blending formula: new = alpha * src + (1 - alpha) * dst
    let blend_alpha = alpha.max(0.0).min(1.0);
    let inv_alpha = 1.0 - blend_alpha;

    let r = (color[0] as f32 * blend_alpha + existing[0] as f32 * inv_alpha) as u8;
    let g = (color[1] as f32 * blend_alpha + existing[1] as f32 * inv_alpha) as u8;
    let b = (color[2] as f32 * blend_alpha + existing[2] as f32 * inv_alpha) as u8;

    // Final alpha is combined alpha from both sources
    let a = (color[3] as f32 * blend_alpha + existing[3] as f32 * inv_alpha) as u8;

    imgbuf.put_pixel(x as u32, y as u32, Rgba([r, g, b, a]));
}

// Draw a pixel with bounds checking
fn safe_put_pixel(imgbuf: &mut RgbaImage, x: i32, y: i32, color: Rgba<u8>) {
    if x >= 0 && x < imgbuf.width() as i32 && y >= 0 && y < imgbuf.height() as i32 {
        imgbuf.put_pixel(x as u32, y as u32, color);
    }
}

// Draw an anti-aliased line between two points with a given thickness
fn draw_anti_aliased_line(
    imgbuf: &mut RgbaImage,
    x0: i32,
    y0: i32,
    x1: i32,
    y1: i32,
    color: Rgba<u8>,
    thickness: f32,
) {
    // Use Bresenham's algorithm for the core line
    // Convert i32 to isize for the Bresenham algorithm
    let x0_isize = x0 as isize;
    let y0_isize = y0 as isize;
    let x1_isize = x1 as isize;
    let y1_isize = y1 as isize;

    for (x_isize, y_isize) in Bresenham::new((x0_isize, y0_isize), (x1_isize, y1_isize)) {
        // Convert back to i32 for our drawing functions
        let x = x_isize as i32;
        let y = y_isize as i32;

        // Draw a "thick" point at each position along the line
        let radius = (thickness / 2.0).ceil() as i32;
        for dx in -radius..=radius {
            for dy in -radius..=radius {
                let dist = ((dx * dx + dy * dy) as f32).sqrt();
                // Calculate alpha based on distance from the line center
                let alpha = if dist <= thickness / 2.0 {
                    // Full opacity for inner pixels
                    1.0
                } else if dist <= thickness / 2.0 + 1.0 {
                    // Fade out for anti-aliasing at the edge (smooth transition)
                    1.0 - (dist - thickness / 2.0)
                } else {
                    // Outside the line's radius
                    0.0
                };

                // Only draw if there's some opacity
                if alpha > 0.0 {
                    // Use blend_pixel for smoother edges
                    blend_pixel(imgbuf, x + dx, y + dy, color, alpha);
                }
            }
        }
    }
}

// Helper function to calculate the exact rendered width of a text string
// Esta funcionaba, es la misma que se usa en measure text?
fn get_text_width(text: &str, font: &Font, scale: Scale) -> f32 {
    // Calculate the width using font metrics with kerning
    let mut caret = 0.0f32;
    let mut prev_glyph_id = None;

    for c in text.chars() {
        // Get the glyph
        let base_glyph = font.glyph(c);
        let glyph_id = base_glyph.id();

        // Add kerning if we have a previous glyph
        if let Some(prev_id) = prev_glyph_id {
            caret += font.pair_kerning(scale, prev_id, glyph_id);
        }

        // Get metrics for this glyph and add its advance width
        let advance_width = font.glyph(c).scaled(scale).h_metrics().advance_width;
        caret += advance_width;

        // Track previous glyph for kerning
        prev_glyph_id = Some(glyph_id);
    }

    // Return the final width
    caret
}

// Draw an anti-aliased ellipse with a given thickness
fn draw_anti_aliased_ellipse(
    imgbuf: &mut RgbaImage,
    cx: i32,
    cy: i32,
    a: i32,
    b: i32,
    color: Rgba<u8>,
    thickness: f32,
) {
    // For very small ellipses, use a simple algorithm
    if a <= 2 || b <= 2 {
        for angle_deg in 0..360 {
            let rad = angle_deg as Float * std::f32::consts::PI / 180.0;
            let x = cx + (a as f32 * rad.cos()).round() as i32;
            let y = cy + (b as f32 * rad.sin()).round() as i32;
            safe_put_pixel(imgbuf, x, y, color);
        }
        return;
    }

    // Improved ellipse drawing using line segments
    // Using more segments for smoother appearance - scale with radius for higher quality
    let num_segments = (a.max(b) * 8).max(120);

    // Calculate first point
    let first_angle: Float = 0.0;
    let first_x = cx + (a as f32 * first_angle.cos()).round() as i32;
    let first_y = cy + (b as f32 * first_angle.sin()).round() as i32;

    let mut prev_x = first_x;
    let mut prev_y = first_y;

    // Draw segments connecting points along the ellipse
    for i in 1..=num_segments {
        let angle = 2.0 * std::f32::consts::PI * (i as f32 / num_segments as f32);
        let x = cx + (a as f32 * angle.cos()).round() as i32;
        let y = cy + (b as f32 * angle.sin()).round() as i32;

        // Draw anti-aliased line segment between consecutive points
        draw_anti_aliased_line(imgbuf, prev_x, prev_y, x, y, color, thickness);

        prev_x = x;
        prev_y = y;
    }

    // Close the ellipse by connecting back to the first point
    draw_anti_aliased_line(imgbuf, prev_x, prev_y, first_x, first_y, color, thickness);
}


===/demo.txt===
===/Cargo.toml===
[package]
name = "demo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

#add dep to crate in local workspace
volare_engine_layout = { path = "../volare_engine_layout" }
svg_renderer = { path = "../svg_renderer" }
image_renderer = { path = "../image_renderer" }
resvg = "0.25.0"
rusttype = "0.9.3"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
uuid = { version = "1.8", features = ["v4"] }

[[bin]]
name = "textdemo"
path = "src/bin/text.rs"

[[bin]]
name = "demo"
path = "src/main.rs"

[[bin]]
name = "patterns"
path = "src/bin/patterns.rs"


===/.gitignore===
/target

===/src/measure_text.rs===
use rusttype::{point, Font, Scale};
use volare_engine_layout::{Float, TextOptions};

/**
 * Measure text using SVG character advance method
 * This method calculates the width based on the advance width of each character,
 * taking into account kerning between characters.
 * It provides a more accurate width for SVG rendering, especially for variable-width fonts.
 */
pub fn measure_text_svg_character_advance(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);

    let mut total_width = 0.0;
    let mut prev_glyph_id = None;

    for ch in text.chars() {
        let glyph = font.glyph(ch).scaled(scale);

        // Use horizontal advance instead of bounding box
        let advance_width = glyph.h_metrics().advance_width;

        // Add kerning if available
        if let Some(prev_id) = prev_glyph_id {
            total_width += font.pair_kerning(scale, prev_id, glyph.id());
        }

        total_width += advance_width;
        prev_glyph_id = Some(glyph.id());
    }

    // Use font metrics for height instead of glyph bounds
    let v_metrics = font.v_metrics(scale);
    let height = v_metrics.ascent - v_metrics.descent;

    (total_width as Float, height as Float)
}

// tight measurement that accounts for actual glyph positioning
// Used for PNG rendering
pub fn measure_text_ultra_tight(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);
    let v_metrics = font.v_metrics(scale);

    if text.is_empty() {
        return (0.0, (v_metrics.ascent - v_metrics.descent) as Float);
    }

    // Use rusttype's layout function which handles everything correctly
    // TODO: Needs unicode normalization for proper glyph handling, see comments of `layout` function
    let glyphs: Vec<_> = font.layout(text, scale, point(0.0, 0.0)).collect();

    // Find the actual visual bounds
    let mut min_x = f32::INFINITY;
    let mut max_x = f32::NEG_INFINITY;

    for glyph in &glyphs {
        if let Some(bb) = glyph.pixel_bounding_box() {
            min_x = min_x.min(bb.min.x as f32);
            max_x = max_x.max(bb.max.x as f32);
        }
    }

    let width = if min_x.is_finite() && max_x.is_finite() {
        max_x - min_x // Pure visual width, no padding
    } else {
        // Fallback for whitespace
        glyphs
            .iter()
            .map(|g| g.unpositioned().h_metrics().advance_width)
            .sum()
    };

    let height = v_metrics.ascent - v_metrics.descent;

    println!("ULTRA TIGHT: '{}' -> {:.2}x{:.2}", text, width, height);
    (width as Float, height as Float)
}

===/src/bin/city.rs===
// src/bin/intricate_city.rs
// Demo program that generates an intricate city using only polylines, rects, and free containers

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🏙️ Generando Ciudad Intrincada...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("intricate_city");
    std::fs::create_dir_all(&output_dir)?;

    // Generate the intricate city
    generate_intricate_city(&output_dir)?;

    println!("\n✅ Ciudad generada exitosamente!");
    println!("📁 Archivo guardado en: {}", output_dir.display());

    Ok(())
}

fn generate_intricate_city(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":1400,"height":900,"background":"#E6F3FF","children":["metro_grid","financial_district","tech_campus","cultural_quarter","harbor","mountain_range","sky_bridges","monorail","shopping_centers"]}

{"id":"metro_grid","type":"free_container","width":1400,"height":900,"children":["metro_line_1","metro_line_2","metro_line_3","metro_line_4","station_markers"],"x":0,"y":0}
{"id":"metro_line_1","type":"polyline","points":[[0,200],[300,205],[600,200],[900,205],[1200,200],[1400,205]],"stroke_color":"#FF6B6B","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_2","type":"polyline","points":[[0,450],[350,455],[700,450],[1050,455],[1400,450]],"stroke_color":"#4ECDC4","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_3","type":"polyline","points":[[200,0],[205,200],[200,400],[205,600],[200,800],[205,900]],"stroke_color":"#45B7D1","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_4","type":"polyline","points":[[800,0],[805,200],[800,400],[805,600],[800,800],[805,900]],"stroke_color":"#96CEB4","stroke_width":6,"x":0,"y":0}
{"id":"station_markers","type":"hstack","children":["station_1","station_2","station_3","station_4","station_5"],"v_align":"center","x":180,"y":180}
{"id":"station_1","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_2","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_3","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_4","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_5","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}

{"id":"financial_district","type":"vstack","children":["fd_tier_1","fd_tier_2","fd_tier_3","fd_plaza"],"h_align":"center","x":50,"y":50}
{"id":"fd_tier_1","type":"hstack","children":["tower_mega","tower_alpha","tower_beta"],"v_align":"bottom"}
{"id":"tower_mega","type":"rect","width":45,"height":180,"background":"#2C3E50"}
{"id":"tower_alpha","type":"rect","width":40,"height":160,"background":"#34495E"}
{"id":"tower_beta","type":"rect","width":35,"height":140,"background":"#7F8C8D"}
{"id":"fd_tier_2","type":"hstack","children":["bank_central","office_prime","office_gold"],"v_align":"bottom"}
{"id":"bank_central","type":"rect","width":50,"height":80,"background":"#F39C12"}
{"id":"office_prime","type":"rect","width":30,"height":100,"background":"#E74C3C"}
{"id":"office_gold","type":"rect","width":35,"height":90,"background":"#9B59B6"}
{"id":"fd_tier_3","type":"hstack","children":["retail_1","retail_2","retail_3","retail_4"],"v_align":"center"}
{"id":"retail_1","type":"rect","width":25,"height":25,"background":"#E67E22"}
{"id":"retail_2","type":"rect","width":25,"height":25,"background":"#E74C3C"}
{"id":"retail_3","type":"rect","width":25,"height":25,"background":"#9B59B6"}
{"id":"retail_4","type":"rect","width":25,"height":25,"background":"#3498DB"}
{"id":"fd_plaza","type":"rect","width":200,"height":15,"background":"#BDC3C7"}

{"id":"tech_campus","type":"free_container","width":300,"height":250,"children":["campus_layout","innovation_labs","data_centers"],"x":500,"y":100}
{"id":"campus_layout","type":"vstack","children":["tech_buildings","tech_courtyard","parking_structure"],"h_align":"center","x":0,"y":0}
{"id":"tech_buildings","type":"hstack","children":["lab_a","lab_b","lab_c","lab_d"],"v_align":"bottom"}
{"id":"lab_a","type":"rect","width":40,"height":80,"background":"#1ABC9C"}
{"id":"lab_b","type":"rect","width":35,"height":70,"background":"#16A085"}
{"id":"lab_c","type":"rect","width":45,"height":85,"background":"#3498DB"}
{"id":"lab_d","type":"rect","width":38,"height":75,"background":"#2980B9"}
{"id":"tech_courtyard","type":"rect","width":180,"height":40,"background":"#2ECC71"}
{"id":"parking_structure","type":"hstack","children":["parking_level_1","parking_level_2","parking_level_3"],"v_align":"center"}
{"id":"parking_level_1","type":"rect","width":50,"height":15,"background":"#95A5A6"}
{"id":"parking_level_2","type":"rect","width":50,"height":15,"background":"#7F8C8D"}
{"id":"parking_level_3","type":"rect","width":50,"height":15,"background":"#95A5A6"}
{"id":"innovation_labs","type":"polyline","points":[[0,0],[50,20],[100,10],[150,30],[200,15],[250,25],[300,20]],"stroke_color":"#E74C3C","stroke_width":3,"x":0,"y":50}
{"id":"data_centers","type":"vstack","children":["server_1","server_2"],"h_align":"right","x":220,"y":180}
{"id":"server_1","type":"rect","width":60,"height":30,"background":"#34495E"}
{"id":"server_2","type":"rect","width":60,"height":25,"background":"#2C3E50"}

{"id":"cultural_quarter","type":"free_container","width":280,"height":200,"children":["museums","theaters","galleries"],"x":900,"y":250}
{"id":"museums","type":"vstack","children":["museum_art","museum_history","museum_science"],"h_align":"left","x":0,"y":0}
{"id":"museum_art","type":"hstack","children":["art_wing_1","art_wing_2","art_central"],"v_align":"center"}
{"id":"art_wing_1","type":"rect","width":30,"height":40,"background":"#8E44AD"}
{"id":"art_wing_2","type":"rect","width":30,"height":40,"background":"#9B59B6"}
{"id":"art_central","type":"rect","width":50,"height":60,"background":"#663399"}
{"id":"museum_history","type":"rect","width":120,"height":35,"background":"#D35400"}
{"id":"museum_science","type":"hstack","children":["planetarium","exhibits","imax"],"v_align":"center"}
{"id":"planetarium","type":"rect","width":25,"height":25,"background":"#2C3E50"}
{"id":"exhibits","type":"rect","width":60,"height":30,"background":"#34495E"}
{"id":"imax","type":"rect","width":35,"height":28,"background":"#2C3E50"}
{"id":"theaters","type":"hstack","children":["opera_house","concert_hall"],"v_align":"bottom","x":140,"y":20}
{"id":"opera_house","type":"vstack","children":["opera_dome","opera_base"],"h_align":"center"}
{"id":"opera_dome","type":"rect","width":40,"height":20,"background":"#E67E22"}
{"id":"opera_base","type":"rect","width":60,"height":40,"background":"#D35400"}
{"id":"concert_hall","type":"rect","width":45,"height":70,"background":"#F39C12"}
{"id":"galleries","type":"polyline","points":[[0,150],[40,160],[80,150],[120,160],[160,150],[200,160],[240,150],[280,160]],"stroke_color":"#9B59B6","stroke_width":4,"x":0,"y":0}

{"id":"harbor","type":"free_container","width":400,"height":300,"children":["waterfront","docks","marina","lighthouse"],"x":1000,"y":600}
{"id":"waterfront","type":"rect","width":400,"height":300,"background":"#3498DB","x":0,"y":0}
{"id":"docks","type":"vstack","children":["pier_1","pier_2","pier_3"],"h_align":"left","x":20,"y":50}
{"id":"pier_1","type":"hstack","children":["dock_a","dock_b","dock_c"],"v_align":"center"}
{"id":"dock_a","type":"rect","width":60,"height":8,"background":"#8B4513"}
{"id":"dock_b","type":"rect","width":60,"height":8,"background":"#A0522D"}
{"id":"dock_c","type":"rect","width":60,"height":8,"background":"#8B4513"}
{"id":"pier_2","type":"rect","width":200,"height":10,"background":"#654321"}
{"id":"pier_3","type":"hstack","children":["slip_1","slip_2","slip_3","slip_4"],"v_align":"center"}
{"id":"slip_1","type":"rect","width":40,"height":6,"background":"#8B4513"}
{"id":"slip_2","type":"rect","width":40,"height":6,"background":"#A0522D"}
{"id":"slip_3","type":"rect","width":40,"height":6,"background":"#8B4513"}
{"id":"slip_4","type":"rect","width":40,"height":6,"background":"#A0522D"}
{"id":"marina","type":"polyline","points":[[50,200],[80,220],[120,210],[160,230],[200,220],[240,240],[280,230]],"stroke_color":"white","stroke_width":2,"x":0,"y":0}
{"id":"lighthouse","type":"vstack","children":["lighthouse_base","lighthouse_tower","lighthouse_light"],"h_align":"center","x":350,"y":180}
{"id":"lighthouse_base","type":"rect","width":20,"height":30,"background":"#E74C3C"}
{"id":"lighthouse_tower","type":"rect","width":12,"height":60,"background":"white"}
{"id":"lighthouse_light","type":"rect","width":16,"height":8,"background":"#F1C40F"}

{"id":"mountain_range","type":"polyline","points":[[0,0],[100,50],[200,20],[300,80],[400,30],[500,90],[600,40],[700,100],[800,50],[900,110],[1000,60],[1100,120],[1200,70],[1300,130],[1400,80]],"stroke_color":"#7D6E3E","stroke_width":30,"x":0,"y":0}

{"id":"sky_bridges","type":"free_container","width":1400,"height":900,"children":["bridge_network","aerial_walkways"],"x":0,"y":0}
{"id":"bridge_network","type":"hstack","children":["sky_bridge_1","sky_bridge_2","sky_bridge_3"],"v_align":"center","x":100,"y":150}
{"id":"sky_bridge_1","type":"polyline","points":[[0,0],[150,10],[300,0]],"stroke_color":"#BDC3C7","stroke_width":4,"x":0,"y":0}
{"id":"sky_bridge_2","type":"polyline","points":[[0,0],[200,15],[400,0]],"stroke_color":"#95A5A6","stroke_width":4,"x":0,"y":0}
{"id":"sky_bridge_3","type":"polyline","points":[[0,0],[180,8],[360,0]],"stroke_color":"#BDC3C7","stroke_width":4,"x":0,"y":0}
{"id":"aerial_walkways","type":"vstack","children":["walkway_level_1","walkway_level_2"],"h_align":"center","x":600,"y":100}
{"id":"walkway_level_1","type":"polyline","points":[[0,0],[100,5],[200,0],[300,5],[400,0]],"stroke_color":"#ECF0F1","stroke_width":3,"x":0,"y":0}
{"id":"walkway_level_2","type":"polyline","points":[[50,0],[150,8],[250,0],[350,8],[450,0]],"stroke_color":"#BDC3C7","stroke_width":3,"x":0,"y":0}

{"id":"monorail","type":"polyline","points":[[0,350],[200,355],[400,350],[600,355],[800,350],[1000,355],[1200,350],[1400,355]],"stroke_color":"#2C3E50","stroke_width":8,"x":0,"y":0}

{"id":"shopping_centers","type":"free_container","width":600,"height":400,"children":["mall_complex","outdoor_plaza","market_district"],"x":250,"y":500}
{"id":"mall_complex","type":"vstack","children":["mall_upper","mall_main","mall_food_court"],"h_align":"center","x":0,"y":0}
{"id":"mall_upper","type":"hstack","children":["store_1","store_2","store_3","store_4","store_5"],"v_align":"center"}
{"id":"store_1","type":"rect","width":40,"height":30,"background":"#E91E63"}
{"id":"store_2","type":"rect","width":35,"height":30,"background":"#9C27B0"}
{"id":"store_3","type":"rect","width":45,"height":30,"background":"#673AB7"}
{"id":"store_4","type":"rect","width":38,"height":30,"background":"#3F51B5"}
{"id":"store_5","type":"rect","width":42,"height":30,"background":"#2196F3"}
{"id":"mall_main","type":"rect","width":250,"height":40,"background":"#F5F5F5"}
{"id":"mall_food_court","type":"hstack","children":["restaurant_1","restaurant_2","restaurant_3","seating"],"v_align":"center"}
{"id":"restaurant_1","type":"rect","width":50,"height":25,"background":"#FF5722"}
{"id":"restaurant_2","type":"rect","width":45,"height":25,"background":"#FF9800"}
{"id":"restaurant_3","type":"rect","width":40,"height":25,"background":"#FFC107"}
{"id":"seating","type":"rect","width":80,"height":25,"background":"#FFEB3B"}
{"id":"outdoor_plaza","type":"free_container","width":200,"height":150,"children":["plaza_fountains","plaza_vendors"],"x":300,"y":50}
{"id":"plaza_fountains","type":"vstack","children":["fountain_main","fountain_small_1","fountain_small_2"],"h_align":"center","x":50,"y":20}
{"id":"fountain_main","type":"rect","width":30,"height":30,"background":"#00BCD4"}
{"id":"fountain_small_1","type":"rect","width":15,"height":15,"background":"#26C6DA"}
{"id":"fountain_small_2","type":"rect","width":15,"height":15,"background":"#26C6DA"}
{"id":"plaza_vendors","type":"hstack","children":["vendor_1","vendor_2","vendor_3"],"v_align":"center","x":20,"y":100}
{"id":"vendor_1","type":"rect","width":25,"height":15,"background":"#4CAF50"}
{"id":"vendor_2","type":"rect","width":25,"height":15,"background":"#8BC34A"}
{"id":"vendor_3","type":"rect","width":25,"height":15,"background":"#CDDC39"}
{"id":"market_district","type":"polyline","points":[[400,200],[450,220],[500,200],[550,220],[600,200]],"stroke_color":"#795548","stroke_width":6,"x":0,"y":0}"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("intricate_city.svg"), "Ciudad Intrincada")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}

===/src/bin/custom_components.rs===
// src/bin/custom_component_demo.rs
// Demo program showing how to register and use custom components

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::{fmt::format, fs::File};
use volare_engine_layout::*;

// Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

/// Custom Component 1: Badge
/// Creates a rounded pill-shaped element with text
fn create_badge_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("🏷️  Creating badge component with attrs: {:?}", attrs);

    // Extract attributes
    let text = get_string_attr(attrs, "text", "Badge");
    let background = get_string_attr(attrs, "background", "blue");
    let color = get_string_attr(attrs, "color", "white");
    let font_size = get_float_attr(attrs, "font_size", 12.0);
    let padding = get_float_attr(attrs, "padding", 8.0);

    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        id =  uuid::Uuid::new_v4().to_string()
    }

    // Create text element
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size,
        text_color: color,
        line_width: 200,
        line_spacing: 0.0,
    };
    let text_node = builder.new_text(
        format!("{}_text", id),
        &text, text_options);

    // Wrap in rounded box
    let box_options = BoxOptions {
        fill_color: Fill::Color(background),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding,
        border_radius: font_size,               // Make it pill-shaped
        width_behavior: SizeBehavior::Content,  // Auto width based on text
        height_behavior: SizeBehavior::Content, // Auto height based on text
    };
    let badge = builder.new_box(
        id,
        text_node, box_options);

    println!("✅ Badge '{}' created successfully", text);
    Ok(badge)
}

/// Custom Component 2: Alert Box
/// Creates an alert with optional icon, title, and message
fn create_alert_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("⚠️  Creating alert component with attrs: {:?}", attrs);

    let alert_type = get_string_attr(attrs, "alert-type", "info");
    let title = get_string_attr(attrs, "title", "Alert");
    let message = get_string_attr(attrs, "message", "Alert message");
    let width = get_float_attr(attrs, "width", 300.0);
    let show_icon = get_bool_attr(attrs, "show_icon", true);
    let mut id = get_string_attr(attrs, "id", "");

    if id.is_empty() {
        id = uuid::Uuid::new_v4().to_string()
    }

    //TODO aqui seria util tener
    // let context = builder.CreateComponentContext(id)
    // y todos los elems internos les asigna prefijo el id
    // util para no tener que concatenarlos

    // Define alert styles
    let (bg_color, border_color, icon) = match alert_type.as_str() {
        "success" => ("#d4edda", "#28a745", "✓"),
        "warning" => ("#fff3cd", "#ffc107", "⚠"),
        "error" => ("#f8d7da", "#dc3545", "✗"),
        "info" | _ => ("#d1ecf1", "#17a2b8", "ℹ"),
    };

    let mut children = Vec::new();

    // Create header with optional icon
    if show_icon {
        let icon_text = builder.new_text(
            format!("{}_showicon", id),
            icon,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: border_color.to_string(),
                line_width: 50,
                line_spacing: 0.0,
            },
        );

        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#333".to_string(),
                line_width: (width - 50.0) as usize,
                line_spacing: 0.0,
            },
        );

        let header = builder.new_hstack(
            format!("{}_header", id),
            vec![icon_text, title_text],
            VerticalAlignment::Center,
        );
        children.push(header);
    } else {
        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#333".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add message
    let message_text = builder.new_text(
        format!("{}_addmsg", id),
        &message,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666".to_string(),
            line_width: width as usize,
            line_spacing: 2.0,
        },
    );
    children.push(message_text);

    // Create vertical layout
    let content = builder.new_vstack(
        format!("{}_contentstack", id),
        children,
        HorizontalAlignment::Left,
    );

    // Wrap in styled box
    let alert_box = builder.new_box(
        id,
        content,
        BoxOptions {
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            padding: 16.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Content, // Auto height based on content
        },
    );

    println!("✅ Alert '{}' ({}) created successfully", title, alert_type);
    Ok(alert_box)
}

/// Custom Component 3: Progress Bar
/// Creates a progress bar with background and fill
fn create_progress_bar_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("📊 Creating progress bar component with attrs: {:?}", attrs);

    let width = get_float_attr(attrs, "width", 200.0);
    let height = get_float_attr(attrs, "height", 20.0);
    let progress = get_float_attr(attrs, "progress", 0.5).min(1.0).max(0.0);
    let bg_color = get_string_attr(attrs, "bg_color", "lightgray");
    let fill_color = get_string_attr(attrs, "fill_color", "blue");
    let show_text = get_bool_attr(attrs, "show_text", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        // Generate a unique ID if not provided
         id = format!("progress_bar_{}", uuid::Uuid::new_v4());
    }

    // Create background bar
    let bg_rect = builder.new_rectangle(
        format!("bg_{}", id),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(height),
            fill_color: Fill::Color(bg_color),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            border_radius: height / 2.0,
        },
    );

    // Create progress fill
    let fill_width = width * progress;
    let fill_rect = builder.new_rectangle(
        format!("fill_{}", id),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(fill_width),
            height_behavior: SizeBehavior::Fixed(height),
            fill_color: Fill::Color(fill_color),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            border_radius: height / 2.0,
        },
    );

    let mut elements = vec![(bg_rect, (0.0, 0.0)), (fill_rect, (0.0, 0.0))];

    // Add percentage text if requested
    if show_text {
        let percentage = (progress * 100.0) as i32;
        let text_node = builder.new_text(
            format!("text_{}", id),
            &format!("{}%", percentage),
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: height * 0.7,
                text_color: "black".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        // Center the text roughly
        let text_x = (width - 30.0) / 2.0; // Rough centering
        let text_y = height * 0.15;
        elements.push((text_node, (text_x, text_y)));
    }

    let progress_bar = builder.new_free_container(id.to_string(), elements);

    println!(
        "✅ Progress bar ({}%) created successfully",
        (progress * 100.0) as i32
    );
    Ok(progress_bar)
}

/// Custom Component 4: Button
/// Creates a clickable button with text
fn create_button_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("🔘 Creating button component with attrs: {:?}", attrs);

    let text = get_string_attr(attrs, "text", "Button");
    let variant = get_string_attr(attrs, "variant", "primary");
    let size = get_string_attr(attrs, "size", "medium");
    let disabled = get_bool_attr(attrs, "disabled", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("button_{}", uuid::Uuid::new_v4());
    }

    // Define button styles based on variant
    let (bg_color, text_color, border_color) = if disabled {
        ("#cccccc", "#666666", "#999999")
    } else {
        match variant.as_str() {
            "primary" => ("#007bff", "white", "#0056b3"),
            "secondary" => ("#6c757d", "white", "#545b62"),
            "success" => ("#28a745", "white", "#1e7e34"),
            "danger" => ("#dc3545", "white", "#bd2130"),
            "warning" => ("#ffc107", "#212529", "#d39e00"),
            _ => ("#007bff", "white", "#0056b3"),
        }
    };

    // Define size-based properties
    let (font_size, padding_x, padding_y) = match size.as_str() {
        "small" => (12.0, 12.0, 6.0),
        "large" => (18.0, 24.0, 12.0),
        _ => (14.0, 16.0, 8.0), // medium
    };

    // Create button text
    let button_text = builder.new_text(
        format!("{}-{}", id, text),
        &text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size,
            text_color: text_color.to_string(),
            line_width: 200,
            line_spacing: 0.0,
        },
    );

    // Wrap in styled box
    let button = builder.new_box(
        format!("button_{}", id),
        button_text,
        BoxOptions {
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            padding: f32::max(padding_x, padding_y), // Use max for uniform padding
            border_radius: 4.0,
            width_behavior: SizeBehavior::Content, // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
        },
    );

    println!(
        "✅ Button '{}' ({}, {}) created successfully",
        text, variant, size
    );
    Ok(button)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 Custom Component Demo Starting...\n");

    // Create diagram builder and set text measurement function
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all our custom components
    println!("📝 Registering custom components...");
    builder.register_custom_component("badge", create_badge_component);
    builder.register_custom_component("alert", create_alert_component);
    builder.register_custom_component("progress_bar", create_progress_bar_component);
    builder.register_custom_component("button", create_button_component);
    println!("✅ All custom components registered!\n");

    // Demo 1: Direct usage with Rust API
    println!("=== Demo 1: Direct Rust API Usage ===");

    // Create components directly
    let badge_attrs = json!({
        "text": "NEW",
        "background": "red",
        "color": "white",
        "font_size": 14.0,
        "padding": 10.0
    })
    .as_object()
    .unwrap()
    .clone();

    let _badge = builder.create_custom_component("badge", &badge_attrs)?;

    let alert_attrs = json!({
        "type": "success",
        "title": "Success!",
        "message": "Your custom component system is working perfectly!",
        "width": 400.0,
        "show_icon": true
    })
    .as_object()
    .unwrap()
    .clone();

    let _alert = builder.create_custom_component("alert", &alert_attrs)?;

    println!("✅ Direct API usage successful!\n");

    // Demo 2: JSON Lines usage
    println!("=== Demo 2: JSON Lines Usage ===");

    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","demo_section","buttons_section","progress_section","alerts_section"],"h_align":"center"}
{"id":"title","type":"text","content":"🎨 Custom Components Showcase","font_size":25,"color":"darkblue"}
{"id":"demo_section","type":"hstack","children":["badge1","badge2","badge3"],"v_align":"center"}
{"id":"badge1","type":"badge","text":"NEW","background":"#ff4444","color":"white","font_size":12,"padding":8}
{"id":"badge2","type":"badge","text":"SALE","background":"#44ff44","color":"black","font_size":12,"padding":8}
{"id":"badge3","type":"badge","text":"HOT","background":"#ff8800","color":"white","font_size":12,"padding":8}
{"id":"buttons_section","type":"hstack","children":["btn1","btn2","btn3","btn4"],"v_align":"center"}
{"id":"btn1","type":"button","text":"Primary","variant":"primary","size":"medium"}
{"id":"btn2","type":"button","text":"Success","variant":"success","size":"medium"}
{"id":"btn3","type":"button","text":"Warning","variant":"warning","size":"medium"}
{"id":"btn4","type":"button","text":"Disabled","variant":"secondary","size":"medium","disabled":true}
{"id":"progress_section","type":"vstack","children":["progress1","progress2","progress3"],"h_align":"center"}
{"id":"progress1","type":"progress_bar","width":300,"height":20,"progress":0.25,"fill_color":"#ff4444","show_text":true}
{"id":"progress2","type":"progress_bar","width":300,"height":20,"progress":0.65,"fill_color":"#44ff44","show_text":true}
{"id":"progress3","type":"progress_bar","width":300,"height":20,"progress":0.90,"fill_color":"#4444ff","show_text":true}
{"id":"alerts_section","type":"vstack","children":["alert1","alert2","alert3","alert4"],"h_align":"left"}
{"id":"alert1","type":"alert","alert-type":"success","title":"Success Alert","message":"Everything is working perfectly! Your custom components are rendering correctly.","width":500,"show_icon":true}
{"id":"alert2","type":"alert","alert-type":"warning","title":"Warning Alert","message":"This is a warning message to demonstrate the warning alert style.","width":500,"show_icon":true}
{"id":"alert3","type":"alert","alert-type":"error","title":"Error Alert","message":"This shows how error messages would appear in your application.","width":500,"show_icon":true}
{"id":"alert4","type":"alert","alert-type":"info","title":"Info Alert","message":"Here's some informational content using the info alert component.","width":500,"show_icon":true}
"##;

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components with the parse builder
    parse_builder.register_custom_component("badge", create_badge_component);
    parse_builder.register_custom_component("alert", create_alert_component);
    parse_builder.register_custom_component("progress_bar", create_progress_bar_component);
    parse_builder.register_custom_component("button", create_button_component);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    println!("✅ JSON Lines parsing successful!");

    // Calculate layout
    println!("📐 Calculating layout...");
    layout::layout_tree_node(&mut parse_builder, &diagram);
    println!("✅ Layout calculation complete!");

    // Demo 3: Render to SVG
    println!("\n=== Demo 3: SVG Rendering ===");

    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("custom-components-showcase.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("✅ SVG rendered successfully!");
    println!("📄 File saved to: {}", svg_path.to_str().unwrap());

    // Demo 4: Statistics
    println!("\n=== Demo 4: Component Statistics ===");
    let registered_types = parse_builder.get_custom_component_types();
    println!("📊 Registered custom components: {:?}", registered_types);
    println!("🔢 Total custom components: {}", registered_types.len());

    // Count components in the diagram
    fn count_custom_components(
        node: &diagram_builder::DiagramTreeNode,
        types: &[&String],
    ) -> usize {
        let mut count = 0;
        if types
            .iter()
            .any(|t| t.as_str() == format!("{:?}", node.entity_type))
        {
            count += 1;
        }
        for child in &node.children {
            count += count_custom_components(child, types);
        }
        count
    }

    let custom_count = count_custom_components(&diagram, &registered_types);
    println!("🎯 Custom components in diagram: {}", custom_count);

    println!("\n🎉 Custom Component Demo Complete!");
    println!("💡 Check the generated SVG file to see your custom components in action!");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);
        builder.register_custom_component("alert", create_alert_component);
        builder.register_custom_component("progress_bar", create_progress_bar_component);
        builder.register_custom_component("button", create_button_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 4);
        assert!(builder.has_custom_component("badge"));
        assert!(builder.has_custom_component("alert"));
        assert!(builder.has_custom_component("progress_bar"));
        assert!(builder.has_custom_component("button"));
    }

    #[test]
    fn test_jsonl_with_custom_components() {
        let input = r#"
{"id":"root","type":"badge","text":"Test Badge","background":"red"}
"#;

        let mut parser = parser::JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let result = parser.build(&root_id, &mut builder);
        assert!(result.is_ok());
    }
}

===/src/bin/visual_experiments.rs===
// src/bin/visual_experiments.rs
// Demo program that generates SVGs for visual experiments using JSONL format

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🎨 Generando Experimentos Visuales...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("visual_experiments");
    std::fs::create_dir_all(&output_dir)?;

    // 🎯 Experimentos de Animación/Progresión
    println!("=== 🎯 Experimentos de Animación/Progresión ===");
    
    // 1. Construcción de Edificio
    generate_building_construction(&output_dir)?;
    
    // 2. Crecimiento de Árbol
    generate_tree_growth(&output_dir)?;

    // 📊 Visualización de Datos en Tiempo Real
    println!("\n=== 📊 Visualización de Datos ===");
    
    // 3. Dashboard Financiero
    generate_financial_dashboard(&output_dir)?;
    
    // 4. Monitor de Sistema
    generate_system_monitor(&output_dir)?;

    // 🎮 Interfaces Interactivas
    println!("\n=== 🎮 Interfaces Interactivas ===");
    
    // 5. Panel de Control Espacial
    generate_space_control_panel(&output_dir)?;
    
    // 6. Simulador de Tráfico
    generate_traffic_simulator(&output_dir)?;

    // 🧬 Simulaciones Científicas
    println!("\n=== 🧬 Simulaciones Científicas ===");
    
    // 7. Modelo Molecular
    generate_molecular_model(&output_dir)?;
    
    // 8. Sistema Solar
    generate_solar_system(&output_dir)?;

    // 🎨 Arte Generativo
    println!("\n=== 🎨 Arte Generativo ===");
    
    // 9. Patrón Fractal Simple
    generate_fractal_pattern(&output_dir)?;
    
    // 10. Mandala Geométrico
    generate_geometric_mandala(&output_dir)?;

    println!("\n✅ Todos los experimentos generados exitosamente!");
    println!("📁 Archivos guardados en: {}", output_dir.display());

    Ok(())
}

// 1. Construcción de Edificio
fn generate_building_construction(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":400,"children":["ground","floor1","floor2","floor3","roof","window1","window2"]}
{"id":"ground","type":"rect","width":400,"height":20,"background":"brown","x":0,"y":380}
{"id":"floor1","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":320}
{"id":"floor2","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":260}
{"id":"floor3","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":200}
{"id":"roof","type":"polyline","points":[[100,200],[150,150],[250,150],[300,200]],"stroke_color":"red","x":0,"y":0}
{"id":"window1","type":"rect","width":20,"height":30,"background":"lightblue","x":120,"y":340}
{"id":"window2","type":"rect","width":20,"height":30,"background":"lightblue","x":160,"y":340}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_building_construction.svg"), "Construcción de Edificio")
}

// 2. Crecimiento de Árbol

fn generate_tree_growth(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
   // 2. Crecimiento de Árbol
 let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":300,"children":["trunk","branch1","branch2","leaf1","leaf2","apple1"]}
{"id":"trunk","type":"rect","width":20,"height":100,"background":"brown","x":190,"y":150}
{"id":"branch1","type":"line","start_x":200,"start_y":150,"end_x":170,"end_y":120,"stroke_color":"brown","stroke_width":3,"x":0,"y":0}
{"id":"branch2","type":"line","start_x":200,"start_y":150,"end_x":230,"end_y":120,"stroke_color":"brown","stroke_width":3,"x":0,"y":0}
{"id":"leaf1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"green","x":155,"y":105}
{"id":"leaf2","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"green","x":215,"y":105}
{"id":"apple1","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red","x":160,"y":125}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_tree_growth.svg"), "Crecimiento de Árbol")
}

// 3. Dashboard Financiero
fn generate_financial_dashboard(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["header","metrics","chart_area"],"h_align":"center"}
{"id":"header","type":"text","content":"📈 Financial Dashboard","font_size":24,"color":"darkblue"}
{"id":"metrics","type":"hstack","children":["revenue","profit","users"],"v_align":"center"}
{"id":"revenue","type":"vstack","children":["rev_icon","rev_value","rev_change"],"h_align":"center"}
{"id":"rev_icon","type":"text","content":"💰","font_size":20}
{"id":"rev_value","type":"text","content":"$125,430","font_size":18,"color":"#333"}
{"id":"rev_change","type":"text","content":"↗ +12.5%","font_size":12,"color":"green"}
{"id":"profit","type":"vstack","children":["prof_icon","prof_value","prof_change"],"h_align":"center"}
{"id":"prof_icon","type":"text","content":"📊","font_size":20}
{"id":"prof_value","type":"text","content":"$45,200","font_size":18,"color":"#333"}
{"id":"prof_change","type":"text","content":"↗ +8.2%","font_size":12,"color":"green"}
{"id":"users","type":"vstack","children":["user_icon","user_value","user_change"],"h_align":"center"}
{"id":"user_icon","type":"text","content":"👥","font_size":20}
{"id":"user_value","type":"text","content":"8,945","font_size":18,"color":"#333"}
{"id":"user_change","type":"text","content":"↘ -2.1%","font_size":12,"color":"red"}
{"id":"chart_area","type":"free_container","width":250,"height":120,"children":["bar1","bar2","bar3"]}
{"id":"bar1","type":"rect","width":30,"height":50,"background":"blue","x":50,"y":50}
{"id":"bar2","type":"rect","width":30,"height":75,"background":"green","x":100,"y":25}
{"id":"bar3","type":"rect","width":30,"height":40,"background":"red","x":150,"y":60}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_financial_dashboard.svg"), "Dashboard Financiero")
}

// 4. Monitor de Sistema
fn generate_system_monitor(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","cpu_section","memory_section","network_section"],"h_align":"left"}
{"id":"title","type":"text","content":"🖥️ System Monitor","font_size":20,"color":"#333"}
{"id":"cpu_section","type":"hstack","children":["cpu_label","cpu_container"],"v_align":"center"}
{"id":"cpu_label","type":"text","content":"CPU:","font_size":14}
{"id":"cpu_container","type":"free_container","width":210,"height":25,"children":["cpu_bg","cpu_fill","cpu_text"]}
{"id":"cpu_bg","type":"rect","width":200,"height":20,"background":"lightgray","x":5,"y":2}
{"id":"cpu_fill","type":"rect","width":150,"height":20,"background":"orange","x":5,"y":2}
{"id":"cpu_text","type":"text","content":"75%","font_size":12,"x":105,"y":12}
{"id":"memory_section","type":"hstack","children":["mem_label","mem_container"],"v_align":"center"}
{"id":"mem_label","type":"text","content":"Memory:","font_size":14}
{"id":"mem_container","type":"free_container","width":210,"height":25,"children":["mem_bg","mem_fill","mem_text"]}
{"id":"mem_bg","type":"rect","width":200,"height":20,"background":"lightgray","x":5,"y":2}
{"id":"mem_fill","type":"rect","width":90,"height":20,"background":"blue","x":5,"y":2}
{"id":"mem_text","type":"text","content":"45%","font_size":12,"x":105,"y":12}
{"id":"network_section","type":"hstack","children":["net_label","net_indicator"],"v_align":"center"}
{"id":"net_label","type":"text","content":"Network:","font_size":14}
{"id":"net_indicator","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"green"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_system_monitor.svg"), "Monitor de Sistema")
}

// 5. Panel de Control Espacial
fn generate_space_control_panel(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":250,"background":"black","border_color":"cyan","border_width":2,"children":["radar","blip1","blip2","status_panel"]}
{"id":"radar","type":"ellipse","cx":80,"cy":80,"rx":80,"ry":80,"fill":"darkgreen","stroke":"green","x":50,"y":50}
{"id":"blip1","type":"ellipse","cx":3,"cy":3,"rx":3,"ry":3,"fill":"red","x":120,"y":140}
{"id":"blip2","type":"ellipse","cx":3,"cy":3,"rx":3,"ry":3,"fill":"yellow","x":170,"y":160}
{"id":"status_panel","type":"vstack","children":["shields","energy","weapons"],"h_align":"left","x":250,"y":50}
{"id":"shields","type":"text","content":"🛡️ Shields: 85%","color":"cyan","font_size":12}
{"id":"energy","type":"text","content":"⚡ Energy: 92%","color":"yellow","font_size":12}
{"id":"weapons","type":"text","content":"🔫 Weapons: Online","color":"green","font_size":12}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("05_space_control_panel.svg"), "Panel de Control Espacial")
}

// 6. Simulador de Tráfico
fn generate_traffic_simulator(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":300,"background":"lightgray","children":["road_h","road_v","car1","car2","car3","traffic_light"]}
{"id":"road_h","type":"rect","width":400,"height":40,"background":"darkgray","x":0,"y":130}
{"id":"road_v","type":"rect","width":40,"height":300,"background":"darkgray","x":180,"y":0}
{"id":"car1","type":"rect","width":30,"height":15,"background":"red","x":50,"y":140}
{"id":"car2","type":"rect","width":30,"height":15,"background":"blue","x":320,"y":140}
{"id":"car3","type":"rect","width":15,"height":30,"background":"green","x":185,"y":50}
{"id":"traffic_light","type":"vstack","children":["red_light","yellow_light","green_light"],"h_align":"center","x":175,"y":110}
{"id":"red_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red"}
{"id":"yellow_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"gray"}
{"id":"green_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"gray"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("06_traffic_simulator.svg"), "Simulador de Tráfico")
}

// 7. Modelo Molecular
fn generate_molecular_model(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":300,"height":300,"children":["carbon1","hydrogen1","hydrogen2","oxygen1","bond1","bond2","bond3"]}
{"id":"carbon1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"gray","x":100,"y":100}
{"id":"hydrogen1","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"white","stroke":"black","x":150,"y":90}
{"id":"hydrogen2","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"white","stroke":"black","x":150,"y":110}
{"id":"oxygen1","type":"ellipse","cx":12,"cy":12,"rx":12,"ry":12,"fill":"red","x":200,"y":100}
{"id":"bond1","type":"line","start_x":115,"start_y":110,"end_x":150,"end_y":100,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"bond2","type":"line","start_x":115,"start_y":115,"end_x":150,"end_y":118,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"bond3","type":"line","start_x":130,"start_y":115,"end_x":200,"end_y":112,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("07_molecular_model.svg"), "Modelo Molecular")
}

// 8. Sistema Solar
fn generate_solar_system(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":500,"height":500,"background":"black","children":["sun","mercury_orbit","venus_orbit","earth_orbit","mercury","venus","earth","moon"]}
{"id":"sun","type":"ellipse","cx":25,"cy":25,"rx":25,"ry":25,"fill":"yellow","x":225,"y":225}
{"id":"mercury_orbit","type":"ellipse","cx":250,"cy":250,"rx":80,"ry":80,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"venus_orbit","type":"ellipse","cx":250,"cy":250,"rx":120,"ry":120,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"earth_orbit","type":"ellipse","cx":250,"cy":250,"rx":160,"ry":160,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"mercury","type":"ellipse","cx":4,"cy":4,"rx":4,"ry":4,"fill":"orange","x":320,"y":246}
{"id":"venus","type":"ellipse","cx":6,"cy":6,"rx":6,"ry":6,"fill":"yellow","x":360,"y":244}
{"id":"earth","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"blue","x":400,"y":242}
{"id":"moon","type":"ellipse","cx":2,"cy":2,"rx":2,"ry":2,"fill":"gray","x":415,"y":240}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("08_solar_system.svg"), "Sistema Solar")
}

// 9. Patrón Fractal Simple
fn generate_fractal_pattern(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":400,"children":["center","nw","ne","sw","se","nw_nw","nw_ne","nw_sw","nw_se"]}
{"id":"center","type":"rect","width":100,"height":100,"background":"blue","x":150,"y":150}
{"id":"nw","type":"rect","width":50,"height":50,"background":"lightblue","x":100,"y":100}
{"id":"ne","type":"rect","width":50,"height":50,"background":"lightblue","x":250,"y":100}
{"id":"sw","type":"rect","width":50,"height":50,"background":"lightblue","x":100,"y":250}
{"id":"se","type":"rect","width":50,"height":50,"background":"lightblue","x":250,"y":250}
{"id":"nw_nw","type":"rect","width":25,"height":25,"background":"cyan","x":75,"y":75}
{"id":"nw_ne","type":"rect","width":25,"height":25,"background":"cyan","x":125,"y":75}
{"id":"nw_sw","type":"rect","width":25,"height":25,"background":"cyan","x":75,"y":125}
{"id":"nw_se","type":"rect","width":25,"height":25,"background":"cyan","x":125,"y":125}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("09_fractal_pattern.svg"), "Patrón Fractal Simple")
}

// 10. Mandala Geométrico
fn generate_geometric_mandala(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":300,"height":300,"children":["center_circle","ring1_1","ring1_2","ring1_3","ring1_4","ring1_5","ring1_6"]}
{"id":"center_circle","type":"ellipse","cx":20,"cy":20,"rx":20,"ry":20,"fill":"purple","x":130,"y":130}
{"id":"ring1_1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":135,"y":80}
{"id":"ring1_2","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":185,"y":105}
{"id":"ring1_3","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":185,"y":155}
{"id":"ring1_4","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":135,"y":180}
{"id":"ring1_5","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":85,"y":155}
{"id":"ring1_6","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":85,"y":105}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("10_geometric_mandala.svg"), "Mandala Geométrico")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  📄 Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ✅ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/bin/sample_components.rs===
// src/bin/useful_components_demo.rs
// A library of practical custom components for real-world usage

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::fs::File;
use volare_engine_layout::*;

// Helper functions for attribute extraction
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Vec<String> {
    attrs
        .get(key)
        .and_then(|v| v.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default()
}

/// Card Component - A flexible container with header, body, and footer
fn create_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let content = get_string_attr(attrs, "content", "");
    let footer = get_string_attr(attrs, "footer", "");
    let width = get_float_attr(attrs, "width", 300.0);
    let padding = get_float_attr(attrs, "padding", 16.0);
    let border_radius = get_float_attr(attrs, "border_radius", 8.0);
    let shadow = get_bool_attr(attrs, "shadow", true);
    let variant = get_string_attr(attrs, "variant", "default");

    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        id = uuid::Uuid::new_v4().to_string()
    }

    // Define card styles based on variant
    let (bg_color, border_color) = match variant.as_str() {
        "primary" => ("#ffffff", "#007bff"),
        "success" => ("#f8fff8", "#28a745"),
        "warning" => ("#fffdf0", "#ffc107"),
        "danger" => ("#fff8f8", "#dc3545"),
        _ => ("#ffffff", "#e0e0e0"),
    };

    let mut children = Vec::new();

    // Add title if provided
    if !title.is_empty() {
        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: "#333333".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_text = builder.new_text(
            format!("{}_subtitle", id),
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#666666".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_text);
    }

    // Add content if provided
    if !content.is_empty() {
        let content_text = builder.new_text(
            format!("{}_content", id),
            &content,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#444444".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 4.0,
            },
        );
        children.push(content_text);
    }

    // Add footer if provided
    if !footer.is_empty() {
        let footer_text = builder.new_text(
            format!("{}_footer", id),
            &footer,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#888888".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(footer_text);
    }

    // Create layout
    let content_stack = builder.new_vstack(
        format!("{}_contentstack", id),
        children, HorizontalAlignment::Left);

    // Apply shadow effect by creating multiple boxes
    if shadow {
        // Shadow box (slightly offset)
        let shadow_box = builder.new_box(
            format!("{}_shadowbox", id),
            content_stack,
            BoxOptions {
                fill_color: Fill::Color("#00000010".to_string()),
                stroke_color: "transparent".to_string(),
                stroke_width: 0.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );

        // Main card box
        let main_content = builder.new_rectangle(
            format!("{}_maincontent", id),
            RectOptions {
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            border_radius,
        });

        // Use free container to overlay them
        let card = builder.new_free_container(
            id, 
            vec![
            (shadow_box, (2.0, 2.0)),   // Shadow slightly offset
            (main_content, (0.0, 0.0)), // Main card on top
        ]);
        Ok(card)
    } else {
        let card = builder.new_box(
            id,
            content_stack,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: 1.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );
        Ok(card)
    }
}

/// List Component - Creates a styled list with bullets or numbers
fn create_list_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let list_type = get_string_attr(attrs, "list_type", "bullet"); // bullet, number, check
    let spacing = get_float_attr(attrs, "spacing", 4.0);
    let width = get_float_attr(attrs, "width", 300.0);
    let font_size = get_float_attr(attrs, "font_size", 14.0);
    let mut id = get_string_attr(attrs, "id", "");

    if id.is_empty(){
        id = uuid::Uuid::new_v4().to_string()
    }

    if items.is_empty() {
        return Err("List component requires 'items' array".to_string());
    }

    let mut list_children = Vec::new();

    for (index, item) in items.iter().enumerate() {
        // Create bullet/number
        let marker = match list_type.as_str() {
            "number" => format!("{}.", index + 1),
            "check" => "✓".to_string(),
            "arrow" => "→".to_string(),
            _ => "•".to_string(), // bullet
        };

        let marker_text = builder.new_text(
            format!("{}-marker", id),
            &marker,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#666666".to_string(),
                line_width: 30,
                line_spacing: 0.0,
            },
        );

        let item_text = builder.new_text(
            format!("{}_item_text", id),
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#333333".to_string(),
                line_width: (width - 40.0) as usize,
                line_spacing: 0.0,
            },
        );

        let list_item = builder.new_hstack(
            format!("list_items_{}", id),
            vec![marker_text, item_text], VerticalAlignment::Top);
        list_children.push(list_item);
    }

    let list = builder.new_vstack(
        format!("list_items_{}", id),
        list_children, HorizontalAlignment::Left);
    Ok(list)
}

/// Form Field Component - Creates labeled input-like elements
fn create_form_field_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let label = get_string_attr(attrs, "label", "Field");
    let placeholder = get_string_attr(attrs, "placeholder", "Enter value...");
    let field_type = get_string_attr(attrs, "field_type", "text"); // text, email, password, textarea
    let required = get_bool_attr(attrs, "required", false);
    let width = get_float_attr(attrs, "width", 250.0);
    let error = get_string_attr(attrs, "error", "");
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
         id = format!("form_field_{}", uuid::Uuid::new_v4());
    }

    let mut children = Vec::new();

    // Create label
    let label_text = if required {
        format!("{} *", label)
    } else {
        label
    };

    let label_node = builder.new_text(
        format!("label_{}", id),
        &label_text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: if required { "#333333" } else { "#666666" }.to_string(),
            line_width: width as usize,
            line_spacing: 0.0,
        },
    );
    children.push(label_node);

    // Create input field representation
    let field_height = match field_type.as_str() {
        "textarea" => 60.0,
        _ => 36.0,
    };

    let placeholder_text = builder.new_text(
        format!("placeholder_{}", id),
        &placeholder,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#999999".to_string(),
            line_width: (width - 24.0) as usize,
            line_spacing: 0.0,
        },
    );

    let input_field = builder.new_box(
        format!("input_field_{}", id),
        placeholder_text,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: if !error.is_empty() {
                "#dc3545"
            } else {
                "#cccccc"
            }
            .to_string(),
            stroke_width: 1.0,
            padding: 12.0,
            border_radius: 4.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(field_height),
        },
    );
    children.push(input_field);

    // Add error message if present
    if !error.is_empty() {
        let error_text = builder.new_text(
            format!("error_{}", id),
            &error,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#dc3545".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(error_text);
    }

    let form_field = builder.new_vstack(id.to_string(), children, HorizontalAlignment::Left);
    Ok(form_field)
}

/// Stats Card Component - Displays key metrics with icons
fn create_stats_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Metric");
    let value = get_string_attr(attrs, "value", "0");
    let change = get_string_attr(attrs, "change", "");
    let icon = get_string_attr(attrs, "icon", "📊");
    let trend = get_string_attr(attrs, "trend", "neutral"); // up, down, neutral
    let color = get_string_attr(attrs, "color", "#007bff");
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("stats_card_{}", uuid::Uuid::new_v4());
    }
    // Determine trend color and symbol
    let (trend_color, trend_symbol) = match trend.as_str() {
        "up" => ("#28a745", "↗"),
        "down" => ("#dc3545", "↘"),
        _ => ("#6c757d", "→"),
    };

    // Create icon
    let icon_text = builder.new_text(
        format!("icon_{}", id),
        &icon,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            text_color: color,
            line_width: 50,
            line_spacing: 0.0,
        },
    );

    // Create value and title section
    let value_text = builder.new_text(
        format!("value_{}", id),
        &value,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 28.0,
            text_color: "#333333".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let title_text = builder.new_text(
        format!("title_{}", id),
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666666".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let mut right_children = vec![value_text, title_text];

    // Add change indicator if provided
    if !change.is_empty() {
        let change_text = format!("{} {}", trend_symbol, change);
        let change_node = builder.new_text(
            "change_text".to_string(),
            &change_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: trend_color.to_string(),
                line_width: 150,
                line_spacing: 0.0,
            },
        );
        right_children.push(change_node);
    }

    let right_section = builder.new_vstack("right_section".to_string(), right_children, HorizontalAlignment::Left);
    let content = builder.new_hstack("stats_card_content".to_string(), vec![icon_text, right_section], VerticalAlignment::Center);

    let stats_card = builder.new_box(
        id,
        content,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: "#e0e0e0".to_string(),
            stroke_width: 1.0,
            padding: 20.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(300.0),
            height_behavior: SizeBehavior::Content,
        },
    );

    Ok(stats_card)
}

/// Navigation Menu Component - Creates a horizontal or vertical menu
fn create_nav_menu_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let orientation = get_string_attr(attrs, "orientation", "horizontal"); // horizontal, vertical
    let active_item = get_string_attr(attrs, "active_item", "");
    let style = get_string_attr(attrs, "style", "default"); // default, pills, tabs
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("nav_menu_{}", uuid::Uuid::new_v4());
    }

    if items.is_empty() {
        return Err("Navigation menu requires 'items' array".to_string());
    }

    let mut nav_children = Vec::new();

    for item in items.iter() {
        let is_active = item == &active_item;

        // Style based on state and style type
        let (bg_color, text_color, border_color) = match (is_active, style.as_str()) {
            (true, "pills") => ("#007bff", "#ffffff", "#007bff"),
            (false, "pills") => ("transparent", "#007bff", "transparent"),
            (true, "tabs") => ("#ffffff", "#007bff", "#007bff"),
            (false, "tabs") => ("transparent", "#666666", "#e0e0e0"),
            (true, _) => ("transparent", "#007bff", "transparent"),
            (false, _) => ("transparent", "#666666", "transparent"),
        };

        let nav_text = builder.new_text(
            format!("nav_text_{}_{}", item, id),
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: text_color.to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );

        let nav_item = builder.new_box(
            format!("nav_item_{}_{}", item, id),
            nav_text,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: if style == "tabs" { 1.0 } else { 0.0 },
                padding: 12.0,
                border_radius: if style == "pills" { 20.0 } else { 4.0 },
                width_behavior: SizeBehavior::Content,
                height_behavior: SizeBehavior::Content,
            },
        );

        nav_children.push(nav_item);
    }

    let nav_menu = match orientation.as_str() {
        "vertical" => builder.new_vstack(format!("nav_menu_{}_{}", id, orientation), nav_children, HorizontalAlignment::Left),
        _ => builder.new_hstack(format!("nav_menu_{}_{}", id, orientation), nav_children, VerticalAlignment::Center),
    };

    Ok(nav_menu)
}

/// Header Component - Creates page headers with optional breadcrumbs
fn create_header_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Page Title");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let breadcrumbs = get_array_attr(attrs, "breadcrumbs");
    let show_back = get_bool_attr(attrs, "show_back", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("header_{}", uuid::Uuid::new_v4());
    }


    let mut children = Vec::new();

    // Add breadcrumbs if provided
    if !breadcrumbs.is_empty() {
        let breadcrumb_text = breadcrumbs.join(" > ");
        let breadcrumb_node = builder.new_text(
            format!("breadcrumb_{}",id),
            &breadcrumb_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(breadcrumb_node);
    }

    // Add back button if requested
    if show_back {
        let back_text = builder.new_text(
            "back_button".to_string(),
            "← Back",
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#007bff".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        children.push(back_text);
    }

    // Add main title
    let title_node = builder.new_text(
        format!("title_{}", id),
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 32.0,
            text_color: "#333333".to_string(),
            line_width: 600,
            line_spacing: 0.0,
        },
    );
    children.push(title_node);

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_node = builder.new_text(
            format!("subtitle_{}", id),
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_node);
    }

    let header = builder.new_vstack("header".to_string(),children, HorizontalAlignment::Left);
    Ok(header)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 Useful Components Demo Starting...\n");

    // Create diagram builder and register components
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all useful components
    println!("📝 Registering useful components...");
    builder.register_custom_component("card", create_card_component);
    builder.register_custom_component("list", create_list_component);
    builder.register_custom_component("form_field", create_form_field_component);
    builder.register_custom_component("stats_card", create_stats_card_component);
    builder.register_custom_component("nav_menu", create_nav_menu_component);
    builder.register_custom_component("header", create_header_component);
    println!("✅ All useful components registered!\n");

    // The JSONL content - Real-world dashboard example
    let jsonl_input = r##"{"id":"root","type":"vstack","children":["main_header","nav","dashboard_content"],"h_align":"center"}
{"id":"main_header","type":"header","title":"Analytics Dashboard","subtitle":"Monitor your key metrics and performance indicators","breadcrumbs":["Home","Analytics","Dashboard"]}
{"id":"nav","type":"nav_menu","items":["Overview","Analytics","Reports","Settings"],"active_item":"Analytics","style":"tabs","orientation":"horizontal"}
{"id":"dashboard_content","type":"vstack","children":["stats_row","charts_row","recent_activity"],"h_align":"center"}
{"id":"stats_row","type":"hstack","children":["stats1","stats2","stats3","stats4"],"v_align":"top"}
{"id":"stats1","type":"stats_card","title":"Total Users","value":"12,345","change":"+12.5%","trend":"up","icon":"👥","color":"#007bff"}
{"id":"stats2","type":"stats_card","title":"Revenue","value":"$89,432","change":"+8.2%","trend":"up","icon":"💰","color":"#28a745"}
{"id":"stats3","type":"stats_card","title":"Orders","value":"1,234","change":"-2.1%","trend":"down","icon":"📦","color":"#ffc107"}
{"id":"stats4","type":"stats_card","title":"Conversion","value":"3.24%","change":"+0.8%","trend":"up","icon":"📈","color":"#17a2b8"}
{"id":"charts_row","type":"hstack","children":["performance_card","recent_orders_card"],"v_align":"top"}
{"id":"performance_card","type":"card","title":"Performance Metrics","content":"Your application performance has improved by 23% this month. Server response times are optimal and user engagement is at an all-time high.","footer":"Last updated: 2 minutes ago","width":400,"variant":"primary","shadow":true}
{"id":"recent_orders_card","type":"card","title":"Recent Orders","width":400,"variant":"default","shadow":true,"children":["orders_list"]}
{"id":"orders_list","type":"list","items":["Order #1234 - $299.99 - Processing","Order #1235 - $156.78 - Shipped","Order #1236 - $89.50 - Delivered","Order #1237 - $445.20 - Processing"],"list_type":"number","spacing":6,"width":350}
{"id":"recent_activity","type":"vstack","children":["activity_header","activity_content"],"h_align":"left"}
{"id":"activity_header","type":"text","content":"Recent Activity","font_size":20,"color":"#333333"}
{"id":"activity_content","type":"hstack","children":["activity_list","user_form"],"v_align":"top"}
{"id":"activity_list","type":"list","items":["User john.doe logged in","New order received (#1238)","Payment processed for order #1235","User jane.smith updated profile","System backup completed","New user registration: mike.wilson"],"list_type":"arrow","width":400,"font_size":13}
{"id":"user_form","type":"vstack","children":["form_title","name_field","email_field","message_field","submit_section"],"h_align":"left"}
{"id":"form_title","type":"text","content":"Quick Contact","font_size":18,"color":"#333333"}
{"id":"name_field","type":"form_field","label":"Full Name","placeholder":"Enter your full name","required":true,"width":300}
{"id":"email_field","type":"form_field","label":"Email Address","placeholder":"your.email@company.com","field_type":"email","required":true,"width":300}
{"id":"message_field","type":"form_field","label":"Message","placeholder":"Type your message here...","field_type":"textarea","width":300}
{"id":"submit_section","type":"card","content":"Form ready to submit","footer":"All fields are validated","width":300,"variant":"success"}"##;

    // Parse and build the diagram
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components
    parse_builder.register_custom_component("card", create_card_component);
    parse_builder.register_custom_component("list", create_list_component);
    parse_builder.register_custom_component("form_field", create_form_field_component);
    parse_builder.register_custom_component("stats_card", create_stats_card_component);
    parse_builder.register_custom_component("nav_menu", create_nav_menu_component);
    parse_builder.register_custom_component("header", create_header_component);

    // Build and layout
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("useful-components-dashboard.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("✅ Dashboard rendered successfully!");
    println!("📄 File saved to: {}", svg_path.to_str().unwrap());
    println!("\n🎉 Useful Components Demo Complete!");

    Ok(())
}

===/src/lib.rs===
pub mod measure_text; 

===/src/text_renderer_comparison.rs===
// Text Renderer Comparison Test
// This file demonstrates the differences in text positioning and spacing
// between the SVG and PNG renderers

use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{
    renderer_base::Renderer,
    BoxOptions,
    TextOptions,
    Fill,
    DiagramBuilder,
    layout::layout_tree_node,
};

// Import measurement function
use crate::measure_text::measure_text;
use std::fs::File;

pub fn run_comparison_test() -> Result<(), Box<dyn std::error::Error>> {
    // Create session
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(measure_text);

    // Create options for the test
    let title_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 18.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let regular_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 14.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let small_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 12.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let box_options = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 0.0,
    };

    let box_options_no_padding = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 0.0,
        border_radius: 0.0,
    };

    // Create title
    let title = session.new_text(
        "Text Rendering Comparison",
        title_text_options,
    );

    // Create a simple single-line text
    let single_line_text = session.new_text(
        "This is a single line of text.",
        regular_text_options.clone(),
    );
    
    // Create a simple single-line text with a box around it
    let single_line_text_boxed = session.new_text(
        "This is a single line with a box.",
        regular_text_options.clone(),
    );
    let single_line_box = session.new_box(single_line_text_boxed, box_options.clone());

    // Create a simple single-line text with a box around it (no padding)
    let single_line_text_boxed_no_padding = session.new_text(
        "Single line box without padding.",
        regular_text_options.clone(),
    );
    let single_line_box_no_padding = session.new_box(single_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Create a multi-line text example
    let multi_line_text = session.new_text(
        "This is a multi-line text example.\nSecond line of text.\nThird line for testing purposes.",
        regular_text_options.clone(),
    );

    // Create a multi-line text with a box around it
    let multi_line_text_boxed = session.new_text(
        "This is a multi-line text with a box.\nSecond line of text.\nThird line demonstrates the gap.",
        regular_text_options.clone(),
    );
    let multi_line_box = session.new_box(multi_line_text_boxed, box_options.clone());

    // Create a multi-line text with a box (no padding) around it
    let multi_line_text_boxed_no_padding = session.new_text(
        "This is a multi-line text box no padding.\nSecond line without padding.\nThird line gap is more pronounced.",
        regular_text_options.clone(),
    );
    let multi_line_box_no_padding = session.new_box(multi_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Text with linebreaking that causes varying line widths
    let varying_width_text = session.new_text(
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eget ligula eu lectus lobortis condimentum. Aliquam nonummy auctor massa.",
        small_text_options.clone(),
    );
    let varying_width_box = session.new_box(varying_width_text, box_options.clone());

    // Create explanation text
    let explanation = session.new_text(
        "The images above demonstrate differences in text positioning between SVG and PNG renderers. Key issues to observe:\n\n1. Vertical spacing between lines in multi-line text\n2. Text centering in boxes with and without padding\n3. Vertical alignment issues with text baseline",
        small_text_options,
    );

    // Arrange all elements in a vertical stack
    let elements = vec![
        title,
        single_line_text,
        single_line_box,
        single_line_box_no_padding,
        multi_line_text,
        multi_line_box,
        multi_line_box_no_padding,
        varying_width_box,
        explanation,
    ];

    let stack = session.ne(elements);

    // Calculate layout
    layout_tree_node(&mut session, &stack);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("text-comparison-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&session, &stack, &mut svg_file)?;
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render to PNG
    let mut png_path = temp_dir.clone();
    png_path.push("text-comparison-test.png");
    let png_renderer = PNGRenderer {};
    let mut png_file = File::create(&png_path)?;
    png_renderer.render(&session, &stack, &mut png_file)?;
    println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}
===/src/main.rs===
// Create an SVG file with all supported elements

pub mod measure_text;

//import svg_renderer
use image_renderer::PNGRenderer;
use resvg::tiny_skia::Rect;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{RectOptions, SizeBehavior};
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, LineOptions};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    Fill, TableOptions, TextOptions,
};
//import io modules to write to file
use measure_text::{
    measure_text_svg_character_advance,
}; // Use the ultra-tight measurement for text

use std::fs::File;



fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 0.0,
    };
    session.set_measure_text_fn(measure_text_svg_character_advance);

    //Create a polyline for a star
    let mut points = Vec::new();
    // Outer vertex
    points.push((10.0, 0.0));
    // Inner vertex
    points.push((16.0, 16.0));
    // Outer vertex
    points.push((0.0, 6.0));
    // Inner vertex
    points.push((20.0, 6.0));
    // Outer vertex
    points.push((4.0, 16.0));
    // Closing the shape by returning to the first point
    points.push((10.0, 0.0));

    let polyline = session.new_polyline(
        "star".to_string(),
        points,
        LineOptions {
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //Create horizontal stack with 2 rects and one text, set vertical align to center 
    let mut rectOpts = RectOptions::default();
    rectOpts.width_behavior =  SizeBehavior::Fixed(150.0);
    rectOpts.height_behavior = SizeBehavior::Fixed(150.0);
    rectOpts.stroke_color = "black".to_string();
    rectOpts.stroke_width = 1.0;
    let rect = session.new_rectangle("r1".to_string(), rectOpts.clone());
    let rect2 = session.new_rectangle("r2".to_string(), rectOpts.clone());


    let label = session.new_text(
        "label".to_string(),
        "Center",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            line_width: 60,
            text_color: "#333333".to_string(),
            line_spacing: 0.0,
        },
    );

    let hstack_centered = session.new_hstack(
        "hstack_centered".to_string(),
        vec![rect, label, rect2],
        volare_engine_layout::VerticalAlignment::Center
    );


    

    // Create a more visible polyline - hexagon
    let mut hex_points = Vec::new();
    let hex_size = 50.0;
    for i in 0..6 {
        let angle = (i as f32) * std::f32::consts::PI / 3.0;
        let x = hex_size * angle.cos() + hex_size;
        let y = hex_size * angle.sin() + hex_size;
        hex_points.push((x, y));
    }
    // Close the shape
    hex_points.push(hex_points[0]);

    let hexagon = session.new_polyline(
        "hexagon".to_string(),
        hex_points,
        LineOptions {
            stroke_color: "blue".to_string(),
            stroke_width: 2.0,
        },
    );

    //Create a table with 10 ellipses
    let mut table_items_ellipses: Vec<DiagramTreeNode> = Vec::new();
    for i in 0..10 {
        let ellipse = session.new_elipse(
            format!("table_ellipse_{}", i).to_string(),
            (0.0, 0.0),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        table_items_ellipses.push(ellipse);
    }
    let tableEllipses = session.new_table("table_ellipses".to_string(), table_items_ellipses, 5, TableOptions::default());

    //Create a list of 10 texts
    let mut table_items = Vec::new();
    table_items.push(hstack_centered);
    table_items.push(tableEllipses);
    table_items.push(polyline);
    table_items.push(hexagon);
    for i in 0..10 {
        let text = session.new_text(
            format!("table_text_{}", i),
            &format!("Text hey ☣ {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        table_items.push(text);
        //texts.push(get_test_table(&mut session));
    }
    //Add a couple of ellipses

    //Create an ellipse and wrap it with a box
    let ellipse = session.new_elipse(
        "ellipse1".to_string(),
        (0.0, 0.0),
        (10.0, 10.0),
        EllipseOptions {
            fill_color: "red".to_string(),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //table_items.push(ellipse);

    //Now add 10 ellipses
    for i in 0..10 {
        let ellipse = session.new_elipse(
            format!("ellipse{}", i).to_string(),
            (0.0, 0.0),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        // table_items.push(ellipse);
    }

    //create a paragraph of lorem ipsum
    let lorem_ipsum = br#"
  THE adjustment \u{f1878} factor (currently font_size * 0.05) slightly shifts the text vertically to achieve better visual centering. It's a small empirical correction that helps the
  text appear more naturally centered to the human eye, rather than strictly mathematically centered.

  Without this adjustment, the text might appear slightly too high in the box, even when it's mathematically centered according to its metrics. This is particularly noticeable
  with certain fonts or at larger font sizes.

  In essence, it's an optical adjustment that helps the text look properly centered, compensating for the inherent asymmetry in font design and the way our eyes perceive text
  positioning."#;

    //create text shape
    let text = session.new_text(
        "lorem_ipsum".to_string(),
        std::str::from_utf8(lorem_ipsum).unwrap(),
        text_options.clone(),
    );
    table_items.push(text);

    //Add sample image from file (first instance)
    let sampleImage = session.new_image_from_file("imagefile0".to_string(), "demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
    //table_items.push(sampleImage);

    //Add sample image from file
    // The path is relative to where the binary is run
    let file_image = session.new_image_from_file("imagefile".to_string(), "demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
   // table_items.push(file_image);

    // Create a FreeContainer with multiple visual elements at specific positions using the new method

    // Create all elements first
    let title_text = session.new_text(
        "titletext".to_string(),
        "FreeContainer Demo",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 18.0,
            line_width: 100,
            text_color: "#000000".to_string(),
            line_spacing: 0.0,
        },
    );

    let red_circle = session.new_elipse(
        "redcircle".to_string(),
        (0.0, 0.0),   // center position (will be positioned by container)
        (15.0, 15.0), // radius
        EllipseOptions {
            fill_color: "#FF0000".to_string(), // bright red
            stroke_color: "black".to_string(),
            stroke_width: 2.0,
        },
    );

    let thetext = format!(
        r#"
    Esto es un texto
    Otra linea de texto
    Otra mas...
    "#
    );

    let blue_text = session.new_text(
        "bluetext".to_string(),
        &thetext,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "white".to_string(), // white text
            line_spacing: 0.0,
        },
    );

    // Create a box around the blue text
    let box_options = BoxOptions {
        fill_color: Fill::Color("#0000FF".to_string()), // blue background
        stroke_color: "green".to_string(),              // dark blue border
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 3.0,
        width_behavior: volare_engine_layout::SizeBehavior::Fixed(700.0), // Fixed width for the box
        height_behavior: volare_engine_layout::SizeBehavior::Fixed(200.0), 
        ..BoxOptions::default()
    };
    let blue_box = session.new_box("bluebox".to_string(),blue_text, box_options);

    let green_ellipse = session.new_elipse(
        "greeneclipse".to_string(),
        (0.0, 0.0),
        (30.0, 20.0),
        EllipseOptions {
            fill_color: "#00CC00".to_string(),   // green
            stroke_color: "#006600".to_string(), // dark green
            stroke_width: 2.0,
        },
    );

    let subtitle = session.new_text(
        "test_absolute".to_string(),
        "Absolute positioning of elements",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            line_width: 100,
            text_color: "#555555".to_string(), // dark gray
            line_spacing: 0.0,
        },
    );

    // Create a container with all children at once
    let container_with_elements = session.new_free_container("containerwithelems".to_string(),vec![
        (title_text, (30.0, 10.0)),
        (red_circle, (40.0, 50.0)),
        (blue_box, (80.0, 40.0)),
        (green_ellipse, (150.0, 70.0)),
        (subtitle, (30.0, 120.0)),
    ]);

    // Add styling to the container with more vibrant colors
    let free_container = session.get_free_container_mut(container_with_elements.entity_id.clone());
    free_container.background_color = Some("#FFDDDD".to_string()); // Light red background (more visible)
    free_container.border_color = Some("#FF0000".to_string()); // Bright red border
    free_container.border_width = 5.0; // Thicker border

    // Add the FreeContainer to the table
    table_items.push(container_with_elements);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 2;
    let table = session.new_table("table".to_string(), table_items, 5, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render PNG
    // Use other  measure function for PNG rendering
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

// Sample image loading is now handled directly through file loading

//function that returns a sample table with 10 elements and 3 columns

/// .
fn get_test_table(session: &mut DiagramBuilder) -> DiagramTreeNode {
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 5.0,
    };
    //Create a list of 10 texts
    let mut texts = Vec::new();
    for i in 0..10 {
        let textid = format!("text_{}", i);
        let text = session.new_text(
            textid,
            &format!("Text hey {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        texts.push(text);
    }
    //create a table options object with all defaults except the header color
    let table_options = TableOptions {
        header_fill_color: "blue".to_string(),
        ..Default::default()
    };
    //Create a table for the texts with 2 columns
    let table = session.new_table("tabletexts".to_string(), texts, 3, table_options);
    table
}



===/volare_engine_layout.txt===
===/Cargo.toml===
[package]
name = "volare_engine_layout"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.0"

===/target/CACHEDIR.TAG===
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by cargo.
# For information about cache directory tags see https://bford.info/cachedir/

===/target/debug/.fingerprint/layout-base-d68186a17e09bb62/lib-layout-base===
e1fb921afd0324c9
===/target/debug/.fingerprint/layout-base-d68186a17e09bb62/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/.fingerprint/layout-base-3046ca7ae66b4c03/test-lib-layout-base===
c2a4ddc523aefc46
===/target/debug/.fingerprint/layout-base-3046ca7ae66b4c03/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/.fingerprint/layout-base-eed9ca7d180c0e5c/lib-layout-base===
9111b90f7f500e00
===/target/debug/.fingerprint/layout-base-eed9ca7d180c0e5c/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/.fingerprint/layout-base-65ec7ba58964b4ee/test-lib-layout-base===
23f059a2e9751bb5
===/target/debug/.fingerprint/layout-base-65ec7ba58964b4ee/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/deps/layout_base-65ec7ba58964b4ee.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-65ec7ba58964b4ee.rmeta: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-65ec7ba58964b4ee.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/target/debug/deps/layout_base-eed9ca7d180c0e5c.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-eed9ca7d180c0e5c.rmeta: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/liblayout_base-eed9ca7d180c0e5c.rlib: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-eed9ca7d180c0e5c.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/target/debug/deps/layout_base-3046ca7ae66b4c03.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-3046ca7ae66b4c03: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-3046ca7ae66b4c03.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/target/debug/deps/layout_base-d68186a17e09bb62.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-d68186a17e09bb62.rmeta: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-d68186a17e09bb62.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/Cargo.lock===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "layout-base"
version = "0.1.0"

===/.gitignore===
/target
/Cargo.lock

===/.github/workflows/test-and-build.yml===
# test rust project and build

name: Test and Build

on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test
      - name: Build
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release





===/src/layout.rs===
/* Layout calculation for each type of entity */

use crate::components::Float;
use crate::{HorizontalAlignment, ShapeArc, ShapeRect, SizeBehavior, VerticalAlignment};
use crate::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, FreeContainer,
    HorizontalStack, PolyLine, ShapeArrow, ShapeBox, ShapeEllipse, ShapeGroup, ShapeImage,
    ShapeLine, ShapeText, Table, VerticalStack,
};

/* The box layout includes the padding and the dimensions
of the wrapped element
The wrapped element position and size should be updated before calling this function
(except for grow behavior).
The wrapped element position is relative to the box position.
*/
pub fn layout_box(session: &mut DiagramBuilder, shape_box: &ShapeBox) {
    println!("Box: {:?}", shape_box);
    
    // Get the wrapped element dimensions
    let wrapped_elem_size = session.get_size(shape_box.wrapped_entity.clone().clone());
    println!("Box Wrapped elem size: {:?}", wrapped_elem_size);

    // Calculate the box dimensions based on size behavior
    let box_width = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(width) => {
            // For fixed width, use the specified width
            // The wrapped element should be positioned within this fixed width
            width
        }
        SizeBehavior::Content => {
            // Content sizing - size based on wrapped element + padding (current behavior)
            wrapped_elem_size.0 + shape_box.box_options.padding * 2.0
        }
        SizeBehavior::Grow => {
            // TODO: Implement grow behavior in future iterations
            // For now, fall back to content behavior
            wrapped_elem_size.0 + shape_box.box_options.padding * 2.0
        }
    };

    let box_height = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(height) => {
            // For fixed height, use the specified height
            height
        }
        SizeBehavior::Content => {
            // Content sizing - size based on wrapped element + padding (current behavior)
            wrapped_elem_size.1 + shape_box.box_options.padding * 2.0
        }
        SizeBehavior::Grow => {
            // TODO: Implement grow behavior in future iterations
            // For now, fall back to content behavior
            wrapped_elem_size.1 + shape_box.box_options.padding * 2.0
        }
    };

    println!(
        "Box: {}, width: {}, height: {}, padding: {}",
        shape_box.entity, box_width, box_height, shape_box.box_options.padding
    );

    // Set the box dimensions
    session.set_size(shape_box.entity.clone(), box_width, box_height);

    // Position the wrapped element within the box
    // For fixed sizing, we might want to center or align the content
    let content_x = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(fixed_width) => {
            // Center the content horizontally within the fixed width
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            if wrapped_elem_size.0 <= available_width {
                // Center the content
                shape_box.box_options.padding + (available_width - wrapped_elem_size.0) / 2.0
            } else {
                // Content is larger than available space, align to left with padding
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, use standard padding
            shape_box.box_options.padding
        }
    };

    let content_y = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(fixed_height) => {
            // Center the content vertically within the fixed height
            let available_height = fixed_height - shape_box.box_options.padding * 2.0;
            if wrapped_elem_size.1 <= available_height {
                // Center the content
                shape_box.box_options.padding + (available_height - wrapped_elem_size.1) / 2.0
            } else {
                // Content is larger than available space, align to top with padding
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, use standard padding
            shape_box.box_options.padding
        }
    };

    // Update the wrapped element position
    session.set_position(shape_box.wrapped_entity.clone(), content_x, content_y);
}

/**
 * Update the group size based on the size of the elements.
 * Group elements must be positioned before calling this function.
 * (Doesn't update the position of the elements)
 */
pub fn layout_group(session: &mut DiagramBuilder, shape_group: &ShapeGroup) {
    //update group dimensions
    let mut width = 0.0;
    let mut height = 0.0;
    for elem in shape_group.elements.iter() {
        let elem_size = session.get_size(elem.clone());
        if elem_size.0 > width {
            width = elem_size.0;
        }
        if elem_size.1 > height {
            height = elem_size.1;
        }
    }
    session.set_size(shape_group.entity.clone(), width, height);
}

pub fn layout_text(session: &mut DiagramBuilder, shape_text: &ShapeText) {
    // let (w, h) = session.measure_text.unwrap()(&shape_text.text, &shape_text.text_options);
    // session.set_size(shape_text.entity, w, h);
    /* for each line in lines, get the size and use it to position the next */
    {
        println!("Text: {:?}", shape_text);
        let mut y = 0.0;
        let mut max_line_width = 0.0;
        for line in shape_text.lines.iter() {
            println!("Line: {:?}", line);
            let textLine = session.get_text_line(line.clone());
            let line_size = session.measure_text.unwrap()(&textLine.text, &shape_text.text_options);
            if line_size.0 > max_line_width {
                max_line_width = line_size.0;
            }
            session.set_position(line.clone(), 0.0, y);
            session.set_size(line.clone(), line_size.0, line_size.1);
            y += line_size.1 + shape_text.text_options.line_spacing as Float;
        }
        y -= shape_text.text_options.line_spacing as Float; // Adjust for the last line spacing

        println!("max_line_width: {}", max_line_width);
        //set the size of the text element
        println!(
            "Setting size to text entity: {} - {} {}",
            shape_text.entity, max_line_width, y
        );
        session.set_size(shape_text.entity.clone(), max_line_width, y);
    }
}

/**
 * Updates the size of the line entity based on the start and end points
 */
pub fn layout_line(session: &mut DiagramBuilder, shape_line: &ShapeLine) {
    let start = shape_line.start;
    let end = shape_line.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_line.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_line.entity.clone(), x, y);
}

/**
 * Updates the size of the arrow entity based on the start and end points
 */
pub fn layout_arrow(session: &mut DiagramBuilder, shape_arrow: &ShapeArrow) {
    let start = shape_arrow.start;
    let end = shape_arrow.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_arrow.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_arrow.entity.clone(), x, y);
}

/**
 * Updates the size of the ellipse entity based on the horizontal and vertical radius
 * radius.0 is the horizontal radius and radius.1 is the vertical radius
 * The position of the ellipse is the top left corner of the bounding box
 */
pub fn layout_ellipse(session: &mut DiagramBuilder, shape_ellipse: &ShapeEllipse) {
    let w = shape_ellipse.radius.0 * 2.0;
    let h = shape_ellipse.radius.1 * 2.0;
    session.set_size(shape_ellipse.entity.clone(), w, h);
}

pub fn layout_rect(session: &mut DiagramBuilder, rect: &ShapeRect) {
    // If the rect has a fixed size, use that
    let width = match rect.rect_options.width_behavior {
        SizeBehavior::Fixed(w) => w,
        _ => 0.0
    };
    let height = match rect.rect_options.height_behavior {
        SizeBehavior::Fixed(h) => h,
        _ => 0.0
    };

    session.set_size(rect.entity.clone(), width, height);
}

/**
 * Sets the image entity size to the preferred size
 */
pub fn layout_image(session: &mut DiagramBuilder, shape_image: &ShapeImage) {

    let width = match shape_image.width_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0
    };

     let height = match shape_image.height_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0
    };

    session.set_size(
        shape_image.entity.clone(),
        width,
        height,
    );
}

/**
 * Updates the position of the elements in the vertical stack
 * and the size of the vertical stack
 */
pub fn layout_vertical_stack(session: &mut DiagramBuilder, vertical_stack: &VerticalStack) {
    let mut y = 0.0;
    let mut width = 0.0;
    for elem in vertical_stack.elements.iter() {
        println!("DEBUG:::y: {}", y);
        let elem_size = session.get_size(elem.clone());
        session.set_position(elem.clone(), 0.0, y);
        y += elem_size.1;
        if elem_size.0 > width {
            width = elem_size.0;
        }
    }
    session.set_size(vertical_stack.entity.clone(), width, y);

      // Second pass: only adjust x positions if alignment is specified
        for elem in vertical_stack.elements.iter() {
            let elem_size = session.get_size(elem.clone());
            let current_pos = session.get_position(elem.clone());
            let x = match vertical_stack.horizontal_alignment {
                HorizontalAlignment::Left => 0.0,
                HorizontalAlignment::Center => (width - elem_size.0) / 2.0,
                HorizontalAlignment::Right => width - elem_size.0,
            };
            session.set_position(elem.clone(), x, current_pos.1); // Update x, keep y   
        }
}

pub fn layout_horizontal_stack(session: &mut DiagramBuilder, horizontal_stack: &HorizontalStack) {
    let mut x = 0.0;
    let mut height = 0.0;
    for elem in horizontal_stack.elements.iter() {
        let elem_size = session.get_size(elem.clone());
        session.set_position(elem.clone(), x, 0.0);
        x += elem_size.0;
        if elem_size.1 > height {
            height = elem_size.1;
        }
    }
    session.set_size(horizontal_stack.entity.clone(), x, height);

    // Second pass: only adjust y positions, keep existing x positions
        for elem in horizontal_stack.elements.iter() {
            let elem_size = session.get_size(elem.clone());
            let current_pos = session.get_position(elem.clone()); // Get the x we already set
            let y = match horizontal_stack.vertical_alignment {
                VerticalAlignment::Top => 0.0,
                VerticalAlignment::Center => (height - elem_size.1) / 2.0,
                VerticalAlignment::Bottom => height - elem_size.1,
            };
            session.set_position(elem.clone(), current_pos.0, y); // Keep x, update y
        }
}

/**
 * Calculates the layout for each of the cells according to table rules:
 * - Cells in the same column have the same width (eq to the max of widths)
 * - Cells in the same row have the same height (eq to the max of heights)
 * - Rows on top of each other
 * - Cols to the right of each other
 * - The sizes of the internal elements should be previously computed for this to work
 */
pub fn layout_table(session: &mut DiagramBuilder, table: &Table) {
    //we need to group elements by row and column, calculate their
    //natural sizes and then update their rows and columns
    let mut rows: Vec<Vec<EntityID>> = Vec::new();
    let mut cols: Vec<Vec<EntityID>> = Vec::new();
    let mut row_heights: Vec<Float> = Vec::new();
    let mut col_widths: Vec<Float> = Vec::new();

    // Add variables to store line positions
    let mut horizontal_line_positions: Vec<Float> = Vec::new();
    let mut vertical_line_positions: Vec<Float> = Vec::new();

    //initialize rows and cols
    for (i, elem) in table.cells.iter().enumerate() {
        let row = i / table.cols;
        let col = i % table.cols;
        //add the element to the row and col
        if row >= rows.len() {
            rows.push(Vec::new());
            row_heights.push(0.0);
        }
        if col >= cols.len() {
            cols.push(Vec::new());
            col_widths.push(0.0);
        }
        rows[row].push(elem.clone());
        cols[col].push(elem.clone());

        //update the row and col sizes
        let elem_size = session.get_size(elem.clone());
        if elem_size.0 > col_widths[col] {
            col_widths[col] = elem_size.0 + table.table_options.cell_padding as Float * 2.0;
        }
        if elem_size.1 > row_heights[row] {
            row_heights[row] = elem_size.1 + table.table_options.cell_padding as Float * 2.0;
        }
    }

    //print row heights and col widths
    println!("row heights: {:?}", row_heights);
    println!("col widths: {:?}", col_widths);

    //we already have each row and col and their sizes.
    //Now we have to update the position of each element
    //and the size of the table

    //iterate through rows and cols and update the position of each element
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        let mut y = 0.0;
        for (j, elem) in col.iter().enumerate() {
            session.set_position(
                elem.clone(),
                x + table.table_options.cell_padding as Float,
                y + table.table_options.cell_padding as Float,
            );
            y += row_heights[j];
        }

        x += col_widths[i];
    }

    //Update the position of the horizontal lines
    let mut y = 0.0;
    for (i, row) in rows.iter().enumerate() {
        horizontal_line_positions.push(y);
        y += row_heights[i];
    }

    //Update the position of the vertical lines
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        vertical_line_positions.push(x);
        x += col_widths[i];
    }

    //update the size of the table
    let mut width = 0.0;
    let mut height = 0.0;

    for w in col_widths.iter() {
        width += w;
    }

    for h in row_heights.iter() {
        height += h;
    }

    //Update the size of the table header rect
    session.set_size(table.header_rect.clone(), width, row_heights[0]);

    //print the size of the table
    println!("Table size: {:?}", (width, height));

    session.set_size(table.entity.clone(), width, height);

    //We need to update the position of the horizontal lines and their size
    for (i, line) in table.row_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line.clone());
        if i < horizontal_line_positions.len() {
            //set the y position of the horizontal line, x will be 0
            session.set_position(line.clone(), 0.0, horizontal_line_positions[i]);
            //update the size, we only need to update the height and leave the width as it is (0 by default)
            session.set_size(line.clone(), width, line_size.1);
        }
    }

    for (i, line) in table.col_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line.clone());
        if i < vertical_line_positions.len() {
            //set the x position of the vertical line, y will be 0
            session.set_position(line.clone(), vertical_line_positions[i], 0.0);
            //update the size, we only need to update the width and leave the height as it is (0 by default)
            session.set_size(line.clone(), line_size.0, height);
        }
    }
}

pub fn layout_polyline(session: &mut DiagramBuilder, polyline: &PolyLine) {
    let mut x = 0.0;
    let mut y = 0.0;
    let mut width = 0.0;
    let mut height = 0.0;
    for (i, point) in polyline.points.iter().enumerate() {
        if i == 0 {
            x = point.0;
            y = point.1;
        } else {
            if point.0 < x {
                width += x - point.0;
                x = point.0;
            }
            if point.1 < y {
                height += y - point.1;
                y = point.1;
            }
        }
    }
    session.set_size(polyline.entity.clone(), width, height);
}

/**
 * Layout for the FreeContainer
 * Children have absolute positions relative to the container
 * The container size is determined by the maximum extent of its children
 */
pub fn layout_free_container(session: &mut DiagramBuilder, container: &FreeContainer) {
    // We need to determine the size of the container based on the positions and sizes of its children
    let mut max_width = 0.0;
    let mut max_height = 0.0;

    // Iterate through all children and find the maximum extent
    for (child_id, position) in &container.children {
        // Get the child's size
        let child_size = session.get_size(child_id.clone());

        // Set the child's position relative to the container
        session.set_position(child_id.clone(), position.0, position.1);

        // Calculate the right and bottom edges of this child
        let right = position.0 + child_size.0;
        let bottom = position.1 + child_size.1;

        // Update the maximum extent
        if right > max_width {
            max_width = right;
        }
        if bottom > max_height {
            max_height = bottom;
        }
    }

    // Add a small margin to ensure we have enough space
    let margin = 2.0;
    max_width += margin;
    max_height += margin;

    // Set the container's size
    session.set_size(container.entity.clone(), max_width, max_height);
}


/**
 * Updates the size of the arc entity based on the radius and angle sweep
 * The arc's bounding box is calculated from its center, radius, and angle range
 */
pub fn layout_arc(session: &mut DiagramBuilder, shape_arc: &ShapeArc) {
    use std::f32::consts::PI;
    
    let radius = shape_arc.radius;
    let (start_angle, end_angle) = shape_arc.normalize_angles();
    
    // Convert degrees to radians
    let start_rad = start_angle * PI / 180.0;
    let end_rad = end_angle * PI / 180.0;
    
    // Calculate the points at start and end angles
    let start_x = shape_arc.center.0 + radius * start_rad.cos();
    let start_y = shape_arc.center.1 + radius * start_rad.sin();
    let end_x = shape_arc.center.0 + radius * end_rad.cos();
    let end_y = shape_arc.center.1 + radius * end_rad.sin();
    
    // For a more accurate bounding box, we need to consider if the arc crosses
    // the cardinal directions (0°, 90°, 180°, 270°)
    let mut min_x = start_x.min(end_x);
    let mut max_x = start_x.max(end_x);
    let mut min_y = start_y.min(end_y);
    let mut max_y = start_y.max(end_y);
    
    // Check if arc crosses cardinal directions and expand bounding box accordingly
    let sweep = shape_arc.angle_sweep();
    let angles_to_check = if end_angle > start_angle {
        vec![0.0, 90.0, 180.0, 270.0]
    } else {
        // Arc crosses 0° (wraps around)
        vec![0.0, 90.0, 180.0, 270.0, 360.0]
    };
    
    for angle in angles_to_check {
        let normalized_angle = angle % 360.0;
        
        // Check if this cardinal angle is within our arc
        let angle_in_arc = if end_angle > start_angle {
            normalized_angle >= start_angle && normalized_angle <= end_angle
        } else {
            normalized_angle >= start_angle || normalized_angle <= end_angle
        };
        
        if angle_in_arc {
            let rad = normalized_angle * PI / 180.0;
            let x = shape_arc.center.0 + radius * rad.cos();
            let y = shape_arc.center.1 + radius * rad.sin();
            
            min_x = min_x.min(x);
            max_x = max_x.max(x);
            min_y = min_y.min(y);
            max_y = max_y.max(y);
        }
    }
    
    // Calculate width and height from bounding box
    let width = max_x - min_x;
    let height = max_y - min_y;
    
    // Set the position to the top-left corner of the bounding box
    session.set_position(shape_arc.entity.clone(), min_x, min_y);
    session.set_size(shape_arc.entity.clone(), width, height);
}


pub struct BoundingBox {
    x: Float,
    y: Float,
    width: Float,
    height: Float,
}
//Calculate the layout for a tree of elements
pub fn layout_tree_node(session: &mut DiagramBuilder, root: &DiagramTreeNode) -> BoundingBox {

    

    //start with the bottom elements
    for child in &root.children {
        println!("Layout child: {:?}", child);
        layout_tree_node(session, child);
        //print size and position of the child

        let child_size = session.get_size(child.entity_id.clone());
        let child_pos = session.get_position(child.entity_id.clone());
        println!("Child size: {:?}", child_size);
        println!("Child pos: {:?}", child_pos);
    }

    //Once the children are laid out, we can layout the current element
    //use methods in the layout module
    match root.entity_type {
        EntityType::TextShape => {
            {
                //get the Shape text entity
                let text = session.get_text(root.entity_id.clone()).clone();
                layout_text(session, &text);
            }
        }
        EntityType::BoxShape => {
            //get the Shape box entity
            let box_shape = session.get_box(root.entity_id.clone()).clone();
            layout_box(session, &box_shape);
        }

        EntityType::RectShape => {
            //get the Rect entity
            let rect = session.get_rectangle(root.entity_id.clone()).clone();
            layout_rect(
                session,
                &rect
            );
        }

        EntityType::LineShape => {
            //get the Shape line entity
            let line = session.get_line(root.entity_id.clone()).clone();
            layout_line(session, &line);
        }
        EntityType::ArrowShape => {
            //get the Shape arrow entity
            let arrow = session.get_arrow(root.entity_id.clone()).clone();
            layout_arrow(session, &arrow);
        }
        EntityType::EllipseShape => {
            //get the Shape ellipse entity
            let ellipse = session.get_ellipse(root.entity_id.clone()).clone();
            layout_ellipse(session, &ellipse);
        }
        EntityType::ImageShape => {
            //get the Shape image entity
            let image = session.get_image(root.entity_id.clone()).clone();
            layout_image(session, &image);
        }
        EntityType::VerticalStackShape => {
            //get the VerticalStack entity
            let vertical_stack = session.get_vertical_stack(root.entity_id.clone()).clone();
            layout_vertical_stack(session, &vertical_stack);
        }

        EntityType::HorizontalStackShape => {
            //get the HorizontalStack entity
            let horizontal_stack = session.get_horizontal_stack(root.entity_id.clone()).clone();
            layout_horizontal_stack(session, &horizontal_stack);
        }

        EntityType::TableShape => {
            //get the Table entity
            let table = session.get_table(root.entity_id.clone()).clone();
            layout_table(session, &table);
        }

        EntityType::GroupShape => {
            //get the Group entity
            let group = session.get_group(root.entity_id.clone()).clone();
            layout_group(session, &group);
        }

        EntityType::PolyLine => {
            let polyline = session.get_polyline(root.entity_id.clone()).clone();
            layout_polyline(session, &polyline);
        }
        EntityType::FreeContainer => {
            let container = session.get_free_container(root.entity_id.clone()).clone();
            layout_free_container(session, &container);
        }

        EntityType::ArcShape => {
        let arc = session.get_arc(root.entity_id.clone()).clone();
        layout_arc(session, &arc);
    }

        //if not recognized, show the name of it in the panic
        _ => panic!("Unknown entity type: {:?}", root.entity_type),
    }

    //Return the bounding box for the root element
    let size = session.get_size(root.entity_id.clone());
    let position = session.get_position(root.entity_id.clone());
    BoundingBox {
        x: position.0,
        y: position.1,
        width: size.0,
        height: size.1,
    }
}

//import textoptions defined in src/components/mod.rs
use crate::components::BoxOptions;
use crate::components::TextOptions;
//Test that a box with a text inside is correctly laid out
#[test]
fn test_layout_box_with_text() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //print box options
    println!("--box options: {:?}", box_options);

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());
    //assert equal positions

    // assert the box size is greater than the text size
    println!("box size: {:?}", box_size);
    println!("text size: {:?}", text_size);
    // and the text size should not be zero
    assert!(text_size.0 > 0.0);
    assert_eq!(box_size.0, 30.0);
    assert!(box_size.1 > text_size.1);
}

#[test]
fn test_box_fixed_size() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        width_behavior: SizeBehavior::Fixed(100.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());

    //assert equal positions
    // Assert that the text is centered within the box
    assert_eq!(
        text_position.0,
        box_options.padding + (box_options.width_behavior.unwrap_fixed().unwrap() - box_options.padding * 2.0 - text_size.0) / 2.0
    );
    assert_eq!(
        text_position.1,
        box_options.padding + (box_options.height_behavior.unwrap_fixed().unwrap() - box_options.padding * 2.0 - text_size.1) / 2.0
    );
    assert_eq!(box_position, (0.0, 0.0));

    // assert the box size is equal to the fixed size
    assert_eq!(box_size.0, 100.0);
    assert_eq!(box_size.1, 50.0);
}
===/src/lib.rs===

pub use crate::diagram_builder::{DiagramBuilder};
pub use crate::components::*;
pub use crate::layout::*;
pub use crate::utils::*;
pub use crate::renderer_base::*;

pub mod diagram_builder;
pub mod utils;
pub mod components;
pub mod layout;
pub mod renderer_base;
pub mod parser;


===/src/components/mod.rs===

pub mod table;

use core::fmt;
use std::{any::Any, collections::HashMap, sync::Arc};

use serde_json::{Value, Map};

pub use crate::components::table::*;
//new type EntityID that is a u64
pub type EntityID = String;
pub type Float = f32;

//Export table and table options


pub trait Entity {
    fn get_id(&self) -> EntityID;
    fn get_type(&self) -> EntityType;
    //as_any
    fn as_any(&self) -> &dyn Any;
}

pub struct Point {
    pub x: Float,
    pub y: Float,
}

//impl clone
impl Clone for Point {
    fn clone(&self) -> Self {
        Point {
            x: self.x,
            y: self.y,
        }
    }
}

//impl new
impl Point {
    pub fn new(x: Float, y: Float) -> Self {
        Point { x, y }
    }
}

pub struct Size {
    pub w: Float,
    pub h: Float,
}

//impl clone
impl Clone for Size {
    fn clone(&self) -> Self {
        Size {
            w: self.w,
            h: self.h,
        }
    }
}

//impl new
impl Size {
    pub fn new(w: Float, h: Float) -> Self {
        Size { w, h }
    }
}

//Note: add new items to the end of the enum to avoid breaking the serialization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EntityType {
    BoxShape,
    RectShape,
    TextShape,
    LineShape,
    ArrowShape,
    EllipseShape,
    ImageShape,
    GroupShape,
    VerticalStackShape,
    HorizontalStackShape,
    TableShape,
    TextLine,
    PolyLine,
    FreeContainer,
    ArcShape,
}

#[derive(Debug, Copy, PartialEq)]
pub enum SizeBehavior {
    /// Fixed size - element has a predetermined size that doesn't change
    Fixed(Float),
    /// Content size - element sizes itself based on its content (current default behavior)
    Content,
    /// Grow size - element takes all available space from its parent
    Grow,
}

impl Default for SizeBehavior {
    fn default() -> Self {
        SizeBehavior::Content
    }
}

impl Eq for SizeBehavior {

}

impl Clone for SizeBehavior {
    fn clone(&self) -> Self {
        match self {
            SizeBehavior::Fixed(v) => SizeBehavior::Fixed(*v),
            SizeBehavior::Content => SizeBehavior::Content,
            SizeBehavior::Grow => SizeBehavior::Grow,
        }
    }
}

impl SizeBehavior {
    pub fn unwrap_fixed(&self) -> Result<f32, &'static str> {
        match self {
            SizeBehavior::Fixed(val) => Ok(*val),
            _ => Err("Called unwrap_fixed on non-Fixed SizeBehavior"),
        }
    }
}

/**
 * Boxes show a rectangle around the wrapped entity
 */
#[derive(Debug)]
pub struct ShapeBox {
    pub entity: EntityID,
    //Each box wraps another entity
    pub wrapped_entity: EntityID,
    pub box_options: BoxOptions,
}

impl Clone for ShapeBox {
    fn clone(&self) -> Self {
        ShapeBox {
            entity: self.entity.clone(),
            wrapped_entity: self.wrapped_entity.clone(),
            box_options: self.box_options.clone(),
        }
    }
}

impl Entity for ShapeBox {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::BoxShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeBox {
    pub fn new(entity: EntityID, wrapped_entity: EntityID, box_options: BoxOptions) -> ShapeBox {
        ShapeBox {
            entity,            
            wrapped_entity,
            box_options,
        }
    }
}

#[derive(Debug)]
pub enum GradientStop {
    ColorStop { offset: Float, color: String },
    OpacityStop { offset: Float, opacity: Float },
}

#[derive(Debug)]
pub struct LinearGradient {
    pub x1: Float,
    pub y1: Float,
    pub x2: Float,
    pub y2: Float,
    pub stops: Vec<GradientStop>,
}

impl LinearGradient {
    pub fn new(x1: Float, y1: Float, x2: Float, y2: Float, stops: Vec<GradientStop>) -> Self {
        LinearGradient {
            x1,
            y1,
            x2,
            y2,
            stops,
        }
    }
}

impl Clone for GradientStop {
    fn clone(&self) -> Self {
        match self {
            GradientStop::ColorStop { offset, color } => GradientStop::ColorStop {
                offset: *offset,
                color: color.clone(),
            },
            GradientStop::OpacityStop { offset, opacity } => GradientStop::OpacityStop {
                offset: *offset,
                opacity: *opacity,
            },
        }
    }
}

#[derive(Debug)]
pub struct RadialGradient {
    pub cx: Float,
    pub cy: Float,
    pub r: Float,
    pub stops: Vec<GradientStop>,
}

impl Clone for RadialGradient {
    fn clone(&self) -> Self {
        RadialGradient {
            cx: self.cx,
            cy: self.cy,
            r: self.r,
            stops: self.stops.clone(),
        }
    }
}

impl Clone for LinearGradient {
    fn clone(&self) -> Self {
        LinearGradient {
            x1: self.x1,
            y1: self.y1,
            x2: self.x2,
            y2: self.y2,
            stops: self.stops.clone(),
        }
    }
}



#[derive(Debug)]
pub enum Fill {
    Color(String),
    LinearGradient(LinearGradient),
    RadialGradient(RadialGradient),
}

impl Clone for Fill {
    fn clone(&self) -> Self {
        match self {
            Fill::Color(color) => Fill::Color(color.clone()),
            Fill::LinearGradient(gradient) => Fill::LinearGradient(gradient.clone()),
            Fill::RadialGradient(gradient) => Fill::RadialGradient(gradient.clone()),
        }
    }
}
//default trait for fill
impl Default for Fill {
    fn default() -> Self {
        Fill::Color(String::from("white"))
    }
}

//display for fill
impl fmt::Display for Fill {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Fill::Color(color) => write!(f, "{}", color),
            Fill::LinearGradient(gradient) => write!(f, "{:?}", gradient),
            Fill::RadialGradient(gradient) => write!(f, "{:?}", gradient),
        }
    }
}

impl PartialEq for Fill {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Fill::Color(a), Fill::Color(b)) => a == b,
            (Fill::LinearGradient(a), Fill::LinearGradient(b)) => a == b,
            (Fill::RadialGradient(a), Fill::RadialGradient(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for Fill {}

impl PartialEq for LinearGradient {
    fn eq(&self, other: &Self) -> bool {
        self.x1 == other.x1
            && self.y1 == other.y1
            && self.x2 == other.x2
            && self.y2 == other.y2
            && self.stops == other.stops
    }
}

impl Eq for LinearGradient {}

impl PartialEq for RadialGradient {
    fn eq(&self, other: &Self) -> bool {
        self.cx == other.cx
            && self.cy == other.cy
            && self.r == other.r
            && self.stops == other.stops
    }
}

impl Eq for RadialGradient {}

impl PartialEq for GradientStop {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                GradientStop::ColorStop { offset: a_offset, color: a_color },
                GradientStop::ColorStop { offset: b_offset, color: b_color },
            ) => a_offset == b_offset && a_color == b_color,
            (
                GradientStop::OpacityStop { offset: a_offset, opacity: a_opacity },
                GradientStop::OpacityStop { offset: b_offset, opacity: b_opacity },
            ) => a_offset == b_offset && a_opacity == b_opacity,
            _ => false,
        }
    }
}

impl Eq for GradientStop {}

#[derive(Debug)]
pub struct BoxOptions {
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub padding: Float,
    pub border_radius: Float,
        // Add size behavior fields
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
}

impl Clone for BoxOptions {
    fn clone(&self) -> Self {
        BoxOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            padding: self.padding,
            border_radius: self.border_radius,
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),

        }
    }
}

impl Default for BoxOptions {
    fn default() -> Self {
        BoxOptions::new()
    }
}

impl BoxOptions {
    pub fn new() -> BoxOptions {
        BoxOptions {
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            padding: 10.0,
            border_radius: 0.0,
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
        }
    }
}



/* A group of entities */

//RectOptions
#[derive(Default, Debug)]
pub struct RectOptions {
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub border_radius: Float,
}

impl Clone for RectOptions {
    fn clone(&self) -> Self {
        RectOptions {
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(), 
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            border_radius: self.border_radius,
        }
    }
}

impl RectOptions {
    pub fn new() -> RectOptions {
        RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(100.0),
            // Default fill color is white
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            border_radius: 0.0,
        }
    }
}

pub struct ShapeRect {
    pub entity: EntityID,
    pub rect_options: RectOptions,
}

impl ShapeRect {
    pub fn new(entity: EntityID, rect_options: RectOptions) -> ShapeRect {
        ShapeRect {
            entity,
            rect_options,
        }
    }
}

impl Clone for ShapeRect {
    fn clone(&self) -> Self {
        ShapeRect {
            entity: self.entity.clone(),
            rect_options: self.rect_options.clone(),
        }
    }
}

impl Entity for ShapeRect {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::RectShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}


/* A group of entities */
pub struct ShapeGroup {
    pub entity: EntityID,
    pub elements: Vec<EntityID>,
}

impl Clone for ShapeGroup {
    fn clone(&self) -> Self {
        ShapeGroup {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
        }
    }
}

impl Entity for ShapeGroup {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::GroupShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

// Represents a line after adding breaks
#[derive(Debug)]
pub struct TextLine {
    pub entity: EntityID,
    pub text: String,
}

impl Clone for TextLine {
    fn clone(&self) -> Self {
        TextLine {
            entity: self.entity.clone(),
            text: self.text.clone(),
        }
    }
}

impl Entity for TextLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
//add copy trait
#[derive(Debug)]
pub struct ShapeText {
    pub entity: EntityID,
    pub text: String,
    pub text_options: TextOptions,
    pub lines: Vec<EntityID>,
}

impl Clone for ShapeText {
    fn clone(&self) -> Self {
        ShapeText {
            entity: self.entity.clone(),
            text: self.text.clone(),
            text_options: self.text_options.clone(),
            lines: self.lines.clone(),
        }
    }
}


impl ShapeText {
    pub fn new(entity: EntityID, text: &str, text_options: TextOptions, lines: &[EntityID]) -> ShapeText {
        ShapeText {
            entity,
            text: text.to_string(),
            text_options,
            lines: lines.to_vec(),
        }
    }
}



impl Entity for ShapeText {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

//struct with text options: font family, font size
#[derive(Default, Debug)]
pub struct TextOptions {
    pub font_family: String,
    pub font_size: f32,
    pub text_color: String,
    // (number of max characters per line)used to know when to insert breaks
    pub line_width: usize,
    pub line_spacing: f32, // spacing between lines
}

impl Clone for TextOptions {
    fn clone(&self) -> Self {
        TextOptions {
            font_family: self.font_family.clone(),
            font_size: self.font_size,
            text_color: self.text_color.clone(),
            line_width: self.line_width,
            line_spacing: self.line_spacing,
        }
    }
}

impl TextOptions {
    pub fn new() -> TextOptions {
        TextOptions {
            font_family: String::from("Roboto"),
            font_size: 12.0,
            text_color: String::from("black"),
            line_width: 20,
            line_spacing: 0.0,
        }
    }
}

pub enum HorizontalAlignment {
    Left,
    Center,
    Right,
}

impl Clone for HorizontalAlignment {
    fn clone(&self) -> Self {
        match self {
            HorizontalAlignment::Left => HorizontalAlignment::Left,
            HorizontalAlignment::Center => HorizontalAlignment::Center,
            HorizontalAlignment::Right => HorizontalAlignment::Right,
        }
    }
}   

pub struct VerticalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub horizontal_alignment: HorizontalAlignment
}

impl Clone for VerticalStack {
    fn clone(&self) -> Self {
        VerticalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            horizontal_alignment: self.horizontal_alignment.clone()
        }
    }
}

impl Entity for VerticalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::VerticalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
    
pub enum VerticalAlignment {
    Top,
    Center,
    Bottom,
}

impl Clone for VerticalAlignment {
    fn clone(&self) -> Self {
        match self {
            VerticalAlignment::Top => VerticalAlignment::Top,
            VerticalAlignment::Center => VerticalAlignment::Center,
            VerticalAlignment::Bottom => VerticalAlignment::Bottom,
        }
    }
}   
impl fmt::Display for VerticalAlignment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerticalAlignment::Top => write!(f, "Top"),
            VerticalAlignment::Center => write!(f, "Center"),
            VerticalAlignment::Bottom => write!(f, "Bottom"),
        }
    }
}
//enum for horizontal stack

pub struct HorizontalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub vertical_alignment: VerticalAlignment, // Optional vertical alignment (e.g., "top", "center", "bottom")
}

impl Clone for HorizontalStack {
    fn clone(&self) -> Self {
        HorizontalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            vertical_alignment: self.vertical_alignment.clone(),
        }
    }
}

impl Entity for HorizontalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::HorizontalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ShapeLine {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub line_options: LineOptions,
}

impl Clone for ShapeLine {
    fn clone(&self) -> Self {
        ShapeLine {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            line_options: self.line_options.clone(),
        }
    }
}

impl ShapeLine {
    pub fn new(line_id: EntityID, start: (Float, Float), end: (Float, Float), options: LineOptions) -> ShapeLine {
        ShapeLine {
            entity: line_id,
            start,
            end,
            line_options: options,
        }
    }
}


impl Entity for ShapeLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::LineShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct LineOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for LineOptions {
    fn clone(&self) -> Self {
        LineOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl LineOptions {
    pub fn new() -> LineOptions {
        LineOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct PolyLine {
    pub entity: EntityID,
    pub points: Vec<(Float, Float)>,
    pub line_options: LineOptions,
}

impl PolyLine {
    pub fn new(entity: EntityID, points: Vec<(Float, Float)>, line_options: LineOptions) -> PolyLine {
        PolyLine {
            entity,
            points,
            line_options,
        }
    }
}

impl Entity for PolyLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::PolyLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl Clone for PolyLine {
    fn clone(&self) -> Self {
        PolyLine {
            entity: self.entity.clone(),
            points: self.points.clone(),
            line_options: self.line_options.clone(),
        }
    }
}

pub struct ShapeArrow {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub arrow_options: ArrowOptions,
}

impl Clone for ShapeArrow {
    fn clone(&self) -> Self {
        ShapeArrow {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            arrow_options: self.arrow_options.clone(),
        }
    }
}

impl Entity for ShapeArrow {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArrowShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct ArrowOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
    pub arrow_size: Float,
}

impl Clone for ArrowOptions {
    fn clone(&self) -> Self {
        ArrowOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            arrow_size: self.arrow_size,
        }
    }
}

impl ArrowOptions {
    pub fn new() -> ArrowOptions {
        ArrowOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            arrow_size: 10.0,
        }
    }
}

pub struct ShapeEllipse {
    pub entity: EntityID,
    pub center: (Float, Float),
    pub radius: (Float, Float),
    pub ellipse_options: EllipseOptions,
}

impl Clone for ShapeEllipse {
    fn clone(&self) -> Self {
        ShapeEllipse {
            entity: self.entity.clone(),
            center: self.center,
            radius: self.radius,
            ellipse_options: self.ellipse_options.clone(),
        }
    }
}

impl ShapeEllipse {
    pub fn new(entity: EntityID, center: (Float, Float), radius: (Float, Float), ellipse_options: EllipseOptions) -> ShapeEllipse {
        ShapeEllipse {
            entity,
            center,
            radius,
            ellipse_options,
        }
    }
}

impl Entity for ShapeEllipse {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::EllipseShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct EllipseOptions {
    //TODO: convert to Fill
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for EllipseOptions {
    fn clone(&self) -> Self {
        EllipseOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl EllipseOptions {
    pub fn new() -> EllipseOptions {
        EllipseOptions {
            fill_color: String::from("white"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}



pub struct ShapeImage {
    pub entity: EntityID,
    //base64 encoded image or empty if using file_path
    pub image: String,
    //path to image file on disk (optional)
    pub file_path: Option<String>,
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior
}

impl Clone for ShapeImage {
    fn clone(&self) -> Self {
        ShapeImage {
            entity: self.entity.clone(),
            image: self.image.clone(),
            file_path: self.file_path.clone(),
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
        }
    }
}

impl Entity for ShapeImage {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ImageShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeImage {
    pub fn new(entity: EntityID, image: String, size: (SizeBehavior, SizeBehavior)) -> ShapeImage {
        ShapeImage {
            entity,
            image,
            file_path: None,
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }
    
    pub fn from_file(entity: EntityID, file_path: String, size: (SizeBehavior, SizeBehavior)) -> ShapeImage {
        ShapeImage {
            entity,
            image: String::new(), // Empty as we're using file_path instead
            file_path: Some(file_path),
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }
}

/// A container that allows children to be positioned with absolute coordinates
/// Children's positions are relative to the container's top-left corner
pub struct FreeContainer {
    pub entity: EntityID,
    pub children: Vec<(EntityID, (Float, Float))>, // Each child has a position relative to the container
    pub background_color: Option<String>,      // Optional background color
    pub border_color: Option<String>,          // Optional border color
    pub border_width: Float,                    // Border width (0 for no border)
}

impl Clone for FreeContainer {
    fn clone(&self) -> Self {
        FreeContainer {
            entity: self.entity.clone(),
            children: self.children.clone(),
            background_color: self.background_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
        }
    }
}

impl Entity for FreeContainer {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::FreeContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl FreeContainer {
    /// Create a new empty FreeContainer
    pub fn new(entity: EntityID) -> Self {
        FreeContainer {
            entity,
            children: Vec::new(),
            background_color: None,
            border_color: None,
            border_width: 0.0,
        }
    }
    
    /// Add a child to the container at the specified position
    pub fn add_child(&mut self, child_id: EntityID, position: (Float, Float)) {
        self.children.push((child_id, position));
    }
    
    /// Add multiple children at once with their positions
    pub fn with_children(mut self, children_with_positions: Vec<(EntityID, (Float, Float))>) -> Self {
        self.children.extend(children_with_positions);
        self
    }
    
    /// Set background color
    pub fn with_background_color(mut self, color: &str) -> Self {
        self.background_color = Some(color.to_string());
        self
    }
    
    /// Set border properties
    pub fn with_border(mut self, color: &str, width: Float) -> Self {
        self.border_color = Some(color.to_string());
        self.border_width = width;
        self
    }
}


// Arc options structure
#[derive(Default, Debug)]
pub struct ArcOptions {
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub filled: bool, // Whether to fill the arc sector or just draw the outline
}

impl Clone for ArcOptions {
    fn clone(&self) -> Self {
        ArcOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            filled: self.filled,
        }
    }
}

impl ArcOptions {
    pub fn new() -> ArcOptions {
        ArcOptions {
            fill_color: String::from("none"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            filled: false,
        }
    }
}

// Arc shape structure
pub struct ShapeArc {
    pub entity: EntityID,
    pub center: (Float, Float),     // Center point of the arc
    pub radius: Float,              // Radius of the arc
    pub start_angle: Float,         // Start angle in degrees
    pub end_angle: Float,           // End angle in degrees
    pub arc_options: ArcOptions,
}

impl Clone for ShapeArc {
    fn clone(&self) -> Self {
        ShapeArc {
            entity: self.entity.clone(),
            center: self.center,
            radius: self.radius,
            start_angle: self.start_angle,
            end_angle: self.end_angle,
            arc_options: self.arc_options.clone(),
        }
    }
}

impl ShapeArc {
    pub fn new(
        entity: EntityID,
        center: (Float, Float),
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        arc_options: ArcOptions,
    ) -> ShapeArc {
        ShapeArc {
            entity,
            center,
            radius,
            start_angle,
            end_angle,
            arc_options,
        }
    }
    
    /// Normalize angles to 0-360 degree range
    pub fn normalize_angles(&self) -> (Float, Float) {
        let mut start = self.start_angle % 360.0;
        let mut end = self.end_angle % 360.0;
        
        if start < 0.0 {
            start += 360.0;
        }
        if end < 0.0 {
            end += 360.0;
        }
        
        (start, end)
    }
    
    /// Calculate the angle sweep of the arc
    pub fn angle_sweep(&self) -> Float {
        let (start, end) = self.normalize_angles();
        if end > start {
            end - start
        } else {
            360.0 - start + end
        }
    }
    
    /// Check if this is a major arc (> 180 degrees)
    pub fn is_major_arc(&self) -> bool {
        self.angle_sweep() > 180.0
    }
}

impl Entity for ShapeArc {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArcShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}


/// Type alias for custom component factory functions
/// Takes a map of attributes and a mutable reference to DiagramBuilder
/// Returns a Result with either a DiagramTreeNode or an error message
pub type CustomComponentFactory = Arc<dyn Fn(&Map<String, Value>, &mut crate::DiagramBuilder) -> Result<crate::diagram_builder::DiagramTreeNode, String> + Send + Sync>;

/// Registry for custom components
pub struct CustomComponentRegistry {
    factories: HashMap<String, CustomComponentFactory>,
}

impl CustomComponentRegistry {
    pub fn new() -> Self {
        Self {
            factories: HashMap::new(),
        }
    }

    /// Register a new custom component with the given identifier and factory function
    pub fn register<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(&Map<String, Value>, &mut crate::DiagramBuilder) -> Result<crate::diagram_builder::DiagramTreeNode, String> + Send + Sync + 'static,
    {
        self.factories.insert(component_type.to_string(), Arc::new(factory));
    }

    /// Create a component instance using the registered factory
    pub fn create_component(
        &self,
        component_type: &str,
        attributes: &Map<String, Value>,
        builder: &mut crate::DiagramBuilder,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        match self.factories.get(component_type) {
            Some(factory) => factory(attributes, builder),
            None => Err(format!("Unknown custom component type: {}", component_type)),
        }
    }

    /// Check if a component type is registered
    pub fn has_component(&self, component_type: &str) -> bool {
        self.factories.contains_key(component_type)
    }

    /// Get all registered component types
    pub fn get_registered_types(&self) -> Vec<&String> {
        self.factories.keys().collect()
    }

     pub fn get(
        &self,
        component_type: &str,
    ) -> Option<&Arc<dyn Fn(&serde_json::Map<String, serde_json::Value>, &mut crate::diagram_builder::DiagramBuilder) -> Result<crate::diagram_builder::DiagramTreeNode, String> + Send + Sync>> {
        self.factories.get(component_type)
    }
}

impl Default for CustomComponentRegistry {
    fn default() -> Self {
        Self::new()
    }
}


// Helper functions for extracting common attribute types
impl CustomComponentRegistry {
    /// Helper to extract a string attribute with a default value
    pub fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    /// Helper to extract a float attribute with a default value
    pub fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs
            .get(key)
            .and_then(|v| v.as_f64())
            .unwrap_or(default) as Float
    }

    /// Helper to extract a boolean attribute with a default value
    pub fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs
            .get(key)
            .and_then(|v| v.as_bool())
            .unwrap_or(default)
    }

    /// Helper to extract an integer attribute with a default value
    pub fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs
            .get(key)
            .and_then(|v| v.as_i64())
            .unwrap_or(default)
    }
}


#[cfg(test)]
mod custom_component_tests {
    use super::*;
    use crate::*;
    use serde_json::json;

    /// Test custom component: Badge
    /// Creates a rounded box with text and a colored background
    fn create_badge_component(
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        // Extract attributes with defaults
        let text = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("Badge")
            .to_string();

        let id = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string();
        
        let textNode = builder.new_text(id, &text, TextOptions::default());
        Ok(textNode)
    }

    #[test]
    fn test_custom_component_registry() {
        let mut registry = CustomComponentRegistry::new();

        // Register badge component
        registry.register("badge", create_badge_component);

        // Test that components are registered
        assert!(registry.has_component("badge"));
        assert!(!registry.has_component("unknown"));

        // Test getting registered types
        let types = registry.get_registered_types();
        assert_eq!(types.len(), 1);
        assert!(types.contains(&&"badge".to_string()));
    }

    #[test]
    fn test_create_badge_component() {
        let mut registry = CustomComponentRegistry::new();
        registry.register("badge", create_badge_component);

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));

        // Create badge with custom attributes
        let attrs = json!({
            "text": "NEW",
            "background_color": "red",
            "text_color": "white",
            "font_size": 14.0,
            "padding": 6.0,
            "border_radius": 20.0
        });

        let attrs_map = attrs.as_object().unwrap();
        let badge = registry.create_component("badge", attrs_map, &mut builder);

        assert!(badge.is_ok());
        let badge_node = badge.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::TextShape);
    }
}

===/src/components/table.rs===

//use EntityID
use crate::components::*;


pub struct TableOptions {
    pub fill_color: String,
    pub header_fill_color: String,
    pub border_color: String,
    pub border_width: usize,
    pub cell_padding: usize,
}

/* A table contains a list of rows, each row has a cell 
* which is a group that contains other elements.

Tables are defined with an array of cells and the number of columns
*/
pub struct Table {
    pub entity: EntityID,
    pub cols: usize, 
    pub cells: Vec<EntityID>,
    pub col_lines: Vec<EntityID>,
    pub row_lines: Vec<EntityID>,
    pub header_rect: EntityID,
    pub table_options: TableOptions,
}

//new


impl Clone for Table {
    fn clone(&self) -> Self {
        Table {
            entity: self.entity.clone(),
            cols: self.cols,
            cells: self.cells.clone(),
            col_lines: self.col_lines.clone(),
            row_lines: self.row_lines.clone(),
            table_options: self.table_options.clone(),
            header_rect: self.header_rect.clone(),
        }
    }
}

//constructor that receives only the table options
impl Table {
    pub fn new(entity: EntityID,cells: Vec<EntityID>, col_lines: Vec<EntityID>, row_lines: Vec<EntityID>, cols: usize, header_rect: EntityID, table_options: TableOptions) -> Table {
        Table {
            entity,
            cols,
            cells,
            col_lines,
            row_lines ,
            header_rect, 
            table_options,
        }
    }
}

impl Entity for Table {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TableShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}




//defaults
impl Default for TableOptions {
    fn default() -> Self {
        TableOptions {
            fill_color: String::from("white"),
            border_color: String::from("black"),
            header_fill_color: String::from("lightgray"),
            border_width: 1,
            cell_padding: 20,
        }
    }
}

impl Clone for TableOptions {
    fn clone(&self) -> Self {
        TableOptions {
            fill_color: self.fill_color.clone(),
            header_fill_color: self.header_fill_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
            cell_padding: self.cell_padding,
        }
    }
}

===/src/renderer_base.rs===
use std::{error::Error, fmt, io::Write};

use crate::{DiagramBuilder, diagram_builder::DiagramTreeNode};

#[derive(Debug)]
pub struct RendererError {
    message: String,
}

impl RendererError {
    pub fn new(message: &str) -> RendererError {
        RendererError {
            message: message.to_string(),
        }
    }
}

impl fmt::Display for RendererError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for RendererError {}

pub trait Renderer<W: Write> {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError>;
}

===/src/parser.rs===
use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

use crate::{components::*, diagram_builder::*, DiagramBuilder};

/// Simplified JSON Lines entity with only essential fields
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonEntity {
    pub id: String,
    #[serde(rename = "type")]
    pub entity_type: String,

    // All attributes go into this single map - much cleaner!
    #[serde(flatten)]
    pub attributes: Map<String, Value>,
}

impl Default for JsonEntity {
    fn default() -> Self {
        Self {
            id: String::new(),
            entity_type: String::new(),
            attributes: Map::new(),
        }
    }
}

// Helper functions for attribute extraction with multiple attribute name support
fn get_string_attr(attrs: &Map<String, Value>, keys: &[&str], default: &str) -> String {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(s) = value.as_str() {
                return if s.is_empty() && !default.is_empty() {
                    default.to_string()
                } else {
                    s.to_string()
                };
            }
        }
    }
    default.to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, keys: &[&str], default: f64) -> Float {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(f) = value.as_f64() {
                return f as Float;
            }
        }
    }
    default as Float
}

fn get_int_attr(attrs: &Map<String, Value>, keys: &[&str], default: i64) -> i64 {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(i) = value.as_i64() {
                return i;
            }
        }
    }
    default
}

fn get_bool_attr(attrs: &Map<String, Value>, keys: &[&str], default: bool) -> bool {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(b) = value.as_bool() {
                return b;
            }
        }
    }
    default
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<String>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
    })
}

fn get_point_attr(
    attrs: &Map<String, Value>,
    x_keys: &[&str],
    y_keys: &[&str],
    default: (Float, Float),
) -> (Float, Float) {
    let x = get_float_attr(attrs, x_keys, default.0 as f64);
    let y = get_float_attr(attrs, y_keys, default.1 as f64);
    (x, y)
}

fn get_points_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<(Float, Float)>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| {
                    item.as_array().and_then(|point_arr| {
                        if point_arr.len() >= 2 {
                            let x = point_arr[0].as_f64().unwrap_or(0.0) as Float;
                            let y = point_arr[1].as_f64().unwrap_or(0.0) as Float;
                            Some((x, y))
                        } else {
                            None
                        }
                    })
                })
                .collect()
        })
    })
}

/// Parse a unified width/height value that can be either a number (fixed) or string (behavior)
fn parse_unified_dimension(attrs: &Map<String, Value>, keys: &[&str]) -> SizeBehavior {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            match value {
                Value::Number(num) => {
                    if let Some(float_val) = num.as_f64() {
                        return SizeBehavior::Fixed(float_val as Float);
                    }
                }
                Value::String(behavior) => {
                    return match behavior.to_lowercase().as_str() {
                        "content" | "auto" => SizeBehavior::Content,
                        "grow" => SizeBehavior::Grow,
                        _ => {
                            // Try to parse as number string
                            if let Ok(parsed) = behavior.parse::<Float>() {
                                SizeBehavior::Fixed(parsed)
                            } else {
                                SizeBehavior::Content
                            }
                        }
                    };
                }
                _ => {}
            }
        }
    }
    SizeBehavior::Content // Default
}

/// Parser for JSON Lines diagram format
pub struct JsonLinesParser {
    entities: HashMap<String, JsonEntity>,
}

impl JsonLinesParser {
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
        }
    }

    /// Parse from a string containing JSON Lines
    pub fn parse_string(&mut self, input: &str) -> Result<String, JsonLinesError> {
        let mut root_id = None;

        for (line_num, line) in input.lines().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from a file
    pub fn parse_file(&mut self, file_path: &str) -> Result<String, JsonLinesError> {
        let file = File::open(file_path).map_err(|e| JsonLinesError::IoError(e.to_string()))?;
        let reader = BufReader::new(file);
        let mut root_id = None;

        for (line_num, line_result) in reader.lines().enumerate() {
            let line = line_result.map_err(|e| JsonLinesError::IoError(e.to_string()))?;
            let line = line.trim();

            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(&line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from an iterator of lines (useful for streaming)
    pub fn parse_lines<I>(&mut self, lines: I) -> Result<String, JsonLinesError>
    where
        I: IntoIterator<Item = String>,
    {
        let mut root_id = None;

        for (line_num, line) in lines.into_iter().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Build the diagram tree from parsed entities
    pub fn build(
        &self,
        root_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        self.build_entity(root_id, builder)
    }

    fn build_entity(
        &self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        // Clone the entity type to avoid borrow conflicts
        let component_type = entity.entity_type.clone();
        let attributes = entity.attributes.clone();

        // Check for custom components FIRST - they get the raw attributes map
        if builder.has_custom_component(&component_type) {
            return builder
                .create_custom_component(&component_type, &attributes)
                .map_err(|e| JsonLinesError::InvalidStructure(e));
        }

        // Handle built-in components using attribute helpers
        match entity.entity_type.as_str() {
            "text" => {
                let content = get_string_attr(&entity.attributes, &["content", "text"], "");
                if content.is_empty() {
                    return Err(JsonLinesError::MissingAttribute(
                        "content or text".to_string(),
                    ));
                }

                let options = TextOptions {
                    font_size: get_float_attr(&entity.attributes, &["font_size"], 12.0),
                    text_color: get_string_attr(
                        &entity.attributes,
                        &["color", "text_color"],
                        "black",
                    ),
                    font_family: get_string_attr(&entity.attributes, &["font_family"], "Arial"),
                    line_width: get_int_attr(&entity.attributes, &["line_width"], 200) as usize,
                    line_spacing: get_float_attr(&entity.attributes, &["line_spacing"], 0.0),
                };

                Ok(builder.new_text(entity_id.to_string(), &content, options))
            }

            "box" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                if children.len() != 1 {
                    return Err(JsonLinesError::InvalidStructure(
                        "Box must have exactly one child".to_string(),
                    ));
                }

                let child = self.build_entity(&children[0], builder)?;

                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = BoxOptions {
                    padding: get_float_attr(&entity.attributes, &["padding"], 0.0),
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                    width_behavior,
                    height_behavior,
                };

                Ok(builder.new_box(entity_id.to_string(), child, options))
            }

            "vstack" => {
                let halign = match get_string_attr(
                    &entity.attributes,
                    &["h_align", "horizontal_alignment"],
                    "center",
                )
                .as_str()
                {
                    "left" => HorizontalAlignment::Left,
                    "center" => HorizontalAlignment::Center,
                    "right" => HorizontalAlignment::Right,
                    _ => HorizontalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                Ok(builder.new_vstack(entity_id.to_string(), child_nodes?, halign))
            }

            "hstack" => {
                let valign = match get_string_attr(
                    &entity.attributes,
                    &["v_align", "vertical_alignment"],
                    "center",
                )
                .as_str()
                {
                    "top" => VerticalAlignment::Top,
                    "center" => VerticalAlignment::Center,
                    "bottom" => VerticalAlignment::Bottom,
                    _ => VerticalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                Ok(builder.new_hstack(entity_id.to_string(), child_nodes?, valign))
            }

            "group" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                Ok(builder.new_group(entity_id.to_string(), child_nodes?))
            }

            "rect" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = RectOptions {
                    width_behavior,
                    height_behavior,
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                };

                Ok(builder.new_rectangle(entity_id.to_string(), options))
            }

            "line" => {
                let start_point = get_point_attr(
                    &entity.attributes,
                    &["start_x", "x1"],
                    &["start_y", "y1"],
                    (0.0, 0.0),
                );
                let end_point = get_point_attr(
                    &entity.attributes,
                    &["end_x", "x2"],
                    &["end_y", "y2"],
                    (0.0, 0.0),
                );

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };

                Ok(builder.new_line(entity_id.to_string(), start_point, end_point, options))
            }

            "ellipse" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (50.0, 50.0),
                );
                let radius = get_point_attr(
                    &entity.attributes,
                    &["rx", "radius_x"],
                    &["ry", "radius_y"],
                    (25.0, 25.0),
                );

                let options = EllipseOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color", "background"],
                        "white",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color", "border_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["stroke_width", "border_width"],
                        1.0,
                    ),
                };

                Ok(builder.new_elipse(entity_id.to_string(), center, radius, options))
            }

            "arc" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (0.0, 0.0),
                );
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let start_angle =
                    get_float_attr(&entity.attributes, &["start_angle", "start"], 0.0);
                let end_angle = get_float_attr(&entity.attributes, &["end_angle", "end"], 90.0);

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                Ok(builder.new_arc(
                    entity_id.to_string(),
                    center,
                    radius,
                    start_angle,
                    end_angle,
                    options,
                ))
            }

            "semicircle" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (0.0, 0.0),
                );
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let facing_up = get_bool_attr(&entity.attributes, &["facing_up", "up"], true);

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                Ok(builder.new_semicircle(
                    entity_id.to_string(),
                    center,
                    radius,
                    facing_up,
                    options,
                ))
            }

            "quarter_circle" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (0.0, 0.0),
                );
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let quadrant = get_int_attr(&entity.attributes, &["quadrant"], 1) as u8;

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                Ok(builder.new_quarter_circle(
                    entity_id.to_string(),
                    center,
                    radius,
                    quadrant,
                    options,
                ))
            }

            "image" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let src = get_string_attr(&entity.attributes, &["src"], "");
                let file_path = get_string_attr(&entity.attributes, &["file_path"], "");

                if !src.is_empty() {
                    Ok(builder.new_image(
                        entity_id.to_string(),
                        &src,
                        (width_behavior, height_behavior),
                    ))
                } else if !file_path.is_empty() {
                    Ok(builder.new_image_from_file(
                        entity_id.to_string(),
                        &file_path,
                        (width_behavior, height_behavior),
                    ))
                } else {
                    Err(JsonLinesError::MissingAttribute(
                        "src or file_path".to_string(),
                    ))
                }
            }

            "table" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;
                let cols = get_int_attr(&entity.attributes, &["cols", "columns"], 1) as usize;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                let options = TableOptions {
                    header_fill_color: get_string_attr(
                        &entity.attributes,
                        &["header_fill_color", "header_background"],
                        "lightgray",
                    ),
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill_color", "background"],
                        "white",
                    ),
                    border_color: get_string_attr(&entity.attributes, &["border_color"], "black"),
                    border_width: get_int_attr(&entity.attributes, &["border_width"], 1) as usize,
                    cell_padding: get_int_attr(&entity.attributes, &["cell_padding", "padding"], 20)
                        as usize,
                };

                Ok(builder.new_table(entity_id.to_string(), child_nodes?, cols, options))
            }

            "polyline" => {
                let points = get_points_attr(&entity.attributes, "points")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("points".to_string()))?;

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };

                Ok(builder.new_polyline(entity_id.to_string(), points, options))
            }

            "free_container" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let mut positioned_children = Vec::new();
                for child_id in children {
                    let child_entity = self
                        .entities
                        .get(&child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;

                    let child_node = self.build_entity(&child_id, builder)?;
                    let position =
                        get_point_attr(&child_entity.attributes, &["x"], &["y"], (0.0, 0.0));
                    positioned_children.push((child_node, position));
                }

                Ok(builder.new_free_container(entity_id.to_string(), positioned_children))
            }

            _ => Err(JsonLinesError::UnknownEntityType(
                entity.entity_type.clone(),
            )),
        }
    }

    /// Validate that all child references exist
    pub fn validate(&self) -> Result<(), JsonLinesError> {
        for (id, entity) in &self.entities {
            if let Some(children) = get_array_attr(&entity.attributes, "children") {
                for child_id in children {
                    if !self.entities.contains_key(&child_id) {
                        return Err(JsonLinesError::MissingChild {
                            parent: id.clone(),
                            child: child_id,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    /// Get all entity IDs
    pub fn get_entity_ids(&self) -> Vec<&String> {
        self.entities.keys().collect()
    }
}

/// Builder for creating JSON Lines diagrams
pub struct JsonLinesBuilder {
    entities: Vec<JsonEntity>,
}

impl JsonLinesBuilder {
    pub fn new() -> Self {
        Self {
            entities: Vec::new(),
        }
    }

    /// Create a text entity
    pub fn text(&mut self, id: String, content: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a styled text entity
    pub fn text_styled(
        &mut self,
        id: String,
        content: &str,
        font_size: f64,
        color: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));
        attrs.insert(
            "font_size".to_string(),
            Value::Number(serde_json::Number::from_f64(font_size).unwrap()),
        );
        attrs.insert("color".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a box entity
    pub fn box_with(
        &mut self,
        id: String,
        child: String,
        padding: f64,
        background: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(vec![Value::String(child)]),
        );
        attrs.insert(
            "padding".to_string(),
            Value::Number(serde_json::Number::from_f64(padding).unwrap()),
        );
        attrs.insert(
            "background".to_string(),
            Value::String(background.to_string()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "box".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a vertical stack
    pub fn vstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "vstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a horizontal stack
    pub fn hstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "hstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a rectangle
    pub fn rect(&mut self, id: String, width: f64, height: f64, color: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "width".to_string(),
            Value::Number(serde_json::Number::from_f64(width).unwrap()),
        );
        attrs.insert(
            "height".to_string(),
            Value::Number(serde_json::Number::from_f64(height).unwrap()),
        );
        attrs.insert("background".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "rect".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a custom component entity
    pub fn custom_component(
        &mut self,
        id: String,
        component_type: &str,
        attributes: Map<String, Value>,
    ) -> String {
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: component_type.to_string(),
            attributes,
        });
        id
    }

    /// Build and return the JSON Lines string
    pub fn build(&self) -> Result<String, serde_json::Error> {
        let mut lines = Vec::new();
        for entity in &self.entities {
            lines.push(serde_json::to_string(entity)?);
        }
        Ok(lines.join("\n"))
    }

    /// Write to a file
    pub fn write_to_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::create(file_path)?;
        for entity in &self.entities {
            writeln!(file, "{}", serde_json::to_string(entity)?)?;
        }
        Ok(())
    }

    /// Get the root entity ID (first entity)
    pub fn root_id(&self) -> Option<String> {
        self.entities.first().map(|e| e.id.clone())
    }
}

#[derive(Debug)]
pub enum JsonLinesError {
    ParseError { line: usize, message: String },
    EntityNotFound(String),
    MissingAttribute(String),
    InvalidStructure(String),
    UnknownEntityType(String),
    MissingChild { parent: String, child: String },
    NoEntities,
    IoError(String),
}

impl std::fmt::Display for JsonLinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsonLinesError::ParseError { line, message } => {
                write!(f, "Parse error on line {}: {}", line, message)
            }
            JsonLinesError::EntityNotFound(id) => write!(f, "Entity not found: {}", id),
            JsonLinesError::MissingAttribute(attr) => {
                write!(f, "Missing required attribute: {}", attr)
            }
            JsonLinesError::InvalidStructure(msg) => write!(f, "Invalid structure: {}", msg),
            JsonLinesError::UnknownEntityType(t) => write!(f, "Unknown entity type: {}", t),
            JsonLinesError::MissingChild { parent, child } => {
                write!(f, "Parent {} references missing child {}", parent, child)
            }
            JsonLinesError::NoEntities => write!(f, "No entities found"),
            JsonLinesError::IoError(msg) => write!(f, "IO error: {}", msg),
        }
    }
}

impl std::error::Error for JsonLinesError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::DiagramBuilder;
    use serde_json::json;

    #[test]
    fn test_simplified_json_lines_parsing() {
        let input = r#"
{"id":"root","type":"box","padding":10,"background":"white","children":["text1"]}
{"id":"text1","type":"text","content":"Hello World","font_size":16,"color":"blue"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        assert_eq!(root_id, "root");

        parser.validate().unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let _diagram = parser.build(&root_id, &mut builder).unwrap();
    }

    #[test]
    fn test_attribute_aliases() {
        // Test that multiple attribute names work for the same concept
        let input = r#"
{"id":"box1","type":"box","padding":5,"background_color":"red","children":["text1"]}
{"id":"text1","type":"text","text":"Using text instead of content","text_color":"white"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_custom_component_access() {
        // Test that custom components get all attributes
        fn test_component(
            attrs: &Map<String, Value>,
            _builder: &mut DiagramBuilder,
        ) -> Result<DiagramTreeNode, String> {
            // Should be able to access any attribute
            assert!(attrs.contains_key("custom_prop"));
            assert!(attrs.contains_key("width"));
            assert!(attrs.contains_key("background"));

            // Return a dummy node for testing
            Ok(DiagramTreeNode::new(
                EntityType::TextShape,
                "test_component".to_string(),
            ))
        }

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("test_comp", test_component);

        let input = r#"{"id":"test1","type":"test_comp","width":200,"background":"blue","custom_prop":"value"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_streaming_parse() {
        let lines = vec![
            r#"{"id":"e1","type":"text","content":"Hello"}"#.to_string(),
            r#"{"id":"e2","type":"text","content":"World"}"#.to_string(),
            r#"{"id":"e3","type":"hstack","children":["e1","e2"]}"#.to_string(),
        ];

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_lines(lines).unwrap();
        assert_eq!(root_id, "e1");
        parser.validate().unwrap();
    }

    #[test]
    fn test_builder_api() {
        let mut builder = JsonLinesBuilder::new();

        let title = builder.text_styled("title".to_string(), "Document Title", 18.0, "blue");
        let left_text = builder.text("left_text".to_string(), "Left Panel");
        let right_text = builder.text("right_text".to_string(), "Right Panel");

        let left_box = builder.box_with("left_box".to_string(), left_text, 10.0, "lightblue");
        let right_box = builder.box_with("right_box".to_string(), right_text, 10.0, "lightgreen");

        let content = builder.hstack("content".to_string(), vec![left_box, right_box]);
        let footer = builder.text_styled("footer".to_string(), "Footer", 12.0, "gray");

        let _root = builder.vstack("root".to_string(), vec![title, content, footer]);

        let jsonl = builder.build().unwrap();
        println!("Generated JSON Lines:\n{}", jsonl);

        // Parse it back to verify
        let mut parser = JsonLinesParser::new();
        parser.parse_string(&jsonl).unwrap();
        parser.validate().unwrap();
    }

    #[test]
    fn test_complex_attributes() {
        // Test points for polyline
        let input = r#"{"id":"poly1","type":"polyline","points":[[0,0],[10,10],[20,0]],"stroke_color":"red"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_size_behaviors() {
        // Test different size behavior specifications
        let input = r#"
{"id":"box1","type":"box","width":"content","height":100,"children":["text1"]}
{"id":"text1","type":"text","content":"Auto-sized"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }
}

// Example of what an LLM might generate with the new simplified format
pub fn example_llm_generated_jsonl() -> &'static str {
    r#"{"id":"document","type":"box","padding":20,"background":"white","border_color":"gray","children":["layout"]}
{"id":"layout","type":"vstack","children":["header","body","footer"]}
{"id":"header","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"body","type":"hstack","children":["sidebar","main"]}
{"id":"sidebar","type":"box","padding":15,"background":"lightgray","children":["nav"]}
{"id":"nav","type":"vstack","children":["link1","link2","link3"]}
{"id":"link1","type":"text","content":"Home","color":"blue"}
{"id":"link2","type":"text","content":"About","color":"blue"}
{"id":"link3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":15,"background":"white","children":["content"]}
{"id":"content","type":"vstack","children":["article_title","article_body"]}
{"id":"article_title","type":"text","content":"Article Title","font_size":18}
{"id":"article_body","type":"text","content":"This is the main content of the article..."}
{"id":"footer","type":"text","content":"Copyright 2024","font_size":10,"color":"gray"}"#
}

===/src/utils.rs===
use crate::components::*;

===/src/diagram_builder.rs===
use std::{collections::HashMap, sync::Arc};

/**
 * This object encapsulates diagram creation logic.
 * Usage:
 *```rust
 * let builder = DiagramBuilder::new();
 * let group = builder.new_group(
 *   builder.new_box(builder.new_text("Hello World!"), BoxOptions{fill_color: "white".to_string(), stroke_color: "black".to_string(), stroke_width: 1.0, padding: 10.0, round_corners: false, border_radius: 0.0}),
 * );
 *
 *
 *
 */
//use TextOptions
use crate::components::*;

pub struct DiagramBuilder {
    pub measure_text: Option<fn(&str, &TextOptions) -> (Float, Float)>,
    pub entities: Vec<EntityID>,
    pub positions: HashMap<EntityID, Point>,
    pub sizes: HashMap<EntityID, Size>,
    pub entityTypes: HashMap<EntityID, EntityType>,

    // Components
    boxes: HashMap<EntityID, ShapeBox>,
    rectangles: HashMap<EntityID, ShapeRect>,
    groups: HashMap<EntityID, ShapeGroup>,
    texts: HashMap<EntityID, ShapeText>,
    textlines: HashMap<EntityID, TextLine>,
    horizontal_stacks: HashMap<EntityID, HorizontalStack>,
    vertical_stacks: HashMap<EntityID, VerticalStack>,
    ellipses: HashMap<EntityID, ShapeEllipse>,
    lines: HashMap<EntityID, ShapeLine>,
    arrows: HashMap<EntityID, ShapeArrow>,
    tables: HashMap<EntityID, Table>,
    images: HashMap<EntityID, ShapeImage>,
    polylines: HashMap<EntityID, PolyLine>,
    free_containers: HashMap<EntityID, FreeContainer>,
    arcs : HashMap<EntityID, ShapeArc>,
    pub custom_components: CustomComponentRegistry,
}

// Stores the type of entity and the index of the entity in the corresponding vector
// Used when building the diagram tree.
#[derive(Debug, Clone)]
pub struct DiagramTreeNode {
    pub entity_type: EntityType,
    // Index of the entity in the corresponding vector
    pub entity_id: EntityID,
    pub children: Vec<Box<DiagramTreeNode>>,
}

impl DiagramTreeNode {
    pub fn new(entity_type: EntityType, id: EntityID) -> DiagramTreeNode {
        DiagramTreeNode {
            entity_type,
            entity_id: id,
            children: Vec::new(),
        }
    }

    fn add_child(&mut self, child: DiagramTreeNode) {
        self.children.push(Box::new(child));
    }
}

/* New architecture (data driven)
 * We have an array of entities, each entity is an id
 * The id has 64 bits, we can use 32 bits for the type and 32 bits for the index
 * To get the type: id >> 32
 * To get the index: id & 0xFFFFFFFF
 * We have a type enum with all the types
*/

impl DiagramBuilder {
    pub fn new() -> DiagramBuilder {
        DiagramBuilder {
            entityTypes: HashMap::<EntityID, EntityType>::new(),
            measure_text: Some(|_text, _text_options| (0.0, 0.0)),
            entities: Vec::new(),
            positions: HashMap::new(),
            sizes: HashMap::new(),
            boxes: HashMap::new(),
            rectangles: HashMap::new(),
            groups: HashMap::new(),
            texts: HashMap::new(),
            textlines: HashMap::new(),
            horizontal_stacks: HashMap::new(),
            vertical_stacks: HashMap::new(),
            ellipses: HashMap::new(),
            lines: HashMap::new(),
            arrows: HashMap::new(),
            tables: HashMap::new(),
            images: HashMap::new(),
            polylines: HashMap::new(),
            free_containers: HashMap::new(),
            arcs: HashMap::new(),
            custom_components: CustomComponentRegistry::new(),
        }
    }

    /// Register a custom component with the builder
    pub fn register_custom_component<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &serde_json::Map<String, serde_json::Value>,
                &mut DiagramBuilder,
            ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
            + Send
            + Sync
            + 'static,
    {
        self.custom_components.register(component_type, factory);
    }

    /// Check if a custom component is registered
    pub fn has_custom_component(&self, component_type: &str) -> bool {
        self.custom_components.has_component(component_type)
    }

    pub fn get_custom_component_types(&self) -> Vec<&String> {
        self.custom_components.get_registered_types()
    }

    pub fn create_custom_component(
        &mut self,
        component_type: &str,
        options: &serde_json::Map<String, serde_json::Value>,
    ) -> Result<DiagramTreeNode, String> {
        if !self.custom_components.has_component(component_type) {
            return Err(format!(
                "Custom component '{}' not registered",
                component_type
            ));
        }

        let factory = { self.custom_components.get(component_type).unwrap().clone() };

        factory(options, self)
    }

    /* Create a new entity of a given type
     * Returns the id of the new entity
     * We have another array with the positions of the entities
     * in the same index. So they are fast to access
     */
    pub fn new_entity(&mut self,id : EntityID, entity_type: EntityType) -> EntityID {
        println!("Creating new entity with id {}", id);
        self.entities.push(id.clone());
        self.positions.insert(id.clone(), Point::new(0.0, 0.0));
        self.sizes.insert(id.clone(), Size::new(0.0, 0.0));
        self.entityTypes.insert(id.clone(), entity_type.clone());
        id
    }

    pub fn clear_cache(&mut self) {
        //clear entities vector
        self.entities = Vec::new();
        self.positions = HashMap::new();
        self.sizes = HashMap::new();
    }

    //set the measure_text function
    pub fn set_measure_text_fn(&mut self, measure_text: fn(&str, &TextOptions) -> (Float, Float)) {
        println!("Setting measure text function");
        self.measure_text = Option::Some(measure_text);
    }

    //get the position of an entity
    pub fn get_position(&self, entity_id: EntityID) -> (Float, Float) {
        let pos = self.positions.get(&entity_id).unwrap();
        (pos.x, pos.y)
    }

    pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        println!("Setting position of entity {} to ({}, {})", entity_id, x, y);
        let pos = self.positions.get_mut(&entity_id).unwrap();
        pos.x = x;
        pos.y = y;
    }

    //get the size of an entity
    pub fn get_size(&self, entity_id: EntityID) -> (Float, Float) {
        let size = self.sizes.get(&entity_id).unwrap();
        (size.w, size.h)
    }

    pub fn set_size(&mut self, entity_id: EntityID, width: Float, height: Float) {
        let size = self.sizes.get_mut(&entity_id).unwrap();
        size.w = width;
        size.h = height;
    }

    /**
     * Architecture note:
     * the new_element methods should only create the necessary elements
     * without calculating the position and size.
     * That will be done in the layout layer.
     */

    // Wraps an element in a box
    pub fn new_box(&mut self,id: EntityID, child: DiagramTreeNode, options: BoxOptions) -> DiagramTreeNode {
        let box_id = self.new_entity(id.clone(), EntityType::BoxShape);

        let sbox = ShapeBox::new(box_id.clone(), child.entity_id.clone(), options);
        self.boxes.insert(box_id.clone(), sbox);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::BoxShape,
            entity_id: box_id.clone(),
            children: Vec::new(),
        };
        node.children.push(Box::new(child.clone()));
        node
    }


    // Add the new_arc method
    pub fn new_arc(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let arc_id = self.new_entity(id, EntityType::ArcShape);
        let arc = ShapeArc::new(arc_id.clone(), center, radius, start_angle, end_angle, options);
        self.arcs.insert(arc_id.clone(), arc);
        DiagramTreeNode::new(EntityType::ArcShape, arc_id)
    }

    // Add convenience methods for common arc types
    pub fn new_arc_degrees(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        start_degrees: Float,
        end_degrees: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        self.new_arc(id, center, radius, start_degrees, end_degrees, options)
    }

    pub fn new_semicircle(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        facing_up: bool,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = if facing_up {
            (0.0, 180.0) // Top semicircle
        } else {
            (180.0, 360.0) // Bottom semicircle
        };
        self.new_arc(id, center, radius, start, end, options)
    }

    pub fn new_quarter_circle(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        quadrant: u8, // 1=top-right, 2=top-left, 3=bottom-left, 4=bottom-right
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = match quadrant {
            1 => (0.0, 90.0),     // Top-right
            2 => (90.0, 180.0),   // Top-left
            3 => (180.0, 270.0),  // Bottom-left
            4 => (270.0, 360.0),  // Bottom-right
            _ => (0.0, 90.0),     // Default to top-right
        };
        self.new_arc(id, center, radius, start, end, options)
    }

    // Creates a new Vertical stack.
    pub fn new_vstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        horizontal_alignment: HorizontalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::VerticalStackShape);
        let mut vstack = VerticalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            horizontal_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::VerticalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            vstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.vertical_stacks.insert(stack_id.clone(), vstack);

        node
    }

    // Creates a new Vertical stack.
    pub fn new_hstack(
        &mut self,
        id : EntityID,
        children: Vec<DiagramTreeNode>,
        vertical_alignment: VerticalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::HorizontalStackShape);
        let mut hstack = HorizontalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            vertical_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::HorizontalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            hstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.horizontal_stacks.insert(stack_id, hstack);

        node
    }

    pub fn new_rectangle(&mut self, id: EntityID, options: RectOptions) -> DiagramTreeNode {
        let rect_id = self.new_entity(id.clone(),EntityType::RectShape);
        let rect = ShapeRect::new(rect_id.clone(), options);
        self.rectangles.insert(rect_id.clone(), rect);
        DiagramTreeNode::new(EntityType::RectShape, rect_id.clone())
    }

    // Creates a new Text element
    // text: the text to display
    // options: the options for the text
    // ```rust
    // let text = session.new_text("Hello World", TextOptions::new());
    // ```
    pub fn new_text(&mut self,id : EntityID, text: &str, options: TextOptions) -> DiagramTreeNode {
        let text_id = self.new_entity(id, EntityType::TextShape);
        //create the lines
        let text_lines = textwrap::wrap(&text, options.line_width);
        let lines: Vec<EntityID> = text_lines
            .iter()
            .enumerate()
            .map(|(i, line)| {
                let line_id = format!("text-{}-line-{}", text_id.clone(), i); // Generate a new ID for each line using the index
                self.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line.to_string(),
                };
                self.textlines.insert(line_id.clone(), text_line.clone());
                line_id
            })
            .collect();

        let text = ShapeText::new(text_id.clone(), text, options, &lines);
        self.texts.insert(text_id.clone(), text);
        DiagramTreeNode::new(EntityType::TextShape, text_id)
    }

    pub fn new_line(
        &mut self,
        id : EntityID,
        start: (Float, Float),
        end: (Float, Float),
        options: LineOptions,
    ) -> DiagramTreeNode {
        let line_id = self.new_entity(id, EntityType::LineShape);
        let line = ShapeLine::new(line_id.clone(), start, end, options);
        self.lines.insert(line_id.clone(), line);
        println!("Creating new line with id {}", line_id.clone());
        DiagramTreeNode::new(EntityType::LineShape, line_id)
    }

    pub fn new_elipse(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: (Float, Float),
        options: EllipseOptions,
    ) -> DiagramTreeNode {
        let ellipse_id = self.new_entity(id, EntityType::EllipseShape);
        let ellipse = ShapeEllipse::new(ellipse_id.clone(), center, radius, options);
        self.ellipses.insert(ellipse_id.clone(), ellipse);
        DiagramTreeNode::new(EntityType::EllipseShape, ellipse_id.clone())
    }

    pub fn new_image(
        &mut self,
        id: EntityID,
        image_data: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::new(image_id.clone(), image_data.to_string(), size);
        self.images.insert(image_id.clone(), image);
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    pub fn new_image_from_file(
        &mut self,
        id: EntityID,
        file_path: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::from_file(image_id.clone(), file_path.to_string(), size);
        self.images.insert(image_id.clone(), image.clone());
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    // Creates a new Group.
    pub fn new_group(&mut self,id : EntityID, children: Vec<DiagramTreeNode>) -> DiagramTreeNode {
        let group_id = self.new_entity(id, EntityType::GroupShape);
        let mut sgroup = ShapeGroup {
            entity: group_id.clone(),
            elements: Vec::new(),
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::GroupShape,
            entity_id: group_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            sgroup.elements.push(child.entity_id.clone());
            node.add_child(child.clone())
        }

        self.groups.insert(group_id, sgroup);

        node
    }

    pub fn new_table(
        &mut self,
        id: EntityID,
        cells: Vec<DiagramTreeNode>,
        cols: usize,
        options: TableOptions,
    ) -> DiagramTreeNode {
        let mut cell_ids = Vec::new();
        for cell in &cells {
            cell_ids.push(cell.entity_id.clone());
        }
        //create entities for the col and row lines
        let mut col_lines = Vec::new();
        for i in 0..cols {
            let line_id = format!("{}-col-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(line_id.clone(), (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id.clone(), line);
            col_lines.push(line_id.clone());
        }
        let num_rows = cells.len() / cols;
        let mut row_lines = Vec::new();
        for i in 0..num_rows + 1 {
            let line_id = format!("{}-row-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(line_id.clone(), (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id.clone(), line);
            row_lines.push(line_id.clone());
        }

        //Add a rectangle for the header row
        let header_id = format!("{}-header", id);
        self.new_entity(header_id.clone(), EntityType::RectShape);
        // Create the rectangle for the header row
        let header = self.new_rectangle(header_id, RectOptions {
            fill_color: Fill::Color(options.header_fill_color.clone()),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            ..Default::default()
        });

        let table_id = format!("{}-table", id.clone());
        self.new_entity(table_id.clone(), EntityType::TableShape);
        let table = Table::new(
            table_id.clone(),
            cell_ids,
            col_lines.clone(),
            row_lines.clone(),
            cols,
            header.entity_id.clone(),
            options.clone(),
        );

        self.tables.insert(table_id.clone(), table);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::TableShape,
            entity_id: table_id.clone(),
            children: Vec::new(),
        };

        // Add the header before the cells, otherwise it can cover the cells
        node.add_child(DiagramTreeNode::new(
            EntityType::RectShape,
            header.entity_id.clone(),
        ));

        for child in cells {
            node.add_child(child)
        }

        //add the lines
        for line in col_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }
        for line in row_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }

        node
    }

    pub fn new_polyline(
        &mut self,
        id: EntityID,
        points: Vec<(Float, Float)>,
        options: LineOptions,
    ) -> DiagramTreeNode {
        self.new_entity(id.clone(), EntityType::PolyLine);
        let polyline = PolyLine::new(id.clone(), points, options);
        self.polylines.insert(id.clone(), polyline);
        DiagramTreeNode::new(EntityType::PolyLine, id.clone())
    }

    /// Creates a new FreeContainer with all children at once
    pub fn new_free_container(
        &mut self,
        id: EntityID,
        children_with_positions: Vec<(DiagramTreeNode, (Float, Float))>,
    ) -> DiagramTreeNode {
        let container_id = self.new_entity(id.clone(), EntityType::FreeContainer);  

        // Create the free container
        let mut container = FreeContainer::new(container_id.clone());

        // Create the node for the tree
        let mut node = DiagramTreeNode {
            entity_type: EntityType::FreeContainer,
            entity_id: container_id.clone(),
            children: Vec::new(),
        };

        // Add all children with their positions
        for (child, position) in children_with_positions {
            container.add_child(child.entity_id.clone(), position);
            node.add_child(child);
        }

        // Store the container
        self.free_containers.insert(container_id.clone(), container);

        node
    }

}

// element list accessors
impl DiagramBuilder {
    pub fn get_text(&self, id: EntityID) -> &ShapeText {
        &self.texts[&id]
    }

    pub fn get_group(&self, id: EntityID) -> &ShapeGroup {
        &self.groups[&id]
    }

    pub fn get_horizontal_stack(&self, id: EntityID) -> &HorizontalStack {
        &self.horizontal_stacks[&id]
    }

    pub fn get_vertical_stack(&self, id: EntityID) -> &VerticalStack {
        &self.vertical_stacks[&id]
    }

    pub fn get_ellipse(&self, id: EntityID) -> &ShapeEllipse {
        &self.ellipses[&id]
    }

    pub fn get_line(&self, id: EntityID) -> &ShapeLine {
        &self.lines[&id]
    }

    pub fn get_rectangle(&self, id: EntityID) -> &ShapeRect {
        &self.rectangles[&id]
    }

    pub fn get_text_line(&self, id: EntityID) -> &TextLine {
        &self.textlines[&id]
    }

    pub fn get_arrow(&self, id: EntityID) -> &ShapeArrow {
        &self.arrows[&id]
    }

    pub fn get_table(&self, id: EntityID) -> &Table {
        &self.tables[&id]
    }

    pub fn get_image(&self, id: EntityID) -> &ShapeImage {
        &self.images[&id]
    }

    pub fn get_box(&self, id: EntityID) -> &ShapeBox {
        &self.boxes[&id]
    }

    pub fn get_polyline(&self, id: EntityID) -> &PolyLine {
        &self.polylines[&id]
    }

    pub fn get_free_container(&self, id: EntityID) -> &FreeContainer {
        &self.free_containers[&id]
    }

    pub fn get_free_container_mut(&mut self, id: EntityID) -> &mut FreeContainer {
        self.free_containers.get_mut(&id).unwrap()
    }

     pub fn get_arc(&self, id: EntityID) -> &ShapeArc {
        &self.arcs[&id]
    }
    

    pub fn get_custom_component(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &serde_json::Map<String, serde_json::Value>,
                    &mut DiagramBuilder,
                ) -> Result<DiagramTreeNode, String>
                + Send
                + Sync,
        >,
    > {
        self.custom_components.get(component_type)
    }
}

//test
#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_session() {
        let mut session = DiagramBuilder::new();

        session.set_measure_text_fn(|text, text_options| {
            let textW: Float = text.len() as Float * text_options.font_size as Float;

            (textW, text_options.font_size.into())
        });
        let (w, h) = session.measure_text.unwrap()(
            "hello",
            &TextOptions {
                font_size: 12.0,
                ..Default::default()
            },
        );
        assert_eq!(w, 60.0);
        assert_eq!(h, 12.0);
    }
}

//Component registration tests
#[cfg(test)]
mod component_registration_tests {
    use serde_json::{json, Map, Value};

    use super::*;

    /// Custom Component 1: Badge
    /// Creates a rounded pill-shaped element with text
    fn create_badge_component(
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, String> {
        println!("🏷️  Creating badge component with attrs: {:?}", attrs);

        // Extract attributes
        let text = get_string_attr(attrs, "text", "Badge");
        let background = get_string_attr(attrs, "background", "blue");
        let color = get_string_attr(attrs, "color", "white");
        let font_size = get_float_attr(attrs, "font_size", 12.0);
        let padding = get_float_attr(attrs, "padding", 8.0);

        // Create text element
        let text_options = TextOptions {
            font_family: "Arial".to_string(),
            font_size,
            text_color: color,
            line_width: 200,
            line_spacing: 0.0,
        };
        let text_node = builder.new_text("text".to_string(), &text, text_options);

        // Wrap in rounded box
        let box_options = BoxOptions {
            fill_color: Fill::Color(background),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            padding,
            border_radius: font_size,               // Make it pill-shaped
            width_behavior: SizeBehavior::Content,  // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
        };
        let badge = builder.new_box("container".to_string(), text_node, box_options);

        println!("✅ Badge '{}' created successfully", text);
        Ok(badge)
    }

    // Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
    fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
        let badge_node = result.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::BoxShape);
        assert!(builder.has_custom_component("badge"));
        let badge = builder.get_box(badge_node.entity_id);
        assert_eq!(badge.box_options.fill_color, Fill::Color("blue".to_string()));
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 1);
        assert!(builder.has_custom_component("badge"));
    }
}


===/svg_renderer.txt===
===/Cargo.toml===
[package]
name = "svg_renderer"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
volare_engine_layout = { path = "../volare_engine_layout" }
base64 = "0.21"

[lib]
name = "svg_renderer"
path = "src/lib.rs"
===/src/lib.rs===
use std::io::Write;
use volare_engine_layout::diagram_builder::DiagramTreeNode;
use volare_engine_layout::*;
use volare_engine_layout::FreeContainer;
//use error
use std::io::Error;

pub struct SVGRenderer;

impl<W: Write> Renderer<W> for SVGRenderer {
    
 fn render(
    &self,
    session: &DiagramBuilder,
    diagram_node: &DiagramTreeNode,
    stream: &mut W,
) -> Result<(), RendererError> {
    let mut svg = String::new();
    let root_size = session.get_size(diagram_node.entity_id.clone());
    let root_pos = session.get_position(diagram_node.entity_id.clone());

    svg.push_str(&format!(
        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>"
    ));

    svg.push_str(&format!(
        r#"<svg width="{}" height="{}" viewBox="{} {} {} {}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">"#,
        root_size.0, root_size.1,
        root_pos.0, root_pos.1, root_size.0, root_size.1
    ));

    svg.push_str(render_node(diagram_node, session).as_str());
    //close svg tag
    svg.push_str("</svg>");
    svg.push_str("\n");
    
    // Properly handle the result from writing to the stream
    stream.write_all(svg.as_bytes())
        .map_err(|e| RendererError::new(&e.to_string()))?;
    
    Ok(())
}
}



// Render a node and its children
fn render_node<'a>(node: &DiagramTreeNode, session: &DiagramBuilder) -> String {
    let mut svg = String::new();

    let entity_id = node.entity_id.clone();
    

    match node.entity_type {
        EntityType::GroupShape => {
            render_group(session, &mut svg, entity_id,  node);
        }
        EntityType::BoxShape => {
            render_box(session, &mut svg, entity_id, node);
        }
        EntityType::TextShape => {
            render_text(session, &mut svg, entity_id, node);
        }
        EntityType::VerticalStackShape => {
            render_vertical_stack(session, &mut svg, entity_id, node);
        }
        EntityType::HorizontalStackShape => {
            render_horizontal_stack(session, &mut svg, entity_id, node);
        }
        EntityType::LineShape => {
            render_line(session, &mut svg, entity_id, node);
        }
        EntityType::ArrowShape => {
            render_arrow(session, &mut svg, entity_id, node);
        }
        EntityType::EllipseShape => {
            render_ellipse(session, &mut svg, entity_id, node);
        }
        //table
        EntityType::TableShape => {
            render_table(session, &mut svg, entity_id, node);
        }
        //Image
        EntityType::ImageShape => {
            render_image(session, &mut svg, entity_id, node);
        }
        
        EntityType:: PolyLine => {
            render_polyline(session, &mut svg, entity_id, node);
        }
        
        EntityType::FreeContainer => {
            render_free_container(session, &mut svg, entity_id, node);
        }

        EntityType::RectShape => {
            render_rectangle(session, &mut svg, entity_id, node);
        }

        EntityType::ArcShape => {
            render_arc(session, &mut svg, entity_id, node);
        }

        _ => {}
        
    }

    svg
}


fn render_polyline(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let polyline_shape = session.get_polyline(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());

    // Convert points to a space-separated string
    let points_str = polyline_shape.points.iter()
        .map(|&(x, y)| format!("{},{}", x, y))
        .collect::<Vec<_>>().join(" ");

    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    svg.push_str(&format!(r#"<polyline points="{}" stroke="{}" stroke-width="{}" fill="none" />"#,
        points_str,
        polyline_shape.line_options.stroke_color,
        polyline_shape.line_options.stroke_width));
    svg.push_str("</g>");
}

fn render_free_container(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let container = session.get_free_container(entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    
    // Open a group for the container with the correct position
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    
    // If there's a background color, draw a rectangle with it
    if let Some(bg_color) = &container.background_color {
        svg.push_str(&format!(
            r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" "#,
            size.0, size.1, bg_color
        ));
        
        // Add border if specified
        if let Some(border_color) = &container.border_color {
            if container.border_width > 0.0 {
                svg.push_str(&format!(
                    r#"stroke="{}" stroke-width="{}" "#,
                    border_color, container.border_width
                ));
            }
        }
        
        svg.push_str("/>");
    } 
    // If there's only a border but no background, draw just the outline
    else if let Some(border_color) = &container.border_color {
        if container.border_width > 0.0 {
            svg.push_str(&format!(
                r#"<rect x="0" y="0" width="{}" height="{}" fill="none" stroke="{}" stroke-width="{}" />"#,
                size.0, size.1, border_color, container.border_width
            ));
        }
    }
    
    // Render children
    for child in node.children.iter() {
        svg.push_str(render_node(child, session).as_str());
    }
    
    // Close the container group
    svg.push_str("</g>");
}


fn render_image(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let image_shape = session.get_image(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    
    // Determine the image source
    let image_src = if let Some(file_path) = &image_shape.file_path {
        // For file-based images, we'll embed them as data URLs in the SVG
        // We need to read the file, encode it to base64, and create a data URL
        match read_image_file_as_data_url(file_path) {
            Ok(data_url) => data_url,
            Err(err) => {
                eprintln!("Error loading image from file '{}': {}", file_path, err);
                // Fallback to a placeholder for errors
                "data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%3E%3Crect%20width%3D%22100%22%20height%3D%22100%22%20fill%3D%22%23ddd%22%2F%3E%3Ctext%20x%3D%2250%22%20y%3D%2250%22%20font-family%3D%22sans-serif%22%20font-size%3D%2220%22%20text-anchor%3D%22middle%22%20alignment-baseline%3D%22middle%22%3EImage%20Error%3C%2Ftext%3E%3C%2Fsvg%3E".to_string()
            }
        }
    } else {
        // For base64 images, use the stored image data
        // If it's already a data URL, use it as-is
        image_shape.image.clone()
    };
    
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    
    // Add the SVG image element with the appropriate source
    svg.push_str(&format!(r#"<image x="0" y="0" width="{}" height="{}" xlink:href="{}" />"#,
        size.0, 
        size.1, 
        image_src));
    
    svg.push_str("</g>");
}

// Helper function to read an image file and convert it to a data URL
fn read_image_file_as_data_url(file_path: &str) -> Result<String, std::io::Error> {
    use std::fs::File;
    use std::io::Read;
    use base64::engine::general_purpose::STANDARD as BASE64;
    use base64::Engine;
    use std::path::Path;
    
    // Read the file
    let mut file = File::open(file_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    
    // Determine mime type based on file extension
    let mime_type = match Path::new(file_path).extension().and_then(|ext| ext.to_str()) {
        Some("png") => "image/png",
        Some("jpg") | Some("jpeg") => "image/jpeg",
        Some("svg") => "image/svg+xml",
        Some("gif") => "image/gif",
        Some("webp") => "image/webp",
        _ => "application/octet-stream", // Default mime type
    };
    
    // Encode as base64 and create data URL
    let base64_data = BASE64.encode(&buffer);
    let data_url = format!("data:{};base64,{}", mime_type, base64_data);
    
    Ok(data_url)
}

fn render_line(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let line_shape = session.get_line(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    svg.push_str(&format!(r#"<line x1="0" y1="0" x2="{}" y2="{}" stroke="{}" stroke-width="{}" />"#,
     size.0, 
     size.1, 
     line_shape.line_options.stroke_color,
     line_shape.line_options.stroke_width));
    svg.push_str("</g>");
}

fn render_rectangle(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let rect_shape = session.get_rectangle(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    svg.push_str(&format!(r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" rx="{}" ry="{}" />"#,
     size.0, 
     size.1, 
     rect_shape.rect_options.fill_color,
     rect_shape.rect_options.stroke_color,
     rect_shape.rect_options.stroke_width,
     rect_shape.rect_options.border_radius,
     rect_shape.rect_options.border_radius));
    svg.push_str("</g>");
}

fn render_arrow(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let arrow_shape = session.get_arrow(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    svg.push_str(&format!(r#"<line x1="0" y1="0" x2="{}" y2="{}" stroke="{}" stroke-width="{}" />"#,
     size.0, 
     size.1, 
     arrow_shape.arrow_options.stroke_color,
     arrow_shape.arrow_options.stroke_width));
    //TODO: paint arrow head
    svg.push_str("</g>");
}

fn render_ellipse(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let ellipse_shape = session.get_ellipse(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    svg.push_str(&format!(r#"<ellipse cx="{}" cy="{}" rx="{}" ry="{}" stroke="{}" stroke-width="{}" fill="{}" />"#,
     size.0/2.0, 
     size.1/2.0, 
     size.0/2.0, 
     size.1/2.0, 
     ellipse_shape.ellipse_options.stroke_color,
     ellipse_shape.ellipse_options.stroke_width,
     ellipse_shape.ellipse_options.fill_color));
    svg.push_str("</g>");
}


fn render_group(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID,  node: &DiagramTreeNode ) {
  
    let pos = session.get_position(entity_id);
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    for child in node.children.iter() {
        print!("render_node recursive");
        svg.push_str(render_node(child, session).as_str());
    }
    svg.push_str("</g>");
}

fn render_table(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let table_shape = session.get_table(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    
    let header_size = session.get_size(table_shape.header_rect.clone());


    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
     //render container rect element
    svg.push_str(&format!(r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" />"#,
        size.0, 
        size.1, 
        table_shape.table_options.fill_color,
        table_shape.table_options.border_color,
        table_shape.table_options.border_width
    ));

    // render header, cells, lines, etc. Should have been added to the node
    for child in node.children.iter() {
        svg.push_str(render_node(child, session).as_str());
    }
    svg.push_str("</g>");
}


fn render_box(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let size = session.get_size(entity_id.clone());
    let box_shape = session.get_box(node.entity_id.clone());
   
    let pos = session.get_position(entity_id.clone());
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));
    
    // svg.push_str(&format!(r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" rx="{}" ry="{}" />"#,
    //  size.0, 
    //  size.1, 
    //  box_shape.box_options.fill_color,
    //  box_shape.box_options.stroke_color,
    //  box_shape.box_options.stroke_width,
    //  box_shape.box_options.border_radius,
    //  box_shape.box_options.border_radius));

    match &box_shape.box_options.fill_color {
        Fill::Color(color) => {
            svg.push_str(&format!(r#"<rect x="0" y="0" width="{}" height="{}" fill="{}" stroke="{}" stroke-width="{}" rx="{}" ry="{}" />"#,
            size.0, 
            size.1, 
            color,
            box_shape.box_options.stroke_color,
            box_shape.box_options.stroke_width,
            box_shape.box_options.border_radius,
            box_shape.box_options.border_radius));
        }
        ,
        Fill::LinearGradient(_linearGrad) => {
            todo!()
        },
        Fill::RadialGradient(_) => todo!(),
    }
     if node.children.len() > 0 {
        // we only render the first child for now
        // The layout phase already positions the wrapped entity with padding, so no need to add extra translate
        let first_child = &node.children[0];
        svg.push_str(render_node(&first_child, session).as_str());
        
    }
    svg.push_str("</g>");
}

fn render_text(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let text_shape = session.get_text(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    let size = session.get_size(entity_id.clone());
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" data-debug="{}" >"#,
        pos.0, pos.1,
        format!("size: {}, {}, pos: {}, {}", 
            size.0, size.1,
            pos.0, pos.1)
    ));

    //render parent text container
    svg.push_str(&format!(r#"<text x="0" y="{}" fill="{}" font-size="{}px" font-family="{}" >"#,
        0,
        text_shape.text_options.text_color,
        text_shape.text_options.font_size,
        text_shape.text_options.font_family));
   
    //render lines
    for line_id in text_shape.lines.iter() {
        let line = session.get_text_line(line_id.clone());
        let pos = session.get_position(line.entity.clone());
        let lineSize = session.get_size(line.entity.clone());
        svg.push_str(&format!(r#"<tspan x="{}" y="{}" fill="{}" font-size="{}px" font-family="{}" alignment-baseline="hanging" data-debug="{}" >"#,
        pos.0,
        pos.1,
        text_shape.text_options.text_color,
        text_shape.text_options.font_size,
        text_shape.text_options.font_family,
        //debug info
        format!("size: {}, {}, pos: {}, {}",
            lineSize.0, lineSize.1,
            pos.0, pos.1)
        ));
        let txt = if line.text.trim().is_empty() {
            "&#8203;".to_string()  // Create a new String directly
        } else {
            line.text.clone()  // Clone the original
        };
        println!("text:::");
        println!("text {}", txt);
        svg.push_str(&txt);
        svg.push_str("</tspan>");
    }
    svg.push_str("</text>");
    svg.push_str("</g>");
}

fn render_vertical_stack(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let pos = session.get_position(entity_id);
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));

    //render items
    for child in node.children.iter() {
        svg.push_str(render_node(child, session).as_str())
    }
    svg.push_str("</g>");
}

fn render_horizontal_stack(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    let pos = session.get_position(entity_id);
    svg.push_str(&format!(
        r#"<g transform="translate({} {})" >"#,
        pos.0, pos.1
    ));

    //render items
    for child in node.children.iter() {
        svg.push_str(render_node(child, session).as_str())
    }
    svg.push_str("</g>");
}


// Add this function to render arcs
fn render_arc(session: &DiagramBuilder, svg: &mut String, entity_id: EntityID, node: &DiagramTreeNode) {
    use std::f32::consts::PI;
    
    let arc_shape = session.get_arc(node.entity_id.clone());
    let pos = session.get_position(entity_id.clone());
    let size = session.get_size(entity_id.clone());
    
    // Get normalized angles
    let (start_angle, end_angle) = arc_shape.normalize_angles();
    let sweep = arc_shape.angle_sweep();
    
    // Convert to radians for calculations
    let start_rad = start_angle * PI / 180.0;
    let end_rad = end_angle * PI / 180.0;
    
    // Calculate start and end points
    let start_x = arc_shape.center.0 + arc_shape.radius * start_rad.cos();
    let start_y = arc_shape.center.1 + arc_shape.radius * start_rad.sin();
    let end_x = arc_shape.center.0 + arc_shape.radius * end_rad.cos();
    let end_y = arc_shape.center.1 + arc_shape.radius * end_rad.sin();
    
    // Determine if this is a large arc (> 180 degrees)
    let large_arc_flag = if sweep > 180.0 { 1 } else { 0 };
    
    // Always sweep in positive direction (clockwise in SVG coordinates)
    let sweep_flag = 1;
    
    svg.push_str(&format!(
        r#"<g transform="translate({} {})">"#,
        pos.0, pos.1
    ));
    
    if arc_shape.arc_options.filled {
        // For filled arcs, create a path that includes the center (pie slice)
        svg.push_str(&format!(
            r#"<path d="M {} {} L {} {} A {} {} 0 {} {} {} {} Z" fill="{}" stroke="{}" stroke-width="{}" />"#,
            arc_shape.center.0 - pos.0, arc_shape.center.1 - pos.1, // Move to center
            start_x - pos.0, start_y - pos.1, // Line to start point
            arc_shape.radius, arc_shape.radius, // Arc radii
            large_arc_flag, sweep_flag, // Arc flags
            end_x - pos.0, end_y - pos.1, // Arc end point
            arc_shape.arc_options.fill_color,
            arc_shape.arc_options.stroke_color,
            arc_shape.arc_options.stroke_width
        ));
    } else {
        // For unfilled arcs, just draw the arc curve
        svg.push_str(&format!(
            r#"<path d="M {} {} A {} {} 0 {} {} {} {}" fill="none" stroke="{}" stroke-width="{}" />"#,
            start_x - pos.0, start_y - pos.1, // Move to start point
            arc_shape.radius, arc_shape.radius, // Arc radii
            large_arc_flag, sweep_flag, // Arc flags
            end_x - pos.0, end_y - pos.1, // Arc end point
            arc_shape.arc_options.stroke_color,
            arc_shape.arc_options.stroke_width
        ));
    }
    
    svg.push_str("</g>");
}


#[test]
fn test_render_arc() {
    let mut session = DiagramBuilder::new();
    let options = ArcOptions {
        fill_color: "blue".to_string(),
        stroke_color: "black".to_string(),
        stroke_width: 2.0,
        filled: false,
    };
    
    let arc = session.new_arc(
        "arc".to_string(),
        (50.0, 50.0), // center
        30.0,         // radius
        0.0,          // start angle
        90.0,         // end angle
        options
    );
    
    let node = render_node(&arc, &session);


    assertIsSameSVG(
        &node,
        r##"<g transform="translate(0 0)">
            <path d="M 80 50 A 30 30 0 0 1 50 80" fill="none" stroke="black" stroke-width="2" />
        </g>"##
    );
    assert!(node.contains("stroke=\"black\""));
}

//test that groups are rendered correctly
#[test]
fn test_render_group() {
    let mut session = DiagramBuilder::new();
    let group = session.new_group(
        "group".to_string(),
        Vec::new());
    let node = render_node(&group, &session);
    assert_eq!(node, r#"<g transform="translate(0 0)" ></g>"#);
}

//test that BoxShape with wrapped group is rendered correctly
#[test]
fn test_render_box_with_rect_in_group() {
    let mut session = DiagramBuilder::new();

    let rect = session.new_rectangle(
        "rect1".to_string(),

        RectOptions {
         width_behavior: SizeBehavior::Fixed(100.0),
         height_behavior: SizeBehavior::Fixed(50.0),
         fill_color:Fill::Color("black".to_string()),
         stroke_color: String::from("magenta"),
         stroke_width: 1.0, border_radius: 1.0 });

    let group = session.new_group(
        "group".to_string(),
        vec![rect]);

    let box_ = session.new_box(
        "box_".to_string(),
        group, BoxOptions{
        fill_color:Fill::Color("white".to_string()),
        stroke_color: "black".to_string(),
        stroke_width: 1.0,
        padding: 2.0,
        border_radius: 0.0,
        width_behavior: SizeBehavior::Content, // 100 + 2*2 (padding)
        height_behavior: SizeBehavior::Content, // 50 + 2
    });

    layout_tree_node(&mut session, &box_);

    let node = render_node(&box_, &session);
    assertIsSameSVG(&node, r#"
    <g transform="translate(0 0)" >
        <rect x="0" y="0" width="104" height="54" fill="white" stroke="black" stroke-width="1" rx="0" ry="0" />
            <g transform="translate(2 2)" >
                <g transform="translate(0 0)">
                    <rect x="0" y="0" width="100" height="50" fill="black" stroke="magenta" stroke-width="1" rx="1" ry="1" />
                </g>
            </g>
     </g>"#);
}

fn assertIsSameSVG(a: &str, b: &str) {
    // Normalize whitespace and compare
    let strA = a.chars().filter(|c| !c.is_whitespace()).collect::<String>();
    let strB = b.chars().filter(|c| !c.is_whitespace()).collect::<String>();
    assert_eq!(strA.replace('\n', "").replace('\r', ""),  strB.replace('\n', "").replace('\r', ""));
}

//test line
#[test]
fn test_render_line() {
    let options = LineOptions{
        stroke_color: "black".to_string(),
        stroke_width: 1.0,
    };
    let mut session = DiagramBuilder::new();
    let line = session.new_line(
        "line".to_string(),
        (0.0,0.0),(0.0,0.0),options);
    
    let node = render_node(&line, &session);
    assert_eq!(
        node,
        r#"<g transform="translate(0 0)" ><line x1="0" y1="0" x2="0" y2="0" stroke="black" stroke-width="1" /></g>"#
    );
}

//test eclipse
#[test]
fn test_render_ellipse() {
    let options = EllipseOptions{
        fill_color: "white".to_string(),
        stroke_color: "black".to_string(),
        stroke_width: 1.0,
    };
    let mut session = DiagramBuilder::new();
    let ellipse = session.new_elipse(
        "ellipse".to_string(),
        (0.0, 0.0), (0.0, 0.0), options);
    
    let node = render_node(&ellipse, &session);
    assertIsSameSVG(
        &node,
        r#"
        <g transform="translate(0 0)" >
            <ellipse cx="0" cy="0" rx="0" ry="0" stroke="black" stroke-width="1" fill="white" />
        </g>"#
    );
}

#[test]
fn test_render_box_rounded_corners_with_group() {
    let mut session = DiagramBuilder::new();
    let group = session.new_group(
        "group".to_string(),
        Vec::new());
    let box_ = session.new_box(
        "box".to_string(),
        group, BoxOptions{
        fill_color: Fill::Color("white".to_string()),
        stroke_color: "black".to_string(),
        stroke_width: 1.0,
        padding: 0.0,
        border_radius: 5.5,
        width_behavior: SizeBehavior::Content, // 0 + 2*0 (padding)
        height_behavior: SizeBehavior::Content, // 0 + 2*0  
    });
    let node = render_node(&box_, &session);
    assertIsSameSVG(
        &node,
        r#"<g transform="translate(0 0)" >
            <rect x="0" y="0" width="0" height="0" fill="white" stroke="black" stroke-width="1" rx="5.5" ry="5.5" />
            <g transform="translate(0 0)" >
            </g>
        </g>"#
    );
}



