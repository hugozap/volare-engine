===/Cargo.toml===
[package]
name = "demo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

#add dep to crate in local workspace
volare_engine_layout = { path = "../volare_engine_layout" }
svg_renderer = { path = "../svg_renderer" }
resvg = "0.25.0"
rusttype = "0.9.3"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
uuid = { version = "1.8", features = ["v4"] }

[[bin]]
name = "textdemo"
path = "src/bin/text.rs"

[[bin]]
name = "demo"
path = "src/main.rs"

[[bin]]
name = "patterns"
path = "src/bin/patterns.rs"

[[bin]]
name = "constraints"
path = "src/bin/constraints.rs"


===/.gitignore===
/target

===/src/measure_text.rs===
use rusttype::{point, Font, Scale};
use volare_engine_layout::{Float, TextOptions};

/**
 * Measure text using SVG character advance method
 * This method calculates the width based on the advance width of each character,
 * taking into account kerning between characters.
 * It provides a more accurate width for SVG rendering, especially for variable-width fonts.
 */
pub fn measure_text_svg_character_advance(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);

    let mut total_width = 0.0;
    let mut prev_glyph_id = None;

    for ch in text.chars() {
        let glyph = font.glyph(ch).scaled(scale);

        // Use horizontal advance instead of bounding box
        let advance_width = glyph.h_metrics().advance_width;

        // Add kerning if available
        if let Some(prev_id) = prev_glyph_id {
            total_width += font.pair_kerning(scale, prev_id, glyph.id());
        }

        total_width += advance_width;
        prev_glyph_id = Some(glyph.id());
    }

    // Use font metrics for height instead of glyph bounds
    let v_metrics = font.v_metrics(scale);
    let height = v_metrics.ascent - v_metrics.descent;

    (total_width as Float, height as Float)
}

// tight measurement that accounts for actual glyph positioning
// Used for PNG rendering
pub fn measure_text_ultra_tight(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);
    let v_metrics = font.v_metrics(scale);

    if text.is_empty() {
        return (0.0, (v_metrics.ascent - v_metrics.descent) as Float);
    }

    // Use rusttype's layout function which handles everything correctly
    // TODO: Needs unicode normalization for proper glyph handling, see comments of `layout` function
    let glyphs: Vec<_> = font.layout(text, scale, point(0.0, 0.0)).collect();

    // Find the actual visual bounds
    let mut min_x = f32::INFINITY;
    let mut max_x = f32::NEG_INFINITY;

    for glyph in &glyphs {
        if let Some(bb) = glyph.pixel_bounding_box() {
            min_x = min_x.min(bb.min.x as f32);
            max_x = max_x.max(bb.max.x as f32);
        }
    }

    let width = if min_x.is_finite() && max_x.is_finite() {
        max_x - min_x // Pure visual width, no padding
    } else {
        // Fallback for whitespace
        glyphs
            .iter()
            .map(|g| g.unpositioned().h_metrics().advance_width)
            .sum()
    };

    let height = v_metrics.ascent - v_metrics.descent;

    println!("ULTRA TIGHT: '{}' -> {:.2}x{:.2}", text, width, height);
    (width as Float, height as Float)
}

===/src/bin/arrows-ellipses.rs===
// src/bin/arrows_ellipses_demo.rs
// Demo program to test arrows and ellipses positioning

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üèπ Arrows and Ellipses Demo Starting...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("arrows_ellipses_demo");
    std::fs::create_dir_all(&output_dir)?;

    // Generate various demos to test positioning
    generate_basic_arrows_demo(&output_dir)?;
    generate_basic_ellipses_demo(&output_dir)?;
    generate_mixed_positioning_demo(&output_dir)?;
    generate_free_container_test(&output_dir)?;

    println!("\n‚úÖ All arrows and ellipses demos generated successfully!");
    println!("üìÅ Files saved in: {}", output_dir.display());

    Ok(())
}

// Demo 1: Basic Arrows in Different Layouts
fn generate_basic_arrows_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","arrows_hstack","arrows_free"],"h_align":"center"}
{"id":"title","type":"text","content":"üèπ Arrow Positioning Test","font_size":24,"color":"darkblue"}
{"id":"arrows_hstack","type":"vstack","children":["hstack_label","hstack_arrows"],"h_align":"center"}
{"id":"hstack_label","type":"text","content":"Arrows in HStack","font_size":16,"color":"#333"}
{"id":"hstack_arrows","type":"hstack","children":["arrow1","arrow2","arrow3"],"v_align":"center"}
{"id":"arrow1","type":"line","start_x":0,"start_y":0,"end_x":50,"end_y":0,"stroke_color":"red","stroke_width":3}
{"id":"arrow2","type":"line","start_x":0,"start_y":0,"end_x":0,"end_y":50,"stroke_color":"green","stroke_width":3}
{"id":"arrow3","type":"line","start_x":0,"start_y":0,"end_x":50,"end_y":50,"stroke_color":"blue","stroke_width":3}
{"id":"arrows_free","type":"vstack","children":["free_label","free_container"],"h_align":"center"}
{"id":"free_label","type":"text","content":"Arrows in Free Container","font_size":16,"color":"#333"}
{"id":"free_container","type":"free_container","width":300,"height":200,"children":["arrow4","arrow5","arrow6"]}
{"id":"arrow4","type":"line","start_x":50,"start_y":50,"end_x":100,"end_y":50,"stroke_color":"red","stroke_width":3,"x":0,"y":0}
{"id":"arrow5","type":"line","start_x":150,"start_y":50,"end_x":150,"end_y":100,"stroke_color":"green","stroke_width":3,"x":0,"y":0}
{"id":"arrow6","type":"line","start_x":200,"start_y":50,"end_x":250,"end_y":100,"stroke_color":"blue","stroke_width":3,"x":0,"y":0}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_basic_arrows.svg"), "Basic Arrows Test")
}

// Demo 2: Basic Ellipses in Different Layouts
//TODO: remove "cx" and "cy"
fn generate_basic_ellipses_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","ellipses_hstack","ellipses_free"],"h_align":"center"}
{"id":"title","type":"text","content":"‚≠ï Ellipse Positioning Test","font_size":24,"color":"darkgreen"}
{"id":"ellipses_hstack","type":"vstack","children":["hstack_label","hstack_ellipses"],"h_align":"center"}
{"id":"hstack_label","type":"text","content":"Ellipses in HStack","font_size":16,"color":"#333"}
{"id":"hstack_ellipses","type":"hstack","children":["ellipse1","ellipse2","ellipse3"],"v_align":"center"}
{"id":"ellipse1","type":"ellipse","cx":20,"cy":20,"rx":20,"ry":20,"fill":"red","stroke":"darkred","stroke_width":2}
{"id":"ellipse2","type":"ellipse","cx":15,"cy":30,"rx":15,"ry":30,"fill":"green","stroke":"darkgreen","stroke_width":2}
{"id":"ellipse3","type":"ellipse","cx":30,"cy":15,"rx":30,"ry":15,"fill":"blue","stroke":"darkblue","stroke_width":2}
{"id":"ellipses_free","type":"vstack","children":["free_label","free_ellipses_container"],"h_align":"center"}
{"id":"free_label","type":"text","content":"Ellipses in Free Container","font_size":16,"color":"#333"}
{"id":"free_ellipses_container","type":"free_container","width":300,"height":200,"children":["ellipse4","ellipse5","ellipse6"]}
{"id":"ellipse4","type":"ellipse","cx":30,"cy":30,"rx":25,"ry":25,"fill":"red","stroke":"darkred","stroke_width":2,"x":20,"y":20}
{"id":"ellipse5","type":"ellipse","cx":30,"cy":30,"rx":20,"ry":35,"fill":"green","stroke":"darkgreen","stroke_width":2,"x":120,"y":20}
{"id":"ellipse6","type":"ellipse","cx":30,"cy":30,"rx":35,"ry":20,"fill":"blue","stroke":"darkblue","stroke_width":2,"x":220,"y":20}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_basic_ellipses.svg"), "Basic Ellipses Test")
}

// Demo 3: Mixed Positioning - Arrows and Ellipses Together
fn generate_mixed_positioning_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","mixed_demo"],"h_align":"center"}
{"id":"title","type":"text","content":"Mixed Arrows & Ellipses","font_size":24,"color":"darkorange"}
{"id":"mixed_demo","type":"free_container","width":400,"height":300,"children":["target1","target2","target3","arrow_to_1","arrow_to_2","arrow_to_3","labels"]}
{"id":"target1","type":"ellipse","cx":25,"cy":25,"rx":20,"ry":20,"fill":"red","stroke":"darkred","stroke_width":3,"x":50,"y":50}
{"id":"target2","type":"ellipse","cx":25,"cy":25,"rx":20,"ry":20,"fill":"green","stroke":"darkgreen","stroke_width":3,"x":200,"y":50}
{"id":"target3","type":"ellipse","cx":25,"cy":25,"rx":20,"ry":20,"fill":"blue","stroke":"darkblue","stroke_width":3,"x":125,"y":150}
{"id":"arrow_to_1","type":"line","start_x":10,"start_y":10,"end_x":65,"end_y":65,"stroke_color":"black","stroke_width":2,"x":10,"y":10}
{"id":"arrow_to_2","type":"line","start_x":10,"start_y":10,"end_x":75,"end_y":65,"stroke_color":"black","stroke_width":2,"x":150,"y":10}
{"id":"arrow_to_3","type":"line","start_x":10,"start_y":10,"end_x":40,"end_y":65,"stroke_color":"black","stroke_width":2,"x":100,"y":100}
{"id":"labels","type":"vstack","children":["label1","label2"],"h_align":"left","x":50,"y":250}
{"id":"label1","type":"text","content":"‚Ä¢ Arrows should point toward ellipses","font_size":12,"color":"#333"}
{"id":"label2","type":"text","content":"‚Ä¢ If positioning works, arrows point to targets","font_size":12,"color":"#333"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_mixed_positioning.svg"), "Mixed Arrows & Ellipses")
}

// Demo 4: Free Container Edge Cases
fn generate_free_container_test(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","edge_cases"],"h_align":"center"}
{"id":"title","type":"text","content":"üîç Edge Case Testing","font_size":24,"color":"darkviolet"}
{"id":"edge_cases","type":"free_container","width":500,"height":400,"children":["corner_ellipses","center_cross","coordinate_test"]}
{"id":"corner_ellipses","type":"free_container","width":200,"height":200,"children":["tl_ellipse","tr_ellipse","bl_ellipse","br_ellipse"],"x":20,"y":20}
{"id":"tl_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"red","stroke":"darkred","stroke_width":1,"x":0,"y":0}
{"id":"tr_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"green","stroke":"darkgreen","stroke_width":1,"x":170,"y":0}
{"id":"bl_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"blue","stroke":"darkblue","stroke_width":1,"x":0,"y":170}
{"id":"br_ellipse","type":"ellipse","cx":15,"cy":15,"rx":10,"ry":10,"fill":"orange","stroke":"darkorange","stroke_width":1,"x":170,"y":170}
{"id":"center_cross","type":"free_container","width":100,"height":100,"children":["h_line","v_line","center_dot"],"x":250,"y":50}
{"id":"h_line","type":"line","start_x":0,"start_y":50,"end_x":100,"end_y":50,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"v_line","type":"line","start_x":50,"start_y":0,"end_x":50,"end_y":100,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"center_dot","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red","stroke":"darkred","stroke_width":1,"x":45,"y":45}
{"id":"coordinate_test","type":"vstack","children":["coord_label","coord_details"],"h_align":"left","x":50,"y":300}
{"id":"coord_label","type":"text","content":"Coordinate System Test:","font_size":14,"color":"#333"}
{"id":"coord_details","type":"vstack","children":["detail1","detail2","detail3"],"h_align":"left"}
{"id":"detail1","type":"text","content":"‚Ä¢ Corner ellipses should be at actual corners","font_size":11,"color":"#666"}
{"id":"detail2","type":"text","content":"‚Ä¢ Cross lines should intersect at red dot center","font_size":11,"color":"#666"}
{"id":"detail3","type":"text","content":"‚Ä¢ All shapes should be positioned as specified","font_size":11,"color":"#666"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_edge_cases.svg"), "Edge Case Testing")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  üìÑ Generating: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ‚úÖ Saved: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}

===/src/bin/city2.rs===
// src/bin/dense_city.rs
// Demo program that generates a super dense city using loops

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üèôÔ∏è Generando Ciudad S√∫per Densa con Loops...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("dense_city");
    std::fs::create_dir_all(&output_dir)?;

    // Generate the dense city
    generate_dense_city(&output_dir)?;

    println!("\n‚úÖ Ciudad densa generada exitosamente!");
    println!("üìÅ Archivo guardado en: {}", output_dir.display());

    Ok(())
}

fn generate_dense_city(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("üèóÔ∏è Construyendo ciudad con loops...");
    
    let mut jsonl_lines = Vec::new();
    
    // Configuraci√≥n de la ciudad
    let city_width = 2000;
    let city_height = 1500;
    let block_size = 100;
    let street_width = 8;
    
    // Colores para diferentes tipos de edificios
    let residential_colors = ["#DEB887", "#F4A460", "#CD853F", "#D2691E", "#8B4513", "#A0522D"];
    let commercial_colors = ["#4169E1", "#32CD32", "#FF6347", "#FFD700", "#9370DB", "#20B2AA"];
    let office_colors = ["#708090", "#2F4F4F", "#696969", "#778899", "#B0C4DE", "#87CEEB"];
    let industrial_colors = ["#808080", "#696969", "#A9A9A9", "#778899", "#708090"];
    
    // Root container
    jsonl_lines.push(format!(
        r##"{{"id":"root","type":"free_container","width":{},"height":{},"background":"#87CEEB","children":["street_grid","districts","labels","transportation","landmarks"]}}"##,
        city_width, city_height
    ));
    
    // Generar grid de calles
    let mut street_children = Vec::new();
    let mut street_id = 0;
    
    // Calles horizontales
    for i in 0..(city_height / block_size + 1) {
        let y = i * block_size;
        let id = format!("h_street_{}", street_id);
        street_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"#696969","x":0,"y":{}}}"##,
            id, city_width, street_width, y
        ));
        street_id += 1;
    }
    
    // Calles verticales
    for i in 0..(city_width / block_size + 1) {
        let x = i * block_size;
        let id = format!("v_street_{}", street_id);
        street_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"#696969","x":{},"y":0}}"##,
            id, street_width, city_height, x
        ));
        street_id += 1;
    }
    
    // Container para calles
    jsonl_lines.push(format!(
        r##"{{"id":"street_grid","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        street_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar distritos con loops
    let mut district_children = Vec::new();
    
    // 1. Distrito Residencial (noroeste)
    let mut residential_buildings = Vec::new();
    for block_y in 0..6 {
        for block_x in 0..8 {
            for house_y in 0..3 {
                for house_x in 0..4 {
                    let id = format!("res_{}_{}_{}_{}", block_x, block_y, house_x, house_y);
                    let x = block_x * block_size + house_x * 22 + 12;
                    let y = block_y * block_size + house_y * 28 + 12;
                    let width = 18 + (house_x * 2);
                    let height = 20 + (house_y * 3);
                    let color = residential_colors[(house_x + house_y) % residential_colors.len()];
                    
                    residential_buildings.push(id.clone());
                    jsonl_lines.push(format!(
                        r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                        id, width, height, color, x, y
                    ));
                }
            }
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"residential_district","type":"free_container","width":800,"height":600,"children":[{}],"x":0,"y":0}}"##,
        residential_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("residential_district".to_string());
    
    // 2. Distrito Comercial (centro)
    let mut commercial_buildings = Vec::new();
    for block_y in 0..8 {
        for block_x in 8..14 {
            for bldg_y in 0..2 {
                for bldg_x in 0..3 {
                    let id = format!("com_{}_{}_{}_{}", block_x, block_y, bldg_x, bldg_y);
                    let x = block_x * block_size + bldg_x * 30 + 10;
                    let y = block_y * block_size + bldg_y * 45 + 10;
                    let width = 25 + (bldg_x * 5);
                    let height = 35 + (bldg_y * 10) + (block_y * 2);
                    let color = commercial_colors[(bldg_x + bldg_y + block_y) % commercial_colors.len()];
                    
                    commercial_buildings.push(id.clone());
                    jsonl_lines.push(format!(
                        r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                        id, width, height, color, x, y
                    ));
                }
            }
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"commercial_district","type":"free_container","width":600,"height":800,"children":[{}],"x":800,"y":0}}"##,
        commercial_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("commercial_district".to_string());
    
    // 3. Distrito de Oficinas (suroeste)
    let mut office_buildings = Vec::new();
    for block_y in 6..12 {
        for block_x in 0..10 {
            let id = format!("office_{}_{}", block_x, block_y);
            let x = block_x * block_size + 15;
            let y = block_y * block_size + 15;
            let width = 70;
            let height = 60 + (block_x * 8) + (block_y * 3);
            let color = office_colors[(block_x + block_y) % office_colors.len()];
            
            office_buildings.push(id.clone());
            jsonl_lines.push(format!(
                r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                id, width, height, color, x, y
            ));
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"office_district","type":"free_container","width":1000,"height":600,"children":[{}],"x":0,"y":600}}"##,
        office_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("office_district".to_string());
    
    // 4. Zona Industrial (sureste)
    let mut industrial_buildings = Vec::new();
    for block_y in 8..15 {
        for block_x in 10..20 {
            let id = format!("ind_{}_{}", block_x, block_y);
            let x = block_x * block_size + 20;
            let y = block_y * block_size + 20;
            let width = 60 + (block_x % 3) * 15;
            let height = 40 + (block_y % 4) * 10;
            let color = industrial_colors[(block_x + block_y) % industrial_colors.len()];
            
            industrial_buildings.push(id.clone());
            jsonl_lines.push(format!(
                r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                id, width, height, color, x, y
            ));
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"industrial_district","type":"free_container","width":1000,"height":700,"children":[{}],"x":1000,"y":800}}"##,
        industrial_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("industrial_district".to_string());
    
    // 5. Rascacielos en el centro
    let mut skyscraper_buildings = Vec::new();
    for i in 0..15 {
        for j in 0..8 {
            let id = format!("sky_{}_{}", i, j);
            let x = 1400 + i * 35;
            let y = 200 + j * 70;
            let width = 25 + (i % 3) * 5;
            let height = 100 + i * 12 + j * 8;
            let color_idx = (i + j) % office_colors.len();
            let color = office_colors[color_idx];
            
            skyscraper_buildings.push(id.clone());
            jsonl_lines.push(format!(
                r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"{}","x":{},"y":{}}}"##,
                id, width, height, color, x, y
            ));
        }
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"skyscraper_district","type":"free_container","width":600,"height":800,"children":[{}],"x":1400,"y":0}}"##,
        skyscraper_buildings.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    district_children.push("skyscraper_district".to_string());
    
    // Container para todos los distritos
    jsonl_lines.push(format!(
        r##"{{"id":"districts","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        district_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar etiquetas para distritos
    let mut label_children = Vec::new();
    let labels = [
        ("Residential Quarter", 400, 50),
        ("Commercial District", 1100, 50),
        ("Business Center", 500, 650),
        ("Industrial Zone", 1500, 850),
        ("Downtown Core", 1700, 50),
    ];
    
    for (i, (text, x, y)) in labels.iter().enumerate() {
        let id = format!("label_{}", i);
        label_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"text","content":"{}","font_size":16,"color":"#000080","x":{},"y":{}}}"##,
            id, text, x, y
        ));
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"labels","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        label_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar sistema de transporte con loops
    let mut transport_children = Vec::new();
    
    // Metro lines
    let metro_lines = [
        (("#FF0000", 6), vec![(0, 300), (500, 305), (1000, 300), (1500, 305), (2000, 300)]),
        (("#00FF00", 6), vec![(0, 600), (600, 605), (1200, 600), (1800, 605), (2000, 600)]),
        (("#0000FF", 6), vec![(300, 0), (305, 400), (300, 800), (305, 1200), (300, 1500)]),
        (("#FFFF00", 6), vec![(900, 0), (905, 350), (900, 700), (905, 1050), (900, 1500)]),
    ];
    
    for (line_idx, ((color, width), points)) in metro_lines.iter().enumerate() {
        let id = format!("metro_line_{}", line_idx);
        transport_children.push(id.clone());
        let points_str = points.iter()
            .map(|(x, y)| format!("[{},{}]", x, y))
            .collect::<Vec<_>>()
            .join(",");
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"polyline","points":[{}],"stroke_color":"{}","stroke_width":{},"x":0,"y":0}}"##,
            id, points_str, color, width
        ));
    }
    
    // Estaciones de metro con validaci√≥n
    for i in 0..20 {
        for j in 0..15 {
            if (i * 150) % 300 == 0 && (j * 100) % 300 == 0 {
                let id = format!("station_{}_{}", i, j);
                transport_children.push(id.clone());
                jsonl_lines.push(format!(
                    r##"{{"id":"{}","type":"rect","width":8,"height":8,"background":"white","stroke_color":"black","x":{},"y":{}}}"##,
                    id, i * 100 + 296, j * 100 + 296
                ));
            }
        }
    }
    
    // Autopistas con loops
    let highway_segments = [
        (0, 900, 2000, 900, 12),
        (1500, 0, 1500, 1500, 10),
    ];
    
    for (seg_idx, (x1, y1, x2, y2, width)) in highway_segments.iter().enumerate() {
        let id = format!("highway_{}", seg_idx);
        transport_children.push(id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"polyline","points":[[{},{}],[{},{}]],"stroke_color":"#2F2F2F","stroke_width":{},"x":0,"y":0}}"##,
            id, x1, y1, x2, y2, width
        ));
    }
    
    jsonl_lines.push(format!(
        r##"{{"id":"transportation","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        transport_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Generar landmarks importantes
    let mut landmark_children = Vec::new();
    
    // Parques generados con loops
    let parks = [(400, 400, 150, 100), (1200, 200, 120, 80), (800, 1000, 180, 120)];
    for (park_idx, (x, y, w, h)) in parks.iter().enumerate() {
        let park_id = format!("park_{}", park_idx);
        landmark_children.push(park_id.clone());
        jsonl_lines.push(format!(
            r##"{{"id":"{}","type":"rect","width":{},"height":{},"background":"#32CD32","x":{},"y":{}}}"##,
            park_id, w, h, x, y
        ));
        
        // √Årboles en el parque
        for tree_x in 0..(w / 20) {
            for tree_y in 0..(h / 20) {
                let tree_id = format!("tree_{}_{}_{}", park_idx, tree_x, tree_y);
                landmark_children.push(tree_id.clone());
                jsonl_lines.push(format!(
                    r##"{{"id":"{}","type":"rect","width":4,"height":4,"background":"#228B22","x":{},"y":{}}}"##,
                    tree_id, x + tree_x * 20 + 8, y + tree_y * 20 + 8
                ));
            }
        }
    }
    
    // R√≠o serpenteante
    let mut river_points = Vec::new();
    for i in 0..40 {
        let x = i * 50;
        let y = 1200.0 + (i as f32 * 0.5).sin() * 100.0;
        river_points.push(format!("[{},{}]", x, y as i32));
    }
    landmark_children.push("river".to_string());
    jsonl_lines.push(format!(
        r##"{{"id":"river","type":"polyline","points":[{}],"stroke_color":"#4169E1","stroke_width":20,"x":0,"y":0}}"##,
        river_points.join(",")
    ));
    
    jsonl_lines.push(format!(
        r##"{{"id":"landmarks","type":"free_container","width":{},"height":{},"children":[{}],"x":0,"y":0}}"##,
        city_width, city_height,
        landmark_children.iter().map(|s| format!("\"{}\"", s)).collect::<Vec<_>>().join(",")
    ));
    
    // Escribir el JSONL generado con validaci√≥n
    let jsonl_content = jsonl_lines.join("\n");
    
    // Validar JSON antes de continuar
    println!("üîç Validando JSONL generado...");
    let mut parser_test = parser::JsonLinesParser::new();
    match parser_test.parse_string(&jsonl_content) {
        Ok(_) => println!("‚úÖ JSONL v√°lido!"),
        Err(e) => {
            println!("‚ùå Error en JSONL: {:?}", e);
            // Escribir a archivo para debug
            let debug_path = output_dir.join("debug_jsonl.txt");
            std::fs::write(&debug_path, &jsonl_content)?;
            println!("üêõ JSONL escrito a {} para debug", debug_path.display());
            return Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("JSONL inv√°lido: {:?}", e)
            )));
        }
    }
    
    println!("üìä Estad√≠sticas de la ciudad:");
    println!("   üè† Edificios residenciales: {}", residential_buildings.len());
    println!("   üè¢ Edificios comerciales: {}", commercial_buildings.len());
    println!("   üè≠ Edificios de oficinas: {}", office_buildings.len());
    println!("   üèóÔ∏è Edificios industriales: {}", industrial_buildings.len());
    println!("   üèôÔ∏è Rascacielos: {}", skyscraper_buildings.len());
    println!("   üìè Total de l√≠neas JSONL: {}", jsonl_lines.len());
    
    generate_svg_from_jsonl(&jsonl_content, output_dir.join("dense_city.svg"), "Ciudad S√∫per Densa")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  üìÑ Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ‚úÖ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/bin/patterns.rs===
// Create an SVG file with all supported elements

//import svg_renderer
// use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, HorizontalAlignment, LineOptions};
use demo::measure_text::{ measure_text_ultra_tight};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    TableOptions, TextOptions, Fill,
};
//import io modules to write to file
use std::fs::File;

struct CardOptions {

}

//componente card
//la tarjeta tiene contenido y titulo
fn card_component(id: String, session:&mut DiagramBuilder, header: DiagramTreeNode, content: DiagramTreeNode, opts: CardOptions) -> DiagramTreeNode {
    
    session.new_vstack(id.clone(), vec![header,content], HorizontalAlignment::Center)

}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
  
    session.set_measure_text_fn(measure_text_ultra_tight);

    let mut table_items = Vec::new();

    let cardOptions = CardOptions {

    };

      let textOpts =  TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "black".to_string(),  // white text
            line_spacing: 5.0,
        };

    let cheader = session.new_text("title".to_string(), "card title", textOpts.clone());
    let ccontent = session.new_text("contents".to_string(), "card contents", textOpts.clone());
    let card1 = card_component("card".to_string(), &mut session, cheader, ccontent, cardOptions);



    
    // Add the FreeContainer to the table
    // table_items.push(container_with_elements);

    table_items.push(card1);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 5;
    let table = session.new_table("items".to_string(), table_items, 1, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
  
    
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());
    

    // Render PNG
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

===/src/bin/city.rs===
// src/bin/intricate_city.rs
// Demo program that generates an intricate city using only polylines, rects, and free containers

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üèôÔ∏è Generando Ciudad Intrincada...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("intricate_city");
    std::fs::create_dir_all(&output_dir)?;

    // Generate the intricate city
    generate_intricate_city(&output_dir)?;

    println!("\n‚úÖ Ciudad generada exitosamente!");
    println!("üìÅ Archivo guardado en: {}", output_dir.display());

    Ok(())
}

fn generate_intricate_city(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":1400,"height":900,"background":"#E6F3FF","children":["metro_grid","financial_district","tech_campus","cultural_quarter","harbor","mountain_range","sky_bridges","monorail","shopping_centers"]}

{"id":"metro_grid","type":"free_container","width":1400,"height":900,"children":["metro_line_1","metro_line_2","metro_line_3","metro_line_4","station_markers"],"x":0,"y":0}
{"id":"metro_line_1","type":"polyline","points":[[0,200],[300,205],[600,200],[900,205],[1200,200],[1400,205]],"stroke_color":"#FF6B6B","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_2","type":"polyline","points":[[0,450],[350,455],[700,450],[1050,455],[1400,450]],"stroke_color":"#4ECDC4","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_3","type":"polyline","points":[[200,0],[205,200],[200,400],[205,600],[200,800],[205,900]],"stroke_color":"#45B7D1","stroke_width":6,"x":0,"y":0}
{"id":"metro_line_4","type":"polyline","points":[[800,0],[805,200],[800,400],[805,600],[800,800],[805,900]],"stroke_color":"#96CEB4","stroke_width":6,"x":0,"y":0}
{"id":"station_markers","type":"hstack","children":["station_1","station_2","station_3","station_4","station_5"],"v_align":"center","x":180,"y":180}
{"id":"station_1","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_2","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_3","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_4","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}
{"id":"station_5","type":"rect","width":12,"height":12,"background":"white","border_color":"black"}

{"id":"financial_district","type":"vstack","children":["fd_tier_1","fd_tier_2","fd_tier_3","fd_plaza"],"h_align":"center","x":50,"y":50}
{"id":"fd_tier_1","type":"hstack","children":["tower_mega","tower_alpha","tower_beta"],"v_align":"bottom"}
{"id":"tower_mega","type":"rect","width":45,"height":180,"background":"#2C3E50"}
{"id":"tower_alpha","type":"rect","width":40,"height":160,"background":"#34495E"}
{"id":"tower_beta","type":"rect","width":35,"height":140,"background":"#7F8C8D"}
{"id":"fd_tier_2","type":"hstack","children":["bank_central","office_prime","office_gold"],"v_align":"bottom"}
{"id":"bank_central","type":"rect","width":50,"height":80,"background":"#F39C12"}
{"id":"office_prime","type":"rect","width":30,"height":100,"background":"#E74C3C"}
{"id":"office_gold","type":"rect","width":35,"height":90,"background":"#9B59B6"}
{"id":"fd_tier_3","type":"hstack","children":["retail_1","retail_2","retail_3","retail_4"],"v_align":"center"}
{"id":"retail_1","type":"rect","width":25,"height":25,"background":"#E67E22"}
{"id":"retail_2","type":"rect","width":25,"height":25,"background":"#E74C3C"}
{"id":"retail_3","type":"rect","width":25,"height":25,"background":"#9B59B6"}
{"id":"retail_4","type":"rect","width":25,"height":25,"background":"#3498DB"}
{"id":"fd_plaza","type":"rect","width":200,"height":15,"background":"#BDC3C7"}

{"id":"tech_campus","type":"free_container","width":300,"height":250,"children":["campus_layout","innovation_labs","data_centers"],"x":500,"y":100}
{"id":"campus_layout","type":"vstack","children":["tech_buildings","tech_courtyard","parking_structure"],"h_align":"center","x":0,"y":0}
{"id":"tech_buildings","type":"hstack","children":["lab_a","lab_b","lab_c","lab_d"],"v_align":"bottom"}
{"id":"lab_a","type":"rect","width":40,"height":80,"background":"#1ABC9C"}
{"id":"lab_b","type":"rect","width":35,"height":70,"background":"#16A085"}
{"id":"lab_c","type":"rect","width":45,"height":85,"background":"#3498DB"}
{"id":"lab_d","type":"rect","width":38,"height":75,"background":"#2980B9"}
{"id":"tech_courtyard","type":"rect","width":180,"height":40,"background":"#2ECC71"}
{"id":"parking_structure","type":"hstack","children":["parking_level_1","parking_level_2","parking_level_3"],"v_align":"center"}
{"id":"parking_level_1","type":"rect","width":50,"height":15,"background":"#95A5A6"}
{"id":"parking_level_2","type":"rect","width":50,"height":15,"background":"#7F8C8D"}
{"id":"parking_level_3","type":"rect","width":50,"height":15,"background":"#95A5A6"}
{"id":"innovation_labs","type":"polyline","points":[[0,0],[50,20],[100,10],[150,30],[200,15],[250,25],[300,20]],"stroke_color":"#E74C3C","stroke_width":3,"x":0,"y":50}
{"id":"data_centers","type":"vstack","children":["server_1","server_2"],"h_align":"right","x":220,"y":180}
{"id":"server_1","type":"rect","width":60,"height":30,"background":"#34495E"}
{"id":"server_2","type":"rect","width":60,"height":25,"background":"#2C3E50"}

{"id":"cultural_quarter","type":"free_container","width":280,"height":200,"children":["museums","theaters","galleries"],"x":900,"y":250}
{"id":"museums","type":"vstack","children":["museum_art","museum_history","museum_science"],"h_align":"left","x":0,"y":0}
{"id":"museum_art","type":"hstack","children":["art_wing_1","art_wing_2","art_central"],"v_align":"center"}
{"id":"art_wing_1","type":"rect","width":30,"height":40,"background":"#8E44AD"}
{"id":"art_wing_2","type":"rect","width":30,"height":40,"background":"#9B59B6"}
{"id":"art_central","type":"rect","width":50,"height":60,"background":"#663399"}
{"id":"museum_history","type":"rect","width":120,"height":35,"background":"#D35400"}
{"id":"museum_science","type":"hstack","children":["planetarium","exhibits","imax"],"v_align":"center"}
{"id":"planetarium","type":"rect","width":25,"height":25,"background":"#2C3E50"}
{"id":"exhibits","type":"rect","width":60,"height":30,"background":"#34495E"}
{"id":"imax","type":"rect","width":35,"height":28,"background":"#2C3E50"}
{"id":"theaters","type":"hstack","children":["opera_house","concert_hall"],"v_align":"bottom","x":140,"y":20}
{"id":"opera_house","type":"vstack","children":["opera_dome","opera_base"],"h_align":"center"}
{"id":"opera_dome","type":"rect","width":40,"height":20,"background":"#E67E22"}
{"id":"opera_base","type":"rect","width":60,"height":40,"background":"#D35400"}
{"id":"concert_hall","type":"rect","width":45,"height":70,"background":"#F39C12"}
{"id":"galleries","type":"polyline","points":[[0,150],[40,160],[80,150],[120,160],[160,150],[200,160],[240,150],[280,160]],"stroke_color":"#9B59B6","stroke_width":4,"x":0,"y":0}

{"id":"harbor","type":"free_container","width":400,"height":300,"children":["waterfront","docks","marina","lighthouse"],"x":1000,"y":600}
{"id":"waterfront","type":"rect","width":400,"height":300,"background":"#3498DB","x":0,"y":0}
{"id":"docks","type":"vstack","children":["pier_1","pier_2","pier_3"],"h_align":"left","x":20,"y":50}
{"id":"pier_1","type":"hstack","children":["dock_a","dock_b","dock_c"],"v_align":"center"}
{"id":"dock_a","type":"rect","width":60,"height":8,"background":"#8B4513"}
{"id":"dock_b","type":"rect","width":60,"height":8,"background":"#A0522D"}
{"id":"dock_c","type":"rect","width":60,"height":8,"background":"#8B4513"}
{"id":"pier_2","type":"rect","width":200,"height":10,"background":"#654321"}
{"id":"pier_3","type":"hstack","children":["slip_1","slip_2","slip_3","slip_4"],"v_align":"center"}
{"id":"slip_1","type":"rect","width":40,"height":6,"background":"#8B4513"}
{"id":"slip_2","type":"rect","width":40,"height":6,"background":"#A0522D"}
{"id":"slip_3","type":"rect","width":40,"height":6,"background":"#8B4513"}
{"id":"slip_4","type":"rect","width":40,"height":6,"background":"#A0522D"}
{"id":"marina","type":"polyline","points":[[50,200],[80,220],[120,210],[160,230],[200,220],[240,240],[280,230]],"stroke_color":"white","stroke_width":2,"x":0,"y":0}
{"id":"lighthouse","type":"vstack","children":["lighthouse_base","lighthouse_tower","lighthouse_light"],"h_align":"center","x":350,"y":180}
{"id":"lighthouse_base","type":"rect","width":20,"height":30,"background":"#E74C3C"}
{"id":"lighthouse_tower","type":"rect","width":12,"height":60,"background":"white"}
{"id":"lighthouse_light","type":"rect","width":16,"height":8,"background":"#F1C40F"}

{"id":"mountain_range","type":"polyline","points":[[0,0],[100,50],[200,20],[300,80],[400,30],[500,90],[600,40],[700,100],[800,50],[900,110],[1000,60],[1100,120],[1200,70],[1300,130],[1400,80]],"stroke_color":"#7D6E3E","stroke_width":30,"x":0,"y":0}

{"id":"sky_bridges","type":"free_container","width":1400,"height":900,"children":["bridge_network","aerial_walkways"],"x":0,"y":0}
{"id":"bridge_network","type":"hstack","children":["sky_bridge_1","sky_bridge_2","sky_bridge_3"],"v_align":"center","x":100,"y":150}
{"id":"sky_bridge_1","type":"polyline","points":[[0,0],[150,10],[300,0]],"stroke_color":"#BDC3C7","stroke_width":4,"x":0,"y":0}
{"id":"sky_bridge_2","type":"polyline","points":[[0,0],[200,15],[400,0]],"stroke_color":"#95A5A6","stroke_width":4,"x":0,"y":0}
{"id":"sky_bridge_3","type":"polyline","points":[[0,0],[180,8],[360,0]],"stroke_color":"#BDC3C7","stroke_width":4,"x":0,"y":0}
{"id":"aerial_walkways","type":"vstack","children":["walkway_level_1","walkway_level_2"],"h_align":"center","x":600,"y":100}
{"id":"walkway_level_1","type":"polyline","points":[[0,0],[100,5],[200,0],[300,5],[400,0]],"stroke_color":"#ECF0F1","stroke_width":3,"x":0,"y":0}
{"id":"walkway_level_2","type":"polyline","points":[[50,0],[150,8],[250,0],[350,8],[450,0]],"stroke_color":"#BDC3C7","stroke_width":3,"x":0,"y":0}

{"id":"monorail","type":"polyline","points":[[0,350],[200,355],[400,350],[600,355],[800,350],[1000,355],[1200,350],[1400,355]],"stroke_color":"#2C3E50","stroke_width":8,"x":0,"y":0}

{"id":"shopping_centers","type":"free_container","width":600,"height":400,"children":["mall_complex","outdoor_plaza","market_district"],"x":250,"y":500}
{"id":"mall_complex","type":"vstack","children":["mall_upper","mall_main","mall_food_court"],"h_align":"center","x":0,"y":0}
{"id":"mall_upper","type":"hstack","children":["store_1","store_2","store_3","store_4","store_5"],"v_align":"center"}
{"id":"store_1","type":"rect","width":40,"height":30,"background":"#E91E63"}
{"id":"store_2","type":"rect","width":35,"height":30,"background":"#9C27B0"}
{"id":"store_3","type":"rect","width":45,"height":30,"background":"#673AB7"}
{"id":"store_4","type":"rect","width":38,"height":30,"background":"#3F51B5"}
{"id":"store_5","type":"rect","width":42,"height":30,"background":"#2196F3"}
{"id":"mall_main","type":"rect","width":250,"height":40,"background":"#F5F5F5"}
{"id":"mall_food_court","type":"hstack","children":["restaurant_1","restaurant_2","restaurant_3","seating"],"v_align":"center"}
{"id":"restaurant_1","type":"rect","width":50,"height":25,"background":"#FF5722"}
{"id":"restaurant_2","type":"rect","width":45,"height":25,"background":"#FF9800"}
{"id":"restaurant_3","type":"rect","width":40,"height":25,"background":"#FFC107"}
{"id":"seating","type":"rect","width":80,"height":25,"background":"#FFEB3B"}
{"id":"outdoor_plaza","type":"free_container","width":200,"height":150,"children":["plaza_fountains","plaza_vendors"],"x":300,"y":50}
{"id":"plaza_fountains","type":"vstack","children":["fountain_main","fountain_small_1","fountain_small_2"],"h_align":"center","x":50,"y":20}
{"id":"fountain_main","type":"rect","width":30,"height":30,"background":"#00BCD4"}
{"id":"fountain_small_1","type":"rect","width":15,"height":15,"background":"#26C6DA"}
{"id":"fountain_small_2","type":"rect","width":15,"height":15,"background":"#26C6DA"}
{"id":"plaza_vendors","type":"hstack","children":["vendor_1","vendor_2","vendor_3"],"v_align":"center","x":20,"y":100}
{"id":"vendor_1","type":"rect","width":25,"height":15,"background":"#4CAF50"}
{"id":"vendor_2","type":"rect","width":25,"height":15,"background":"#8BC34A"}
{"id":"vendor_3","type":"rect","width":25,"height":15,"background":"#CDDC39"}
{"id":"market_district","type":"polyline","points":[[400,200],[450,220],[500,200],[550,220],[600,200]],"stroke_color":"#795548","stroke_width":6,"x":0,"y":0}"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("intricate_city.svg"), "Ciudad Intrincada")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  üìÑ Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ‚úÖ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}

===/src/bin/custom_components.rs===
// src/bin/custom_component_demo.rs
// Demo program showing how to register and use custom components

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::{fmt::format, fs::File};
use volare_engine_layout::*;

// Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

/// Custom Component 1: Badge
/// Creates a rounded pill-shaped element with text
fn create_badge_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("üè∑Ô∏è  Creating badge component with attrs: {:?}", attrs);

    // Extract attributes
    let text = get_string_attr(attrs, "text", "Badge");
    let background = get_string_attr(attrs, "background", "blue");
    let color = get_string_attr(attrs, "color", "white");
    let font_size = get_float_attr(attrs, "font_size", 12.0);
    let padding = get_float_attr(attrs, "padding", 8.0);

    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        id =  uuid::Uuid::new_v4().to_string()
    }

    // Create text element
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size,
        text_color: color,
        line_width: 200,
        line_spacing: 0.0,
    };
    let text_node = builder.new_text(
        format!("{}_text", id),
        &text, text_options);

    // Wrap in rounded box
    let box_options = BoxOptions {
        fill_color: Fill::Color(background),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding,
        border_radius: font_size,               // Make it pill-shaped
        width_behavior: SizeBehavior::Content,  // Auto width based on text
        height_behavior: SizeBehavior::Content, // Auto height based on text
    };
    let badge = builder.new_box(
        id,
        text_node, box_options);

    println!("‚úÖ Badge '{}' created successfully", text);
    Ok(badge)
}

/// Custom Component 2: Alert Box
/// Creates an alert with optional icon, title, and message
fn create_alert_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("‚ö†Ô∏è  Creating alert component with attrs: {:?}", attrs);

    let alert_type = get_string_attr(attrs, "alert-type", "info");
    let title = get_string_attr(attrs, "title", "Alert");
    let message = get_string_attr(attrs, "message", "Alert message");
    let width = get_float_attr(attrs, "width", 300.0);
    let show_icon = get_bool_attr(attrs, "show_icon", true);
    let mut id = get_string_attr(attrs, "id", "");

    if id.is_empty() {
        id = uuid::Uuid::new_v4().to_string()
    }

    //TODO aqui seria util tener
    // let context = builder.CreateComponentContext(id)
    // y todos los elems internos les asigna prefijo el id
    // util para no tener que concatenarlos

    // Define alert styles
    let (bg_color, border_color, icon) = match alert_type.as_str() {
        "success" => ("#d4edda", "#28a745", "‚úì"),
        "warning" => ("#fff3cd", "#ffc107", "‚ö†"),
        "error" => ("#f8d7da", "#dc3545", "‚úó"),
        "info" | _ => ("#d1ecf1", "#17a2b8", "‚Ñπ"),
    };

    let mut children = Vec::new();

    // Create header with optional icon
    if show_icon {
        let icon_text = builder.new_text(
            format!("{}_showicon", id),
            icon,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: border_color.to_string(),
                line_width: 50,
                line_spacing: 0.0,
            },
        );

        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#333".to_string(),
                line_width: (width - 50.0) as usize,
                line_spacing: 0.0,
            },
        );

        let header = builder.new_hstack(
            format!("{}_header", id),
            vec![icon_text, title_text],
            VerticalAlignment::Center,
        );
        children.push(header);
    } else {
        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#333".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add message
    let message_text = builder.new_text(
        format!("{}_addmsg", id),
        &message,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666".to_string(),
            line_width: width as usize,
            line_spacing: 2.0,
        },
    );
    children.push(message_text);

    // Create vertical layout
    let content = builder.new_vstack(
        format!("{}_contentstack", id),
        children,
        HorizontalAlignment::Left,
    );

    // Wrap in styled box
    let alert_box = builder.new_box(
        id,
        content,
        BoxOptions {
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            padding: 16.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Content, // Auto height based on content
        },
    );

    println!("‚úÖ Alert '{}' ({}) created successfully", title, alert_type);
    Ok(alert_box)
}

/// Custom Component 3: Progress Bar
/// Creates a progress bar with background and fill
fn create_progress_bar_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("üìä Creating progress bar component with attrs: {:?}", attrs);

    let width = get_float_attr(attrs, "width", 200.0);
    let height = get_float_attr(attrs, "height", 20.0);
    let progress = get_float_attr(attrs, "progress", 0.5).min(1.0).max(0.0);
    let bg_color = get_string_attr(attrs, "bg_color", "lightgray");
    let fill_color = get_string_attr(attrs, "fill_color", "blue");
    let show_text = get_bool_attr(attrs, "show_text", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        // Generate a unique ID if not provided
         id = format!("progress_bar_{}", uuid::Uuid::new_v4());
    }

    // Create background bar
    let bg_rect = builder.new_rectangle(
        format!("bg_{}", id),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(height),
            fill_color: Fill::Color(bg_color),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            border_radius: height / 2.0,
        },
    );

    // Create progress fill
    let fill_width = width * progress;
    let fill_rect = builder.new_rectangle(
        format!("fill_{}", id),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(fill_width),
            height_behavior: SizeBehavior::Fixed(height),
            fill_color: Fill::Color(fill_color),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            border_radius: height / 2.0,
        },
    );

    let mut elements = vec![(bg_rect, (0.0, 0.0)), (fill_rect, (0.0, 0.0))];

    // Add percentage text if requested
    if show_text {
        let percentage = (progress * 100.0) as i32;
        let text_node = builder.new_text(
            format!("text_{}", id),
            &format!("{}%", percentage),
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: height * 0.7,
                text_color: "black".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        // Center the text roughly
        let text_x = (width - 30.0) / 2.0; // Rough centering
        let text_y = height * 0.15;
        elements.push((text_node, (text_x, text_y)));
    }

    let progress_bar = builder.new_free_container(id.to_string(), elements);

    println!(
        "‚úÖ Progress bar ({}%) created successfully",
        (progress * 100.0) as i32
    );
    Ok(progress_bar)
}

/// Custom Component 4: Button
/// Creates a clickable button with text
fn create_button_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("üîò Creating button component with attrs: {:?}", attrs);

    let text = get_string_attr(attrs, "text", "Button");
    let variant = get_string_attr(attrs, "variant", "primary");
    let size = get_string_attr(attrs, "size", "medium");
    let disabled = get_bool_attr(attrs, "disabled", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("button_{}", uuid::Uuid::new_v4());
    }

    // Define button styles based on variant
    let (bg_color, text_color, border_color) = if disabled {
        ("#cccccc", "#666666", "#999999")
    } else {
        match variant.as_str() {
            "primary" => ("#007bff", "white", "#0056b3"),
            "secondary" => ("#6c757d", "white", "#545b62"),
            "success" => ("#28a745", "white", "#1e7e34"),
            "danger" => ("#dc3545", "white", "#bd2130"),
            "warning" => ("#ffc107", "#212529", "#d39e00"),
            _ => ("#007bff", "white", "#0056b3"),
        }
    };

    // Define size-based properties
    let (font_size, padding_x, padding_y) = match size.as_str() {
        "small" => (12.0, 12.0, 6.0),
        "large" => (18.0, 24.0, 12.0),
        _ => (14.0, 16.0, 8.0), // medium
    };

    // Create button text
    let button_text = builder.new_text(
        format!("{}-{}", id, text),
        &text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size,
            text_color: text_color.to_string(),
            line_width: 200,
            line_spacing: 0.0,
        },
    );

    // Wrap in styled box
    let button = builder.new_box(
        format!("button_{}", id),
        button_text,
        BoxOptions {
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            padding: f32::max(padding_x, padding_y), // Use max for uniform padding
            border_radius: 4.0,
            width_behavior: SizeBehavior::Content, // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
        },
    );

    println!(
        "‚úÖ Button '{}' ({}, {}) created successfully",
        text, variant, size
    );
    Ok(button)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üöÄ Custom Component Demo Starting...\n");

    // Create diagram builder and set text measurement function
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all our custom components
    println!("üìù Registering custom components...");
    builder.register_custom_component("badge", create_badge_component);
    builder.register_custom_component("alert", create_alert_component);
    builder.register_custom_component("progress_bar", create_progress_bar_component);
    builder.register_custom_component("button", create_button_component);
    println!("‚úÖ All custom components registered!\n");

    // Demo 1: Direct usage with Rust API
    println!("=== Demo 1: Direct Rust API Usage ===");

    // Create components directly
    let badge_attrs = json!({
        "text": "NEW",
        "background": "red",
        "color": "white",
        "font_size": 14.0,
        "padding": 10.0
    })
    .as_object()
    .unwrap()
    .clone();

    let _badge = builder.create_custom_component("badge", &badge_attrs)?;

    let alert_attrs = json!({
        "type": "success",
        "title": "Success!",
        "message": "Your custom component system is working perfectly!",
        "width": 400.0,
        "show_icon": true
    })
    .as_object()
    .unwrap()
    .clone();

    let _alert = builder.create_custom_component("alert", &alert_attrs)?;

    println!("‚úÖ Direct API usage successful!\n");

    // Demo 2: JSON Lines usage
    println!("=== Demo 2: JSON Lines Usage ===");

    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","demo_section","buttons_section","progress_section","alerts_section"],"h_align":"center"}
{"id":"title","type":"text","content":"üé® Custom Components Showcase","font_size":25,"color":"darkblue"}
{"id":"demo_section","type":"hstack","children":["badge1","badge2","badge3"],"v_align":"center"}
{"id":"badge1","type":"badge","text":"NEW","background":"#ff4444","color":"white","font_size":12,"padding":8}
{"id":"badge2","type":"badge","text":"SALE","background":"#44ff44","color":"black","font_size":12,"padding":8}
{"id":"badge3","type":"badge","text":"HOT","background":"#ff8800","color":"white","font_size":12,"padding":8}
{"id":"buttons_section","type":"hstack","children":["btn1","btn2","btn3","btn4"],"v_align":"center"}
{"id":"btn1","type":"button","text":"Primary","variant":"primary","size":"medium"}
{"id":"btn2","type":"button","text":"Success","variant":"success","size":"medium"}
{"id":"btn3","type":"button","text":"Warning","variant":"warning","size":"medium"}
{"id":"btn4","type":"button","text":"Disabled","variant":"secondary","size":"medium","disabled":true}
{"id":"progress_section","type":"vstack","children":["progress1","progress2","progress3"],"h_align":"center"}
{"id":"progress1","type":"progress_bar","width":300,"height":20,"progress":0.25,"fill_color":"#ff4444","show_text":true}
{"id":"progress2","type":"progress_bar","width":300,"height":20,"progress":0.65,"fill_color":"#44ff44","show_text":true}
{"id":"progress3","type":"progress_bar","width":300,"height":20,"progress":0.90,"fill_color":"#4444ff","show_text":true}
{"id":"alerts_section","type":"vstack","children":["alert1","alert2","alert3","alert4"],"h_align":"left"}
{"id":"alert1","type":"alert","alert-type":"success","title":"Success Alert","message":"Everything is working perfectly! Your custom components are rendering correctly.","width":500,"show_icon":true}
{"id":"alert2","type":"alert","alert-type":"warning","title":"Warning Alert","message":"This is a warning message to demonstrate the warning alert style.","width":500,"show_icon":true}
{"id":"alert3","type":"alert","alert-type":"error","title":"Error Alert","message":"This shows how error messages would appear in your application.","width":500,"show_icon":true}
{"id":"alert4","type":"alert","alert-type":"info","title":"Info Alert","message":"Here's some informational content using the info alert component.","width":500,"show_icon":true}
"##;

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components with the parse builder
    parse_builder.register_custom_component("badge", create_badge_component);
    parse_builder.register_custom_component("alert", create_alert_component);
    parse_builder.register_custom_component("progress_bar", create_progress_bar_component);
    parse_builder.register_custom_component("button", create_button_component);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    println!("‚úÖ JSON Lines parsing successful!");

    // Calculate layout
    println!("üìê Calculating layout...");
    layout::layout_tree_node(&mut parse_builder, &diagram);
    println!("‚úÖ Layout calculation complete!");

    // Demo 3: Render to SVG
    println!("\n=== Demo 3: SVG Rendering ===");

    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("custom-components-showcase.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("‚úÖ SVG rendered successfully!");
    println!("üìÑ File saved to: {}", svg_path.to_str().unwrap());

    // Demo 4: Statistics
    println!("\n=== Demo 4: Component Statistics ===");
    let registered_types = parse_builder.get_custom_component_types();
    println!("üìä Registered custom components: {:?}", registered_types);
    println!("üî¢ Total custom components: {}", registered_types.len());

    // Count components in the diagram
    fn count_custom_components(
        node: &diagram_builder::DiagramTreeNode,
        types: &[&String],
    ) -> usize {
        let mut count = 0;
        if types
            .iter()
            .any(|t| t.as_str() == format!("{:?}", node.entity_type))
        {
            count += 1;
        }
        for child in &node.children {
            count += count_custom_components(child, types);
        }
        count
    }

    let custom_count = count_custom_components(&diagram, &registered_types);
    println!("üéØ Custom components in diagram: {}", custom_count);

    println!("\nüéâ Custom Component Demo Complete!");
    println!("üí° Check the generated SVG file to see your custom components in action!");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);
        builder.register_custom_component("alert", create_alert_component);
        builder.register_custom_component("progress_bar", create_progress_bar_component);
        builder.register_custom_component("button", create_button_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 4);
        assert!(builder.has_custom_component("badge"));
        assert!(builder.has_custom_component("alert"));
        assert!(builder.has_custom_component("progress_bar"));
        assert!(builder.has_custom_component("button"));
    }

    #[test]
    fn test_jsonl_with_custom_components() {
        let input = r#"
{"id":"root","type":"badge","text":"Test Badge","background":"red"}
"#;

        let mut parser = parser::JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let result = parser.build(&root_id, &mut builder);
        assert!(result.is_ok());
    }
}

===/src/bin/visual_experiments.rs===
// src/bin/visual_experiments.rs
// Demo program that generates SVGs for visual experiments using JSONL format

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üé® Generando Experimentos Visuales...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("visual_experiments");
    std::fs::create_dir_all(&output_dir)?;

    // üéØ Experimentos de Animaci√≥n/Progresi√≥n
    println!("=== üéØ Experimentos de Animaci√≥n/Progresi√≥n ===");
    
    // 1. Construcci√≥n de Edificio
    generate_building_construction(&output_dir)?;
    
    // 2. Crecimiento de √Årbol
    generate_tree_growth(&output_dir)?;

    // üìä Visualizaci√≥n de Datos en Tiempo Real
    println!("\n=== üìä Visualizaci√≥n de Datos ===");
    
    // 3. Dashboard Financiero
    generate_financial_dashboard(&output_dir)?;
    
    // 4. Monitor de Sistema
    generate_system_monitor(&output_dir)?;

    // üéÆ Interfaces Interactivas
    println!("\n=== üéÆ Interfaces Interactivas ===");
    
    // 5. Panel de Control Espacial
    generate_space_control_panel(&output_dir)?;
    
    // 6. Simulador de Tr√°fico
    generate_traffic_simulator(&output_dir)?;

    // üß¨ Simulaciones Cient√≠ficas
    println!("\n=== üß¨ Simulaciones Cient√≠ficas ===");
    
    // 7. Modelo Molecular
    generate_molecular_model(&output_dir)?;
    
    // 8. Sistema Solar
    generate_solar_system(&output_dir)?;

    // üé® Arte Generativo
    println!("\n=== üé® Arte Generativo ===");
    
    // 9. Patr√≥n Fractal Simple
    generate_fractal_pattern(&output_dir)?;
    
    // 10. Mandala Geom√©trico
    generate_geometric_mandala(&output_dir)?;

    println!("\n‚úÖ Todos los experimentos generados exitosamente!");
    println!("üìÅ Archivos guardados en: {}", output_dir.display());

    Ok(())
}

// 1. Construcci√≥n de Edificio
fn generate_building_construction(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":400,"children":["ground","floor1","floor2","floor3","roof","window1","window2"]}
{"id":"ground","type":"rect","width":400,"height":20,"background":"brown","x":0,"y":380}
{"id":"floor1","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":320}
{"id":"floor2","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":260}
{"id":"floor3","type":"rect","width":200,"height":60,"background":"lightgray","x":100,"y":200}
{"id":"roof","type":"polyline","points":[[100,200],[150,150],[250,150],[300,200]],"stroke_color":"red","x":0,"y":0}
{"id":"window1","type":"rect","width":20,"height":30,"background":"lightblue","x":120,"y":340}
{"id":"window2","type":"rect","width":20,"height":30,"background":"lightblue","x":160,"y":340}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_building_construction.svg"), "Construcci√≥n de Edificio")
}

// 2. Crecimiento de √Årbol

fn generate_tree_growth(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
   // 2. Crecimiento de √Årbol
 let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":300,"children":["trunk","branch1","branch2","leaf1","leaf2","apple1"]}
{"id":"trunk","type":"rect","width":20,"height":100,"background":"brown","x":190,"y":150}
{"id":"branch1","type":"line","start_x":200,"start_y":150,"end_x":170,"end_y":120,"stroke_color":"brown","stroke_width":3,"x":0,"y":0}
{"id":"branch2","type":"line","start_x":200,"start_y":150,"end_x":230,"end_y":120,"stroke_color":"brown","stroke_width":3,"x":0,"y":0}
{"id":"leaf1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"green","x":155,"y":105}
{"id":"leaf2","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"green","x":215,"y":105}
{"id":"apple1","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red","x":160,"y":125}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_tree_growth.svg"), "Crecimiento de √Årbol")
}

// 3. Dashboard Financiero
fn generate_financial_dashboard(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["header","metrics","chart_area"],"h_align":"center"}
{"id":"header","type":"text","content":"üìà Financial Dashboard","font_size":24,"color":"darkblue"}
{"id":"metrics","type":"hstack","children":["revenue","profit","users"],"v_align":"center"}
{"id":"revenue","type":"vstack","children":["rev_icon","rev_value","rev_change"],"h_align":"center"}
{"id":"rev_icon","type":"text","content":"üí∞","font_size":20}
{"id":"rev_value","type":"text","content":"$125,430","font_size":18,"color":"#333"}
{"id":"rev_change","type":"text","content":"‚Üó +12.5%","font_size":12,"color":"green"}
{"id":"profit","type":"vstack","children":["prof_icon","prof_value","prof_change"],"h_align":"center"}
{"id":"prof_icon","type":"text","content":"üìä","font_size":20}
{"id":"prof_value","type":"text","content":"$45,200","font_size":18,"color":"#333"}
{"id":"prof_change","type":"text","content":"‚Üó +8.2%","font_size":12,"color":"green"}
{"id":"users","type":"vstack","children":["user_icon","user_value","user_change"],"h_align":"center"}
{"id":"user_icon","type":"text","content":"üë•","font_size":20}
{"id":"user_value","type":"text","content":"8,945","font_size":18,"color":"#333"}
{"id":"user_change","type":"text","content":"‚Üò -2.1%","font_size":12,"color":"red"}
{"id":"chart_area","type":"free_container","width":250,"height":120,"children":["bar1","bar2","bar3"]}
{"id":"bar1","type":"rect","width":30,"height":50,"background":"blue","x":50,"y":50}
{"id":"bar2","type":"rect","width":30,"height":75,"background":"green","x":100,"y":25}
{"id":"bar3","type":"rect","width":30,"height":40,"background":"red","x":150,"y":60}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_financial_dashboard.svg"), "Dashboard Financiero")
}

// 4. Monitor de Sistema
fn generate_system_monitor(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","cpu_section","memory_section","network_section"],"h_align":"left"}
{"id":"title","type":"text","content":"üñ•Ô∏è System Monitor","font_size":20,"color":"#333"}
{"id":"cpu_section","type":"hstack","children":["cpu_label","cpu_container"],"v_align":"center"}
{"id":"cpu_label","type":"text","content":"CPU:","font_size":14}
{"id":"cpu_container","type":"free_container","width":210,"height":25,"children":["cpu_bg","cpu_fill","cpu_text"]}
{"id":"cpu_bg","type":"rect","width":200,"height":20,"background":"lightgray","x":5,"y":2}
{"id":"cpu_fill","type":"rect","width":150,"height":20,"background":"orange","x":5,"y":2}
{"id":"cpu_text","type":"text","content":"75%","font_size":12,"x":105,"y":12}
{"id":"memory_section","type":"hstack","children":["mem_label","mem_container"],"v_align":"center"}
{"id":"mem_label","type":"text","content":"Memory:","font_size":14}
{"id":"mem_container","type":"free_container","width":210,"height":25,"children":["mem_bg","mem_fill","mem_text"]}
{"id":"mem_bg","type":"rect","width":200,"height":20,"background":"lightgray","x":5,"y":2}
{"id":"mem_fill","type":"rect","width":90,"height":20,"background":"blue","x":5,"y":2}
{"id":"mem_text","type":"text","content":"45%","font_size":12,"x":105,"y":12}
{"id":"network_section","type":"hstack","children":["net_label","net_indicator"],"v_align":"center"}
{"id":"net_label","type":"text","content":"Network:","font_size":14}
{"id":"net_indicator","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"green"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_system_monitor.svg"), "Monitor de Sistema")
}

// 5. Panel de Control Espacial
fn generate_space_control_panel(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":250,"background":"black","border_color":"cyan","border_width":2,"children":["radar","blip1","blip2","status_panel"]}
{"id":"radar","type":"ellipse","cx":80,"cy":80,"rx":80,"ry":80,"fill":"darkgreen","stroke":"green","x":50,"y":50}
{"id":"blip1","type":"ellipse","cx":3,"cy":3,"rx":3,"ry":3,"fill":"red","x":120,"y":140}
{"id":"blip2","type":"ellipse","cx":3,"cy":3,"rx":3,"ry":3,"fill":"yellow","x":170,"y":160}
{"id":"status_panel","type":"vstack","children":["shields","energy","weapons"],"h_align":"left","x":250,"y":50}
{"id":"shields","type":"text","content":"üõ°Ô∏è Shields: 85%","color":"cyan","font_size":12}
{"id":"energy","type":"text","content":"‚ö° Energy: 92%","color":"yellow","font_size":12}
{"id":"weapons","type":"text","content":"üî´ Weapons: Online","color":"green","font_size":12}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("05_space_control_panel.svg"), "Panel de Control Espacial")
}

// 6. Simulador de Tr√°fico
fn generate_traffic_simulator(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":300,"background":"lightgray","children":["road_h","road_v","car1","car2","car3","traffic_light"]}
{"id":"road_h","type":"rect","width":400,"height":40,"background":"darkgray","x":0,"y":130}
{"id":"road_v","type":"rect","width":40,"height":300,"background":"darkgray","x":180,"y":0}
{"id":"car1","type":"rect","width":30,"height":15,"background":"red","x":50,"y":140}
{"id":"car2","type":"rect","width":30,"height":15,"background":"blue","x":320,"y":140}
{"id":"car3","type":"rect","width":15,"height":30,"background":"green","x":185,"y":50}
{"id":"traffic_light","type":"vstack","children":["red_light","yellow_light","green_light"],"h_align":"center","x":175,"y":110}
{"id":"red_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"red"}
{"id":"yellow_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"gray"}
{"id":"green_light","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"gray"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("06_traffic_simulator.svg"), "Simulador de Tr√°fico")
}

// 7. Modelo Molecular
fn generate_molecular_model(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":300,"height":300,"children":["carbon1","hydrogen1","hydrogen2","oxygen1","bond1","bond2","bond3"]}
{"id":"carbon1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"gray","x":100,"y":100}
{"id":"hydrogen1","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"white","stroke":"black","x":150,"y":90}
{"id":"hydrogen2","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"white","stroke":"black","x":150,"y":110}
{"id":"oxygen1","type":"ellipse","cx":12,"cy":12,"rx":12,"ry":12,"fill":"red","x":200,"y":100}
{"id":"bond1","type":"line","start_x":115,"start_y":110,"end_x":150,"end_y":100,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"bond2","type":"line","start_x":115,"start_y":115,"end_x":150,"end_y":118,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
{"id":"bond3","type":"line","start_x":130,"start_y":115,"end_x":200,"end_y":112,"stroke_color":"black","stroke_width":2,"x":0,"y":0}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("07_molecular_model.svg"), "Modelo Molecular")
}

// 8. Sistema Solar
fn generate_solar_system(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":500,"height":500,"background":"black","children":["sun","mercury_orbit","venus_orbit","earth_orbit","mercury","venus","earth","moon"]}
{"id":"sun","type":"ellipse","cx":25,"cy":25,"rx":25,"ry":25,"fill":"yellow","x":225,"y":225}
{"id":"mercury_orbit","type":"ellipse","cx":250,"cy":250,"rx":80,"ry":80,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"venus_orbit","type":"ellipse","cx":250,"cy":250,"rx":120,"ry":120,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"earth_orbit","type":"ellipse","cx":250,"cy":250,"rx":160,"ry":160,"fill":"none","stroke":"gray","x":0,"y":0}
{"id":"mercury","type":"ellipse","cx":4,"cy":4,"rx":4,"ry":4,"fill":"orange","x":320,"y":246}
{"id":"venus","type":"ellipse","cx":6,"cy":6,"rx":6,"ry":6,"fill":"yellow","x":360,"y":244}
{"id":"earth","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"blue","x":400,"y":242}
{"id":"moon","type":"ellipse","cx":2,"cy":2,"rx":2,"ry":2,"fill":"gray","x":415,"y":240}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("08_solar_system.svg"), "Sistema Solar")
}

// 9. Patr√≥n Fractal Simple
fn generate_fractal_pattern(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":400,"height":400,"children":["center","nw","ne","sw","se","nw_nw","nw_ne","nw_sw","nw_se"]}
{"id":"center","type":"rect","width":100,"height":100,"background":"blue","x":150,"y":150}
{"id":"nw","type":"rect","width":50,"height":50,"background":"lightblue","x":100,"y":100}
{"id":"ne","type":"rect","width":50,"height":50,"background":"lightblue","x":250,"y":100}
{"id":"sw","type":"rect","width":50,"height":50,"background":"lightblue","x":100,"y":250}
{"id":"se","type":"rect","width":50,"height":50,"background":"lightblue","x":250,"y":250}
{"id":"nw_nw","type":"rect","width":25,"height":25,"background":"cyan","x":75,"y":75}
{"id":"nw_ne","type":"rect","width":25,"height":25,"background":"cyan","x":125,"y":75}
{"id":"nw_sw","type":"rect","width":25,"height":25,"background":"cyan","x":75,"y":125}
{"id":"nw_se","type":"rect","width":25,"height":25,"background":"cyan","x":125,"y":125}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("09_fractal_pattern.svg"), "Patr√≥n Fractal Simple")
}

// 10. Mandala Geom√©trico
fn generate_geometric_mandala(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"free_container","width":300,"height":300,"children":["center_circle","ring1_1","ring1_2","ring1_3","ring1_4","ring1_5","ring1_6"]}
{"id":"center_circle","type":"ellipse","cx":20,"cy":20,"rx":20,"ry":20,"fill":"purple","x":130,"y":130}
{"id":"ring1_1","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":135,"y":80}
{"id":"ring1_2","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":185,"y":105}
{"id":"ring1_3","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":185,"y":155}
{"id":"ring1_4","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":135,"y":180}
{"id":"ring1_5","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":85,"y":155}
{"id":"ring1_6","type":"ellipse","cx":15,"cy":15,"rx":15,"ry":15,"fill":"blue","x":85,"y":105}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("10_geometric_mandala.svg"), "Mandala Geom√©trico")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  üìÑ Generando: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ‚úÖ Guardado: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/bin/constraints.rs===
// src/bin/intricate_city.rs
// Demo program that generates an intricate city using only polylines, rects, and free containers

use demo::measure_text::measure_text_svg_character_advance;
use resvg::usvg::roxmltree::Children;
use uuid::fmt::Simple;
use volare_engine_layout::diagram_builder::DiagramTreeNode;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Cassowary constraints demo...\n");
    let mut builder = DiagramBuilder::new();
    let output_dir = std::env::temp_dir().join("constraints_demo");
    std::fs::create_dir_all(&output_dir)?;
    let output_path = output_dir.join("constraints1.svg");
    builder.set_measure_text_fn(measure_text_svg_character_advance);
    let children = vec![builder.new_rectangle(
        "r1".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("red".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    ),
    builder.new_rectangle(
        "r2".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    ),
    builder.new_rectangle(
        "r3".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("green".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    ),
      builder.new_rectangle(
        "r4".to_string(),
        RectOptions {
            width_behavior: SizeBehavior::Fixed(50.0),
            height_behavior: SizeBehavior::Fixed(20.0),
            fill_color: Fill::Color("purple".to_string()),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        },
    )
    ];

    let mut children_with_pos: Vec<(DiagramTreeNode, Option<Point>)>= children.iter().map(|c| {
        (c.clone(), None)
    }).collect();

     if let Some(elem) = children_with_pos.get_mut(0) {
        elem.1  = Some(Point::new(0.0, 0.0))
     }

    builder.set_position("r1".to_string(), 50.0, 50.0);

    let mut constraints = Vec::<SimpleConstraint>::new();
    // R1 should be set to the right of r2
    constraints.push(SimpleConstraint::RightOf("r1".into(), "r2".into()));
    constraints.push(SimpleConstraint::Below("r3".into(), "r2".into()));
    constraints.push(SimpleConstraint::Above("r4".into(), "r1".into()));
    constraints.push(SimpleConstraint::RightOf("r1".into(), "r4".into()));
    let root = builder.new_constraint_layout_container("container".to_string(), children_with_pos, constraints);
    layout_tree_node(&mut builder, &root);
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&builder, &root, &mut svg_file)?;

    println!("    ‚úÖ Guardado: {}",output_path.to_str().unwrap());
  

    Ok(())
}

===/src/bin/sample_components.rs===
// src/bin/useful_components_demo.rs
// A library of practical custom components for real-world usage

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::fs::File;
use volare_engine_layout::*;

// Helper functions for attribute extraction
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Vec<String> {
    attrs
        .get(key)
        .and_then(|v| v.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default()
}

/// Card Component - A flexible container with header, body, and footer
fn create_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let content = get_string_attr(attrs, "content", "");
    let footer = get_string_attr(attrs, "footer", "");
    let width = get_float_attr(attrs, "width", 300.0);
    let padding = get_float_attr(attrs, "padding", 16.0);
    let border_radius = get_float_attr(attrs, "border_radius", 8.0);
    let shadow = get_bool_attr(attrs, "shadow", true);
    let variant = get_string_attr(attrs, "variant", "default");

    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        id = uuid::Uuid::new_v4().to_string()
    }

    // Define card styles based on variant
    let (bg_color, border_color) = match variant.as_str() {
        "primary" => ("#ffffff", "#007bff"),
        "success" => ("#f8fff8", "#28a745"),
        "warning" => ("#fffdf0", "#ffc107"),
        "danger" => ("#fff8f8", "#dc3545"),
        _ => ("#ffffff", "#e0e0e0"),
    };

    let mut children = Vec::new();

    // Add title if provided
    if !title.is_empty() {
        let title_text = builder.new_text(
            format!("{}_title", id),
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: "#333333".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_text = builder.new_text(
            format!("{}_subtitle", id),
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#666666".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_text);
    }

    // Add content if provided
    if !content.is_empty() {
        let content_text = builder.new_text(
            format!("{}_content", id),
            &content,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#444444".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 4.0,
            },
        );
        children.push(content_text);
    }

    // Add footer if provided
    if !footer.is_empty() {
        let footer_text = builder.new_text(
            format!("{}_footer", id),
            &footer,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#888888".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(footer_text);
    }

    // Create layout
    let content_stack = builder.new_vstack(
        format!("{}_contentstack", id),
        children, HorizontalAlignment::Left);

    // Apply shadow effect by creating multiple boxes
    if shadow {
        // Shadow box (slightly offset)
        let shadow_box = builder.new_box(
            format!("{}_shadowbox", id),
            content_stack,
            BoxOptions {
                fill_color: Fill::Color("#00000010".to_string()),
                stroke_color: "transparent".to_string(),
                stroke_width: 0.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );

        // Main card box
        let main_content = builder.new_rectangle(
            format!("{}_maincontent", id),
            RectOptions {
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            border_radius,
        });

        // Use free container to overlay them
        let card = builder.new_free_container(
            id, 
            vec![
            (shadow_box, (2.0, 2.0)),   // Shadow slightly offset
            (main_content, (0.0, 0.0)), // Main card on top
        ]);
        Ok(card)
    } else {
        let card = builder.new_box(
            id,
            content_stack,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: 1.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );
        Ok(card)
    }
}

/// List Component - Creates a styled list with bullets or numbers
fn create_list_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let list_type = get_string_attr(attrs, "list_type", "bullet"); // bullet, number, check
    let spacing = get_float_attr(attrs, "spacing", 4.0);
    let width = get_float_attr(attrs, "width", 300.0);
    let font_size = get_float_attr(attrs, "font_size", 14.0);
    let mut id = get_string_attr(attrs, "id", "");

    if id.is_empty(){
        id = uuid::Uuid::new_v4().to_string()
    }

    if items.is_empty() {
        return Err("List component requires 'items' array".to_string());
    }

    let mut list_children = Vec::new();

    for (index, item) in items.iter().enumerate() {
        // Create bullet/number
        let marker = match list_type.as_str() {
            "number" => format!("{}.", index + 1),
            "check" => "‚úì".to_string(),
            "arrow" => "‚Üí".to_string(),
            _ => "‚Ä¢".to_string(), // bullet
        };

        let marker_text = builder.new_text(
            format!("{}-marker", id),
            &marker,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#666666".to_string(),
                line_width: 30,
                line_spacing: 0.0,
            },
        );

        let item_text = builder.new_text(
            format!("{}_item_text", id),
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#333333".to_string(),
                line_width: (width - 40.0) as usize,
                line_spacing: 0.0,
            },
        );

        let list_item = builder.new_hstack(
            format!("list_items_{}", id),
            vec![marker_text, item_text], VerticalAlignment::Top);
        list_children.push(list_item);
    }

    let list = builder.new_vstack(
        format!("list_items_{}", id),
        list_children, HorizontalAlignment::Left);
    Ok(list)
}

/// Form Field Component - Creates labeled input-like elements
fn create_form_field_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let label = get_string_attr(attrs, "label", "Field");
    let placeholder = get_string_attr(attrs, "placeholder", "Enter value...");
    let field_type = get_string_attr(attrs, "field_type", "text"); // text, email, password, textarea
    let required = get_bool_attr(attrs, "required", false);
    let width = get_float_attr(attrs, "width", 250.0);
    let error = get_string_attr(attrs, "error", "");
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
         id = format!("form_field_{}", uuid::Uuid::new_v4());
    }

    let mut children = Vec::new();

    // Create label
    let label_text = if required {
        format!("{} *", label)
    } else {
        label
    };

    let label_node = builder.new_text(
        format!("label_{}", id),
        &label_text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: if required { "#333333" } else { "#666666" }.to_string(),
            line_width: width as usize,
            line_spacing: 0.0,
        },
    );
    children.push(label_node);

    // Create input field representation
    let field_height = match field_type.as_str() {
        "textarea" => 60.0,
        _ => 36.0,
    };

    let placeholder_text = builder.new_text(
        format!("placeholder_{}", id),
        &placeholder,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#999999".to_string(),
            line_width: (width - 24.0) as usize,
            line_spacing: 0.0,
        },
    );

    let input_field = builder.new_box(
        format!("input_field_{}", id),
        placeholder_text,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: if !error.is_empty() {
                "#dc3545"
            } else {
                "#cccccc"
            }
            .to_string(),
            stroke_width: 1.0,
            padding: 12.0,
            border_radius: 4.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(field_height),
        },
    );
    children.push(input_field);

    // Add error message if present
    if !error.is_empty() {
        let error_text = builder.new_text(
            format!("error_{}", id),
            &error,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#dc3545".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(error_text);
    }

    let form_field = builder.new_vstack(id.to_string(), children, HorizontalAlignment::Left);
    Ok(form_field)
}

/// Stats Card Component - Displays key metrics with icons
fn create_stats_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Metric");
    let value = get_string_attr(attrs, "value", "0");
    let change = get_string_attr(attrs, "change", "");
    let icon = get_string_attr(attrs, "icon", "üìä");
    let trend = get_string_attr(attrs, "trend", "neutral"); // up, down, neutral
    let color = get_string_attr(attrs, "color", "#007bff");
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("stats_card_{}", uuid::Uuid::new_v4());
    }
    // Determine trend color and symbol
    let (trend_color, trend_symbol) = match trend.as_str() {
        "up" => ("#28a745", "‚Üó"),
        "down" => ("#dc3545", "‚Üò"),
        _ => ("#6c757d", "‚Üí"),
    };

    // Create icon
    let icon_text = builder.new_text(
        format!("icon_{}", id),
        &icon,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            text_color: color,
            line_width: 50,
            line_spacing: 0.0,
        },
    );

    // Create value and title section
    let value_text = builder.new_text(
        format!("value_{}", id),
        &value,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 28.0,
            text_color: "#333333".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let title_text = builder.new_text(
        format!("title_{}", id),
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666666".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let mut right_children = vec![value_text, title_text];

    // Add change indicator if provided
    if !change.is_empty() {
        let change_text = format!("{} {}", trend_symbol, change);
        let change_node = builder.new_text(
            "change_text".to_string(),
            &change_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: trend_color.to_string(),
                line_width: 150,
                line_spacing: 0.0,
            },
        );
        right_children.push(change_node);
    }

    let right_section = builder.new_vstack("right_section".to_string(), right_children, HorizontalAlignment::Left);
    let content = builder.new_hstack("stats_card_content".to_string(), vec![icon_text, right_section], VerticalAlignment::Center);

    let stats_card = builder.new_box(
        id,
        content,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: "#e0e0e0".to_string(),
            stroke_width: 1.0,
            padding: 20.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(300.0),
            height_behavior: SizeBehavior::Content,
        },
    );

    Ok(stats_card)
}

/// Navigation Menu Component - Creates a horizontal or vertical menu
fn create_nav_menu_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let orientation = get_string_attr(attrs, "orientation", "horizontal"); // horizontal, vertical
    let active_item = get_string_attr(attrs, "active_item", "");
    let style = get_string_attr(attrs, "style", "default"); // default, pills, tabs
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("nav_menu_{}", uuid::Uuid::new_v4());
    }

    if items.is_empty() {
        return Err("Navigation menu requires 'items' array".to_string());
    }

    let mut nav_children = Vec::new();

    for item in items.iter() {
        let is_active = item == &active_item;

        // Style based on state and style type
        let (bg_color, text_color, border_color) = match (is_active, style.as_str()) {
            (true, "pills") => ("#007bff", "#ffffff", "#007bff"),
            (false, "pills") => ("transparent", "#007bff", "transparent"),
            (true, "tabs") => ("#ffffff", "#007bff", "#007bff"),
            (false, "tabs") => ("transparent", "#666666", "#e0e0e0"),
            (true, _) => ("transparent", "#007bff", "transparent"),
            (false, _) => ("transparent", "#666666", "transparent"),
        };

        let nav_text = builder.new_text(
            format!("nav_text_{}_{}", item, id),
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: text_color.to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );

        let nav_item = builder.new_box(
            format!("nav_item_{}_{}", item, id),
            nav_text,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: if style == "tabs" { 1.0 } else { 0.0 },
                padding: 12.0,
                border_radius: if style == "pills" { 20.0 } else { 4.0 },
                width_behavior: SizeBehavior::Content,
                height_behavior: SizeBehavior::Content,
            },
        );

        nav_children.push(nav_item);
    }

    let nav_menu = match orientation.as_str() {
        "vertical" => builder.new_vstack(format!("nav_menu_{}_{}", id, orientation), nav_children, HorizontalAlignment::Left),
        _ => builder.new_hstack(format!("nav_menu_{}_{}", id, orientation), nav_children, VerticalAlignment::Center),
    };

    Ok(nav_menu)
}

/// Header Component - Creates page headers with optional breadcrumbs
fn create_header_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Page Title");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let breadcrumbs = get_array_attr(attrs, "breadcrumbs");
    let show_back = get_bool_attr(attrs, "show_back", false);
    let mut id = get_string_attr(attrs, "id", "");
    if id.is_empty() {
        //use uuid
        id = format!("header_{}", uuid::Uuid::new_v4());
    }


    let mut children = Vec::new();

    // Add breadcrumbs if provided
    if !breadcrumbs.is_empty() {
        let breadcrumb_text = breadcrumbs.join(" > ");
        let breadcrumb_node = builder.new_text(
            format!("breadcrumb_{}",id),
            &breadcrumb_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(breadcrumb_node);
    }

    // Add back button if requested
    if show_back {
        let back_text = builder.new_text(
            "back_button".to_string(),
            "‚Üê Back",
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#007bff".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        children.push(back_text);
    }

    // Add main title
    let title_node = builder.new_text(
        format!("title_{}", id),
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 32.0,
            text_color: "#333333".to_string(),
            line_width: 600,
            line_spacing: 0.0,
        },
    );
    children.push(title_node);

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_node = builder.new_text(
            format!("subtitle_{}", id),
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_node);
    }

    let header = builder.new_vstack("header".to_string(),children, HorizontalAlignment::Left);
    Ok(header)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üöÄ Useful Components Demo Starting...\n");

    // Create diagram builder and register components
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all useful components
    println!("üìù Registering useful components...");
    builder.register_custom_component("card", create_card_component);
    builder.register_custom_component("list", create_list_component);
    builder.register_custom_component("form_field", create_form_field_component);
    builder.register_custom_component("stats_card", create_stats_card_component);
    builder.register_custom_component("nav_menu", create_nav_menu_component);
    builder.register_custom_component("header", create_header_component);
    println!("‚úÖ All useful components registered!\n");

    // The JSONL content - Real-world dashboard example
    let jsonl_input = r##"{"id":"root","type":"vstack","children":["main_header","nav","dashboard_content"],"h_align":"center"}
{"id":"main_header","type":"header","title":"Analytics Dashboard","subtitle":"Monitor your key metrics and performance indicators","breadcrumbs":["Home","Analytics","Dashboard"]}
{"id":"nav","type":"nav_menu","items":["Overview","Analytics","Reports","Settings"],"active_item":"Analytics","style":"tabs","orientation":"horizontal"}
{"id":"dashboard_content","type":"vstack","children":["stats_row","charts_row","recent_activity"],"h_align":"center"}
{"id":"stats_row","type":"hstack","children":["stats1","stats2","stats3","stats4"],"v_align":"top"}
{"id":"stats1","type":"stats_card","title":"Total Users","value":"12,345","change":"+12.5%","trend":"up","icon":"üë•","color":"#007bff"}
{"id":"stats2","type":"stats_card","title":"Revenue","value":"$89,432","change":"+8.2%","trend":"up","icon":"üí∞","color":"#28a745"}
{"id":"stats3","type":"stats_card","title":"Orders","value":"1,234","change":"-2.1%","trend":"down","icon":"üì¶","color":"#ffc107"}
{"id":"stats4","type":"stats_card","title":"Conversion","value":"3.24%","change":"+0.8%","trend":"up","icon":"üìà","color":"#17a2b8"}
{"id":"charts_row","type":"hstack","children":["performance_card","recent_orders_card"],"v_align":"top"}
{"id":"performance_card","type":"card","title":"Performance Metrics","content":"Your application performance has improved by 23% this month. Server response times are optimal and user engagement is at an all-time high.","footer":"Last updated: 2 minutes ago","width":400,"variant":"primary","shadow":true}
{"id":"recent_orders_card","type":"card","title":"Recent Orders","width":400,"variant":"default","shadow":true,"children":["orders_list"]}
{"id":"orders_list","type":"list","items":["Order #1234 - $299.99 - Processing","Order #1235 - $156.78 - Shipped","Order #1236 - $89.50 - Delivered","Order #1237 - $445.20 - Processing"],"list_type":"number","spacing":6,"width":350}
{"id":"recent_activity","type":"vstack","children":["activity_header","activity_content"],"h_align":"left"}
{"id":"activity_header","type":"text","content":"Recent Activity","font_size":20,"color":"#333333"}
{"id":"activity_content","type":"hstack","children":["activity_list","user_form"],"v_align":"top"}
{"id":"activity_list","type":"list","items":["User john.doe logged in","New order received (#1238)","Payment processed for order #1235","User jane.smith updated profile","System backup completed","New user registration: mike.wilson"],"list_type":"arrow","width":400,"font_size":13}
{"id":"user_form","type":"vstack","children":["form_title","name_field","email_field","message_field","submit_section"],"h_align":"left"}
{"id":"form_title","type":"text","content":"Quick Contact","font_size":18,"color":"#333333"}
{"id":"name_field","type":"form_field","label":"Full Name","placeholder":"Enter your full name","required":true,"width":300}
{"id":"email_field","type":"form_field","label":"Email Address","placeholder":"your.email@company.com","field_type":"email","required":true,"width":300}
{"id":"message_field","type":"form_field","label":"Message","placeholder":"Type your message here...","field_type":"textarea","width":300}
{"id":"submit_section","type":"card","content":"Form ready to submit","footer":"All fields are validated","width":300,"variant":"success"}"##;

    // Parse and build the diagram
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components
    parse_builder.register_custom_component("card", create_card_component);
    parse_builder.register_custom_component("list", create_list_component);
    parse_builder.register_custom_component("form_field", create_form_field_component);
    parse_builder.register_custom_component("stats_card", create_stats_card_component);
    parse_builder.register_custom_component("nav_menu", create_nav_menu_component);
    parse_builder.register_custom_component("header", create_header_component);

    // Build and layout
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("useful-components-dashboard.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("‚úÖ Dashboard rendered successfully!");
    println!("üìÑ File saved to: {}", svg_path.to_str().unwrap());
    println!("\nüéâ Useful Components Demo Complete!");

    Ok(())
}

===/src/bin/text.rs===
// Create an SVG file with all supported elements

//import svg_renderer
// use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, LineOptions};
use demo::measure_text::{ measure_text_ultra_tight};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    TableOptions, TextOptions, Fill,
};
//import io modules to write to file
use std::fs::File;



fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
  
    session.set_measure_text_fn(measure_text_ultra_tight);

    let mut table_items = Vec::new();

    let thetext =  br#""Lorem ipsum dolor sit amet, consectetur adipiscing elit.
otra linea texto
otra mas...
It could also be compensating for the fact that pos includes
cumulative scaling from parent transforms, 
and you need to pass down the "base" position to child renderers.
The comment "Calculate absolute position without any scaling" suggests the goal is to get back to unscaled coordinates that the child rendering pipeline expects.""#;

    let textOpts =  TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "white".to_string(),  // white text
            line_spacing: 5.0,
        };

    let blue_text = session.new_text(
        "blue_text".to_string(),
        std::str::from_utf8(thetext).unwrap(),
       textOpts.clone(),
    );

   // debug_text_measurement(std::str::from_utf8(thetext).unwrap(), &textOpts.clone());


    let box_options = BoxOptions {
        fill_color: Fill::Color("#0000FF".to_string()),  // blue background
        stroke_color: "#000066".to_string(),  // dark blue border
        stroke_width: 1.0,
        //TODO: falta tener en cuenta padding al momento de hacer layout de elementos de box
        padding: 50.0,
        border_radius: 0.0,
        width_behavior: volare_engine_layout::SizeBehavior::Fixed(200.0), // fixed width
        height_behavior: volare_engine_layout::SizeBehavior::Content, // auto height
    };

    let box1 = session.new_box("box1".to_string(), blue_text, box_options);

    
    // Add the FreeContainer to the table
    // table_items.push(container_with_elements);

    table_items.push(box1);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 5;
    let table = session.new_table("text_table".to_string(), table_items, 5, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
  
    
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());
    

    // Render PNG
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

===/src/bin/arcs.rs===
// src/bin/arc_shapes_demo.rs
// Demo program showcasing Arc, Semicircle, and Quarter Circle shapes

use demo::measure_text::measure_text_svg_character_advance;
use std::fs::File;
use std::path::Path;
use volare_engine_layout::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üåÄ Arc Shapes Demo Starting...\n");

    // Create output directory
    let output_dir = std::env::temp_dir().join("arc_shapes_demo");
    std::fs::create_dir_all(&output_dir)?;

    // Generate various arc shape demonstrations
    generate_basic_arcs_demo(&output_dir)?;
    generate_semicircles_demo(&output_dir)?;
    generate_quarter_circles_demo(&output_dir)?;
    generate_filled_arcs_demo(&output_dir)?;
    generate_complex_arc_patterns(&output_dir)?;
    generate_arc_dashboard(&output_dir)?;

    println!("\n‚úÖ All arc shape demos generated successfully!");
    println!("üìÅ Files saved in: {}", output_dir.display());

    Ok(())
}

// Demo 1: Basic Arc Shapes
fn generate_basic_arcs_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","arcs_container"],"h_align":"center"}
{"id":"title","type":"text","content":"üåÄ Basic Arc Shapes","font_size":24,"color":"darkblue"}
{"id":"arcs_container","type":"free_container","width":900,"height":400,"children":["arc_45","arc_90","arc_180","arc_270","arc_300","labels"]}
{"id":"arc_45","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":45,"stroke_color":"#ff4444","stroke_width":3,"x":80,"y":120}
{"id":"arc_90","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":90,"stroke_color":"#44ff44","stroke_width":3,"x":200,"y":120}
{"id":"arc_180","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":180,"stroke_color":"#4444ff","stroke_width":3,"x":320,"y":120}
{"id":"arc_270","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":270,"stroke_color":"#ff44ff","stroke_width":3,"x":440,"y":120}
{"id":"arc_300","type":"arc","cx":0,"cy":0,"radius":40,"start_angle":0,"end_angle":300,"stroke_color":"#44ffff","stroke_width":3,"x":560,"y":120}
{"id":"labels","type":"vstack","children":["label_45","label_90","label_180","label_270","label_300"],"h_align":"left","x":50,"y":320}
{"id":"label_45","type":"text","content":"‚Ä¢ 45¬∞ Arc (Red)","font_size":14,"color":"#ff4444"}
{"id":"label_90","type":"text","content":"‚Ä¢ 90¬∞ Arc (Green)","font_size":14,"color":"#44ff44"}
{"id":"label_180","type":"text","content":"‚Ä¢ 180¬∞ Arc (Blue)","font_size":14,"color":"#4444ff"}
{"id":"label_270","type":"text","content":"‚Ä¢ 270¬∞ Arc (Magenta)","font_size":14,"color":"#ff44ff"}
{"id":"label_300","type":"text","content":"‚Ä¢ 300¬∞ Arc (Cyan)","font_size":14,"color":"#44ffff"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("01_basic_arcs.svg"), "Basic Arc Shapes")
}

// Demo 2: Semicircles in Different Orientations
fn generate_semicircles_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","semicircles_layout"],"h_align":"center"}
{"id":"title","type":"text","content":"üîÑ Semicircle Variations","font_size":24,"color":"darkgreen"}
{"id":"semicircles_layout","type":"free_container","width":600,"height":350,"children":["semi_up","semi_down","semi_left","semi_right","descriptions"]}
{"id":"semi_up","type":"semicircle","cx":150,"cy":150,"radius":50,"facing_up":true,"stroke_color":"#e74c3c","stroke_width":4,"filled":false,"x":0,"y":0}
{"id":"semi_down","type":"semicircle","cx":450,"cy":150,"radius":50,"facing_up":false,"stroke_color":"#3498db","stroke_width":4,"filled":false,"x":0,"y":0}
{"id":"semi_left","type":"arc","cx":150,"cy":300,"radius":50,"start_angle":90,"end_angle":270,"stroke_color":"#f39c12","stroke_width":4,"x":0,"y":0}
{"id":"semi_right","type":"arc","cx":450,"cy":300,"radius":50,"start_angle":270,"end_angle":90,"stroke_color":"#9b59b6","stroke_width":4,"x":0,"y":0}
{"id":"descriptions","type":"vstack","children":["desc1","desc2","desc3","desc4"],"h_align":"left","x":50,"y":50}
{"id":"desc1","type":"text","content":"Top Semicircle (0¬∞-180¬∞)","font_size":12,"color":"#e74c3c"}
{"id":"desc2","type":"text","content":"Bottom Semicircle (180¬∞-360¬∞)","font_size":12,"color":"#3498db"}
{"id":"desc3","type":"text","content":"Left Semicircle (90¬∞-270¬∞)","font_size":12,"color":"#f39c12"}
{"id":"desc4","type":"text","content":"Right Semicircle (270¬∞-90¬∞)","font_size":12,"color":"#9b59b6"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("02_semicircles.svg"), "Semicircle Variations")
}

// Demo 3: Quarter Circles in All Quadrants
fn generate_quarter_circles_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","quarters_container"],"h_align":"center"}
{"id":"title","type":"text","content":"üìê Quarter Circle Quadrants","font_size":24,"color":"darkorchid"}
{"id":"quarters_container","type":"free_container","width":400,"height":400,"children":["q1","q2","q3","q4","center_point","quadrant_labels"]}
{"id":"q1","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":1,"stroke_color":"#e74c3c","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"q2","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":2,"stroke_color":"#2ecc71","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"q3","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":3,"stroke_color":"#3498db","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"q4","type":"quarter_circle","cx":200,"cy":200,"radius":80,"quadrant":4,"stroke_color":"#f39c12","stroke_width":5,"filled":false,"x":0,"y":0}
{"id":"center_point","type":"ellipse","cx":5,"cy":5,"rx":5,"ry":5,"fill":"black","x":195,"y":195}
{"id":"quadrant_labels","type":"vstack","children":["q1_label","q2_label","q3_label","q4_label"],"h_align":"left","x":50,"y":50}
{"id":"q1_label","type":"text","content":"Q1: Top-Right (0¬∞-90¬∞)","font_size":12,"color":"#e74c3c"}
{"id":"q2_label","type":"text","content":"Q2: Top-Left (90¬∞-180¬∞)","font_size":12,"color":"#2ecc71"}
{"id":"q3_label","type":"text","content":"Q3: Bottom-Left (180¬∞-270¬∞)","font_size":12,"color":"#3498db"}
{"id":"q4_label","type":"text","content":"Q4: Bottom-Right (270¬∞-360¬∞)","font_size":12,"color":"#f39c12"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("03_quarter_circles.svg"), "Quarter Circle Quadrants")
}

// Demo 4: Filled vs Unfilled Arcs
fn generate_filled_arcs_demo(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","filled_comparison"],"h_align":"center"}
{"id":"title","type":"text","content":"üé® Filled vs Unfilled Arcs","font_size":24,"color":"darkred"}
{"id":"filled_comparison","type":"hstack","children":["unfilled_section","filled_section"],"v_align":"center"}
{"id":"unfilled_section","type":"vstack","children":["unfilled_label","unfilled_arcs"],"h_align":"center"}
{"id":"unfilled_label","type":"text","content":"Outline Only","font_size":16,"color":"#333"}
{"id":"unfilled_arcs","type":"hstack","children":["arc_outline_1","arc_outline_2","arc_outline_3"],"v_align":"center"}
{"id":"arc_outline_1","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":90,"stroke_color":"#e74c3c","stroke_width":4,"filled":false}
{"id":"arc_outline_2","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":180,"stroke_color":"#3498db","stroke_width":4,"filled":false}
{"id":"arc_outline_3","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":270,"stroke_color":"#2ecc71","stroke_width":4,"filled":false}
{"id":"filled_section","type":"vstack","children":["filled_label","filled_arcs"],"h_align":"center"}
{"id":"filled_label","type":"text","content":"Filled Sectors","font_size":16,"color":"#333"}
{"id":"filled_arcs","type":"hstack","children":["arc_filled_1","arc_filled_2","arc_filled_3"],"v_align":"center"}
{"id":"arc_filled_1","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":90,"stroke_color":"#c0392b","stroke_width":2,"fill_color":"#e74c3c","filled":true}
{"id":"arc_filled_2","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":180,"stroke_color":"#2980b9","stroke_width":2,"fill_color":"#3498db","filled":true}
{"id":"arc_filled_3","type":"arc","cx":40,"cy":40,"radius":25,"start_angle":0,"end_angle":270,"stroke_color":"#27ae60","stroke_width":2,"fill_color":"#2ecc71","filled":true}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("04_filled_arcs.svg"), "Filled vs Unfilled Arcs")
}

// Demo 5: Complex Arc Patterns
fn generate_complex_arc_patterns(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","patterns_container"],"h_align":"center"}
{"id":"title","type":"text","content":"üåü Complex Arc Patterns","font_size":24,"color":"darkcyan"}
{"id":"patterns_container","type":"free_container","width":800,"height":500,"children":["flower_pattern","spiral_pattern","clock_pattern","legend"]}
{"id":"flower_pattern","type":"free_container","width":200,"height":200,"children":["petal1","petal2","petal3","petal4","petal5","petal6","flower_center"],"x":50,"y":50}
{"id":"petal1","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":0,"end_angle":60,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#fce4ec","filled":true}
{"id":"petal2","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":60,"end_angle":120,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#f8bbd9","filled":true}
{"id":"petal3","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":120,"end_angle":180,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#fce4ec","filled":true}
{"id":"petal4","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":180,"end_angle":240,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#f8bbd9","filled":true}
{"id":"petal5","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":240,"end_angle":300,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#fce4ec","filled":true}
{"id":"petal6","type":"arc","cx":100,"cy":100,"radius":40,"start_angle":300,"end_angle":360,"stroke_color":"#e91e63","stroke_width":4,"fill_color":"#f8bbd9","filled":true}
{"id":"flower_center","type":"ellipse","cx":10,"cy":10,"rx":10,"ry":10,"fill":"#ffeb3b","stroke":"#ff9800","stroke_width":2,"x":90,"y":90}
{"id":"spiral_pattern","type":"free_container","width":200,"height":200,"children":["spiral1","spiral2","spiral3","spiral4","spiral5"],"x":300,"y":50}
{"id":"spiral1","type":"arc","cx":100,"cy":100,"radius":20,"start_angle":0,"end_angle":270,"stroke_color":"#9c27b0","stroke_width":6,"filled":false}
{"id":"spiral2","type":"arc","cx":100,"cy":100,"radius":35,"start_angle":45,"end_angle":315,"stroke_color":"#673ab7","stroke_width":5,"filled":false}
{"id":"spiral3","type":"arc","cx":100,"cy":100,"radius":50,"start_angle":90,"end_angle":360,"stroke_color":"#3f51b5","stroke_width":4,"filled":false}
{"id":"spiral4","type":"arc","cx":100,"cy":100,"radius":65,"start_angle":135,"end_angle":405,"stroke_color":"#2196f3","stroke_width":3,"filled":false}
{"id":"spiral5","type":"arc","cx":100,"cy":100,"radius":80,"start_angle":180,"end_angle":450,"stroke_color":"#03a9f4","stroke_width":2,"filled":false}
{"id":"clock_pattern","type":"free_container","width":200,"height":200,"children":["clock_12","clock_3","clock_6","clock_9","clock_center","hour_hand","minute_hand"],"x":550,"y":50}
{"id":"clock_12","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":1,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_3","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":4,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_6","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":3,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_9","type":"quarter_circle","cx":100,"cy":100,"radius":80,"quadrant":2,"stroke_color":"#795548","stroke_width":3,"filled":false}
{"id":"clock_center","type":"ellipse","cx":8,"cy":8,"rx":8,"ry":8,"fill":"#424242","x":92,"y":92}
{"id":"hour_hand","type":"line","start_x":100,"start_y":100,"end_x":100,"end_y":60,"stroke_color":"#212121","stroke_width":4,"x":0,"y":0}
{"id":"minute_hand","type":"line","start_x":100,"start_y":100,"end_x":130,"end_y":100,"stroke_color":"#424242","stroke_width":2,"x":0,"y":0}
{"id":"legend","type":"vstack","children":["flower_desc","spiral_desc","clock_desc"],"h_align":"left","x":50,"y":300}
{"id":"flower_desc","type":"text","content":"üå∏ Flower Pattern: 6 filled arc petals (60¬∞ each)","font_size":14,"color":"#e91e63"}
{"id":"spiral_desc","type":"text","content":"üåÄ Spiral Pattern: Concentric arcs with increasing radius","font_size":14,"color":"#9c27b0"}
{"id":"clock_desc","type":"text","content":"üïí Clock Pattern: Quarter circles forming clock face","font_size":14,"color":"#795548"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("05_complex_patterns.svg"), "Complex Arc Patterns")
}

// Demo 6: Arc Dashboard with Various Metrics
fn generate_arc_dashboard(output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["header","dashboard_content"],"h_align":"center"}
{"id":"header","type":"text","content":"üìä Arc-Based Dashboard","font_size":26,"color":"#2c3e50"}
{"id":"dashboard_content","type":"free_container","width":900,"height":600,"children":["progress_gauges","pie_charts","status_indicators","dashboard_labels"]}
{"id":"progress_gauges","type":"free_container","width":300,"height":200,"children":["gauge1_bg","gauge1_fill","gauge1_text","gauge2_bg","gauge2_fill","gauge2_text","gauge3_bg","gauge3_fill","gauge3_text"],"x":50,"y":50}
{"id":"gauge1_bg","type":"arc","cx":100,"cy":100,"radius":60,"start_angle":180,"end_angle":360,"stroke_color":"#ecf0f1","stroke_width":12,"filled":false}
{"id":"gauge1_fill","type":"arc","cx":100,"cy":100,"radius":60,"start_angle":180,"end_angle":288,"stroke_color":"#e74c3c","stroke_width":12,"filled":false}
{"id":"gauge1_text","type":"text","content":"CPU 60%","font_size":12,"color":"#2c3e50","x":75,"y":120}
{"id":"gauge2_bg","type":"arc","cx":100,"cy":250,"radius":60,"start_angle":180,"end_angle":360,"stroke_color":"#ecf0f1","stroke_width":12,"filled":false}
{"id":"gauge2_fill","type":"arc","cx":100,"cy":250,"radius":60,"start_angle":180,"end_angle":324,"stroke_color":"#f39c12","stroke_width":12,"filled":false}
{"id":"gauge2_text","type":"text","content":"RAM 80%","font_size":12,"color":"#2c3e50","x":75,"y":270}
{"id":"gauge3_bg","type":"arc","cx":250,"cy":175,"radius":60,"start_angle":180,"end_angle":360,"stroke_color":"#ecf0f1","stroke_width":12,"filled":false}
{"id":"gauge3_fill","type":"arc","cx":250,"cy":175,"radius":60,"start_angle":180,"end_angle":252,"stroke_color":"#27ae60","stroke_width":12,"filled":false}
{"id":"gauge3_text","type":"text","content":"Disk 40%","font_size":12,"color":"#2c3e50","x":225,"y":195}
{"id":"pie_charts","type":"free_container","width":250,"height":250,"children":["pie1_s1","pie1_s2","pie1_s3","pie1_s4","pie2_s1","pie2_s2","pie2_s3"],"x":400,"y":50}
{"id":"pie1_s1","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":0,"end_angle":144,"stroke_color":"#3498db","stroke_width":2,"fill_color":"#3498db","filled":true}
{"id":"pie1_s2","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":144,"end_angle":216,"stroke_color":"#e74c3c","stroke_width":2,"fill_color":"#e74c3c","filled":true}
{"id":"pie1_s3","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":216,"end_angle":288,"stroke_color":"#2ecc71","stroke_width":2,"fill_color":"#2ecc71","filled":true}
{"id":"pie1_s4","type":"arc","cx":80,"cy":80,"radius":50,"start_angle":288,"end_angle":360,"stroke_color":"#f39c12","stroke_width":2,"fill_color":"#f39c12","filled":true}
{"id":"pie2_s1","type":"arc","cx":80,"cy":200,"radius":40,"start_angle":0,"end_angle":180,"stroke_color":"#9b59b6","stroke_width":2,"fill_color":"#9b59b6","filled":true}
{"id":"pie2_s2","type":"arc","cx":80,"cy":200,"radius":40,"start_angle":180,"end_angle":270,"stroke_color":"#1abc9c","stroke_width":2,"fill_color":"#1abc9c","filled":true}
{"id":"pie2_s3","type":"arc","cx":80,"cy":200,"radius":40,"start_angle":270,"end_angle":360,"stroke_color":"#e67e22","stroke_width":2,"fill_color":"#e67e22","filled":true}
{"id":"status_indicators","type":"free_container","width":200,"height":300,"children":["status1","status2","status3","status4"],"x":700,"y":50}
{"id":"status1","type":"arc","cx":50,"cy":50,"radius":30,"start_angle":0,"end_angle":90,"stroke_color":"#27ae60","stroke_width":8,"filled":false}
{"id":"status2","type":"arc","cx":150,"cy":50,"radius":30,"start_angle":0,"end_angle":180,"stroke_color":"#f39c12","stroke_width":8,"filled":false}
{"id":"status3","type":"arc","cx":50,"cy":150,"radius":30,"start_angle":0,"end_angle":270,"stroke_color":"#e74c3c","stroke_width":8,"filled":false}
{"id":"status4","type":"arc","cx":150,"cy":150,"radius":30,"start_angle":0,"end_angle":360,"stroke_color":"#8e44ad","stroke_width":8,"filled":false}
{"id":"dashboard_labels","type":"vstack","children":["gauges_label","pie_label","status_label"],"h_align":"left","x":50,"y":400}
{"id":"gauges_label","type":"text","content":"üìà Progress Gauges: System resource usage","font_size":16,"color":"#34495e"}
{"id":"pie_label","type":"text","content":"üç∞ Pie Charts: Data distribution visualization","font_size":16,"color":"#34495e"}
{"id":"status_label","type":"text","content":"üîÑ Status Indicators: Service availability levels","font_size":16,"color":"#34495e"}
"##;

    generate_svg_from_jsonl(jsonl_input, output_dir.join("06_arc_dashboard.svg"), "Arc-Based Dashboard")
}

// Helper function to generate SVG from JSONL
fn generate_svg_from_jsonl(
    jsonl_input: &str,
    output_path: std::path::PathBuf,
    description: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("  üìÑ Generating: {}", description);

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;

    // Calculate layout
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&output_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("    ‚úÖ Saved: {}", output_path.file_name().unwrap().to_str().unwrap());

    Ok(())
}
===/src/lib.rs===
pub mod measure_text; 

===/src/text_renderer_comparison.rs===
// Text Renderer Comparison Test
// This file demonstrates the differences in text positioning and spacing
// between the SVG and PNG renderers

// use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{
    renderer_base::Renderer,
    BoxOptions,
    TextOptions,
    Fill,
    DiagramBuilder,
    layout::layout_tree_node,
};

// Import measurement function
use crate::measure_text::measure_text;
use std::fs::File;

pub fn run_comparison_test() -> Result<(), Box<dyn std::error::Error>> {
    // Create session
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(measure_text);

    // Create options for the test
    let title_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 18.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let regular_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 14.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let small_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 12.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let box_options = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 0.0,
    };

    let box_options_no_padding = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 0.0,
        border_radius: 0.0,
    };

    // Create title
    let title = session.new_text(
        "Text Rendering Comparison",
        title_text_options,
    );

    // Create a simple single-line text
    let single_line_text = session.new_text(
        "This is a single line of text.",
        regular_text_options.clone(),
    );
    
    // Create a simple single-line text with a box around it
    let single_line_text_boxed = session.new_text(
        "This is a single line with a box.",
        regular_text_options.clone(),
    );
    let single_line_box = session.new_box(single_line_text_boxed, box_options.clone());

    // Create a simple single-line text with a box around it (no padding)
    let single_line_text_boxed_no_padding = session.new_text(
        "Single line box without padding.",
        regular_text_options.clone(),
    );
    let single_line_box_no_padding = session.new_box(single_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Create a multi-line text example
    let multi_line_text = session.new_text(
        "This is a multi-line text example.\nSecond line of text.\nThird line for testing purposes.",
        regular_text_options.clone(),
    );

    // Create a multi-line text with a box around it
    let multi_line_text_boxed = session.new_text(
        "This is a multi-line text with a box.\nSecond line of text.\nThird line demonstrates the gap.",
        regular_text_options.clone(),
    );
    let multi_line_box = session.new_box(multi_line_text_boxed, box_options.clone());

    // Create a multi-line text with a box (no padding) around it
    let multi_line_text_boxed_no_padding = session.new_text(
        "This is a multi-line text box no padding.\nSecond line without padding.\nThird line gap is more pronounced.",
        regular_text_options.clone(),
    );
    let multi_line_box_no_padding = session.new_box(multi_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Text with linebreaking that causes varying line widths
    let varying_width_text = session.new_text(
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eget ligula eu lectus lobortis condimentum. Aliquam nonummy auctor massa.",
        small_text_options.clone(),
    );
    let varying_width_box = session.new_box(varying_width_text, box_options.clone());

    // Create explanation text
    let explanation = session.new_text(
        "The images above demonstrate differences in text positioning between SVG and PNG renderers. Key issues to observe:\n\n1. Vertical spacing between lines in multi-line text\n2. Text centering in boxes with and without padding\n3. Vertical alignment issues with text baseline",
        small_text_options,
    );

    // Arrange all elements in a vertical stack
    let elements = vec![
        title,
        single_line_text,
        single_line_box,
        single_line_box_no_padding,
        multi_line_text,
        multi_line_box,
        multi_line_box_no_padding,
        varying_width_box,
        explanation,
    ];

    let stack = session.ne(elements);

    // Calculate layout
    layout_tree_node(&mut session, &stack);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("text-comparison-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&session, &stack, &mut svg_file)?;
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render to PNG
    let mut png_path = temp_dir.clone();
    png_path.push("text-comparison-test.png");
    let png_renderer = PNGRenderer {};
    let mut png_file = File::create(&png_path)?;
    png_renderer.render(&session, &stack, &mut png_file)?;
    println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}
===/src/main.rs===
// Create an SVG file with all supported elements

pub mod measure_text;

//import svg_renderer
// use image_renderer::PNGRenderer;
use resvg::tiny_skia::Rect;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{RectOptions, SimpleConstraint, SizeBehavior};
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, LineOptions};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    Fill, TableOptions, TextOptions,
};
//import io modules to write to file
use measure_text::{
    measure_text_svg_character_advance,
}; // Use the ultra-tight measurement for text

use std::fs::File;



fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 0.0,
    };
    session.set_measure_text_fn(measure_text_svg_character_advance);

    //Create a polyline for a star
    let mut points = Vec::new();
    // Outer vertex
    points.push((10.0, 0.0));
    // Inner vertex
    points.push((16.0, 16.0));
    // Outer vertex
    points.push((0.0, 6.0));
    // Inner vertex
    points.push((20.0, 6.0));
    // Outer vertex
    points.push((4.0, 16.0));
    // Closing the shape by returning to the first point
    points.push((10.0, 0.0));

    let polyline = session.new_polyline(
        "star".to_string(),
        points,
        LineOptions {
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //Create horizontal stack with 2 rects and one text, set vertical align to center 
    let mut rectOpts = RectOptions::default();
    rectOpts.width_behavior =  SizeBehavior::Fixed(150.0);
    rectOpts.height_behavior = SizeBehavior::Fixed(150.0);
    rectOpts.stroke_color = "black".to_string();
    rectOpts.stroke_width = 1.0;
    let rect = session.new_rectangle("r1".to_string(), rectOpts.clone());
    let rect2 = session.new_rectangle("r2".to_string(), rectOpts.clone());


    let label = session.new_text(
        "label".to_string(),
        "Center",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            line_width: 60,
            text_color: "#333333".to_string(),
            line_spacing: 0.0,
        },
    );

    let hstack_centered = session.new_hstack(
        "hstack_centered".to_string(),
        vec![rect, label, rect2],
        volare_engine_layout::VerticalAlignment::Center
    );


    

    // Create a more visible polyline - hexagon
    let mut hex_points = Vec::new();
    let hex_size = 50.0;
    for i in 0..6 {
        let angle = (i as f32) * std::f32::consts::PI / 3.0;
        let x = hex_size * angle.cos() + hex_size;
        let y = hex_size * angle.sin() + hex_size;
        hex_points.push((x, y));
    }
    // Close the shape
    hex_points.push(hex_points[0]);

    let hexagon = session.new_polyline(
        "hexagon".to_string(),
        hex_points,
        LineOptions {
            stroke_color: "blue".to_string(),
            stroke_width: 2.0,
        },
    );

    //Create a table with 10 ellipses
    let mut table_items_ellipses: Vec<DiagramTreeNode> = Vec::new();
    for i in 0..10 {
        let ellipse = session.new_elipse(
            format!("table_ellipse_{}", i).to_string(),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        table_items_ellipses.push(ellipse);
    }
    let tableEllipses = session.new_table("table_ellipses".to_string(), table_items_ellipses, 5, TableOptions::default());

    //Create a list of 10 texts
    let mut table_items = Vec::new();
    table_items.push(hstack_centered);
    table_items.push(tableEllipses);
    table_items.push(polyline);
    table_items.push(hexagon);
    for i in 0..10 {
        let text = session.new_text(
            format!("table_text_{}", i),
            &format!("Text hey ‚ò£ {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        table_items.push(text);
        //texts.push(get_test_table(&mut session));
    }
    //Add a couple of ellipses

    //Create an ellipse and wrap it with a box
    let ellipse = session.new_elipse(
        "ellipse1".to_string(),
        (10.0, 10.0),
        EllipseOptions {
            fill_color: "red".to_string(),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //table_items.push(ellipse);

    //Now add 10 ellipses
    for i in 0..10 {
        let ellipse = session.new_elipse(
            format!("ellipse{}", i).to_string(),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        // table_items.push(ellipse);
    }

    //create a paragraph of lorem ipsum
    let lorem_ipsum = br#"
  THE adjustment \u{f1878} factor (currently font_size * 0.05) slightly shifts the text vertically to achieve better visual centering. It's a small empirical correction that helps the
  text appear more naturally centered to the human eye, rather than strictly mathematically centered.

  Without this adjustment, the text might appear slightly too high in the box, even when it's mathematically centered according to its metrics. This is particularly noticeable
  with certain fonts or at larger font sizes.

  In essence, it's an optical adjustment that helps the text look properly centered, compensating for the inherent asymmetry in font design and the way our eyes perceive text
  positioning."#;

    //create text shape
    let text = session.new_text(
        "lorem_ipsum".to_string(),
        std::str::from_utf8(lorem_ipsum).unwrap(),
        text_options.clone(),
    );
    table_items.push(text);

    //Add sample image from file (first instance)
    let sampleImage = session.new_image_from_file("imagefile0".to_string(), "demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
    //table_items.push(sampleImage);

    //Add sample image from file
    // The path is relative to where the binary is run
    let file_image = session.new_image_from_file("imagefile".to_string(), "demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
   // table_items.push(file_image);

    // Create a FreeContainer with multiple visual elements at specific positions using the new method

    // Create all elements first
    let title_text = session.new_text(
        "titletext".to_string(),
        "FreeContainer Demo",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 18.0,
            line_width: 100,
            text_color: "#000000".to_string(),
            line_spacing: 0.0,
        },
    );

    let red_circle = session.new_elipse(
        "redcircle".to_string(),
        (15.0, 15.0), // radius
        EllipseOptions {
            fill_color: "#FF0000".to_string(), // bright red
            stroke_color: "black".to_string(),
            stroke_width: 2.0,
        },
    );

    let thetext = format!(
        r#"
    Esto es un texto
    Otra linea de texto
    Otra mas...
    "#
    );

    let blue_text = session.new_text(
        "bluetext".to_string(),
        &thetext,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "white".to_string(), // white text
            line_spacing: 0.0,
        },
    );

    // Create a box around the blue text
    let box_options = BoxOptions {
        fill_color: Fill::Color("#0000FF".to_string()), // blue background
        stroke_color: "green".to_string(),              // dark blue border
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 3.0,
        width_behavior: volare_engine_layout::SizeBehavior::Fixed(700.0), // Fixed width for the box
        height_behavior: volare_engine_layout::SizeBehavior::Fixed(200.0), 
        ..BoxOptions::default()
    };
    let blue_box = session.new_box("bluebox".to_string(),blue_text, box_options);

    let green_ellipse = session.new_elipse(
        "greeneclipse".to_string(),
        (30.0, 20.0),
        EllipseOptions {
            fill_color: "#00CC00".to_string(),   // green
            stroke_color: "#006600".to_string(), // dark green
            stroke_width: 2.0,
        },
    );

    let subtitle = session.new_text(
        "test_absolute".to_string(),
        "Absolute positioning of elements",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            line_width: 100,
            text_color: "#555555".to_string(), // dark gray
            line_spacing: 0.0,
        },
    );

    // Create a container with all children at once
    let container_with_elements = session.new_free_container("containerwithelems".to_string(),vec![
        (title_text, (30.0, 10.0)),
        (red_circle, (40.0, 50.0)),
        (blue_box, (80.0, 40.0)),
        (green_ellipse, (150.0, 70.0)),
        (subtitle, (30.0, 120.0)),
    ]);

    // Add styling to the container with more vibrant colors
    let free_container = session.get_free_container_mut(container_with_elements.entity_id.clone());
    free_container.background_color = Some("#FFDDDD".to_string()); // Light red background (more visible)
    free_container.border_color = Some("#FF0000".to_string()); // Bright red border
    free_container.border_width = 5.0; // Thicker border


    // Add the FreeContainer to the table
    table_items.push(container_with_elements);


    // Create constraint layout and elements
    let elem1 = session.new_rectangle("constrained1".to_string(), RectOptions{
        width_behavior: SizeBehavior::Fixed(50.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        fill_color: Fill::Color("red".to_string()),
        stroke_color: "yellow".to_string(),
        ..Default::default()
    });
    let elem2 = session.new_rectangle("constrained2".to_string(), RectOptions{
        width_behavior: SizeBehavior::Fixed(50.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        fill_color: Fill::Color("black".to_string()),
        ..Default::default()
    });

    let constraints = vec![SimpleConstraint::AlignLeft("constrained1".to_string(), "constrained2".to_string())];
    let constraint_container = session.new_constraint_layout_container("constraint_container1".to_string(), vec![(elem1, None),(elem2, None)], constraints);
    table_items.push(constraint_container);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 2;
    let table = session.new_table("table".to_string(), table_items, 5, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render PNG
    // Use other  measure function for PNG rendering
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

// Sample image loading is now handled directly through file loading

//function that returns a sample table with 10 elements and 3 columns

/// .
fn get_test_table(session: &mut DiagramBuilder) -> DiagramTreeNode {
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 5.0,
    };
    //Create a list of 10 texts
    let mut texts = Vec::new();
    for i in 0..10 {
        let textid = format!("text_{}", i);
        let text = session.new_text(
            textid,
            &format!("Text hey {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        texts.push(text);
    }
    //create a table options object with all defaults except the header color
    let table_options = TableOptions {
        header_fill_color: "blue".to_string(),
        ..Default::default()
    };
    //Create a table for the texts with 2 columns
    let table = session.new_table("tabletexts".to_string(), texts, 3, table_options);
    table
}


