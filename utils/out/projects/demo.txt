===/Cargo.toml===
[package]
name = "demo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

#add dep to crate in local workspace
volare_engine_layout = { path = "../volare_engine_layout" }
svg_renderer = { path = "../svg_renderer" }
image_renderer = { path = "../image_renderer" }
resvg = "0.25.0"
rusttype = "0.9.3"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"

[[bin]]
name = "textdemo"
path = "src/bin/text.rs"

[[bin]]
name = "demo"
path = "src/main.rs"

[[bin]]
name = "patterns"
path = "src/bin/patterns.rs"


===/.gitignore===
/target

===/src/measure_text.rs===
use rusttype::{point, Font, Scale};
use volare_engine_layout::{Float, TextOptions};

/**
 * Measure text using SVG character advance method
 * This method calculates the width based on the advance width of each character,
 * taking into account kerning between characters.
 * It provides a more accurate width for SVG rendering, especially for variable-width fonts.
 */
pub fn measure_text_svg_character_advance(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);

    let mut total_width = 0.0;
    let mut prev_glyph_id = None;

    for ch in text.chars() {
        let glyph = font.glyph(ch).scaled(scale);

        // Use horizontal advance instead of bounding box
        let advance_width = glyph.h_metrics().advance_width;

        // Add kerning if available
        if let Some(prev_id) = prev_glyph_id {
            total_width += font.pair_kerning(scale, prev_id, glyph.id());
        }

        total_width += advance_width;
        prev_glyph_id = Some(glyph.id());
    }

    // Use font metrics for height instead of glyph bounds
    let v_metrics = font.v_metrics(scale);
    let height = v_metrics.ascent - v_metrics.descent;

    (total_width as Float, height as Float)
}

// tight measurement that accounts for actual glyph positioning
// Used for PNG rendering
pub fn measure_text_ultra_tight(text: &str, options: &TextOptions) -> (Float, Float) {
    let font_data = include_bytes!("../assets/AnonymiceProNerdFont-Regular.ttf");
    let font = Font::try_from_bytes(font_data as &[u8]).unwrap();

    let scale = Scale::uniform(options.font_size);
    let v_metrics = font.v_metrics(scale);

    if text.is_empty() {
        return (0.0, (v_metrics.ascent - v_metrics.descent) as Float);
    }

    // Use rusttype's layout function which handles everything correctly
    // TODO: Needs unicode normalization for proper glyph handling, see comments of `layout` function
    let glyphs: Vec<_> = font.layout(text, scale, point(0.0, 0.0)).collect();

    // Find the actual visual bounds
    let mut min_x = f32::INFINITY;
    let mut max_x = f32::NEG_INFINITY;

    for glyph in &glyphs {
        if let Some(bb) = glyph.pixel_bounding_box() {
            min_x = min_x.min(bb.min.x as f32);
            max_x = max_x.max(bb.max.x as f32);
        }
    }

    let width = if min_x.is_finite() && max_x.is_finite() {
        max_x - min_x // Pure visual width, no padding
    } else {
        // Fallback for whitespace
        glyphs
            .iter()
            .map(|g| g.unpositioned().h_metrics().advance_width)
            .sum()
    };

    let height = v_metrics.ascent - v_metrics.descent;

    println!("ULTRA TIGHT: '{}' -> {:.2}x{:.2}", text, width, height);
    (width as Float, height as Float)
}

===/src/bin/custom_components.rs===
// src/bin/custom_component_demo.rs
// Demo program showing how to register and use custom components

use demo::measure_text::measure_text_svg_character_advance;
use volare_engine_layout::*;
use serde_json::{json, Map, Value};
use std::fs::File;

// Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs
        .get(key)
        .and_then(|v| v.as_f64())
        .unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs
        .get(key)
        .and_then(|v| v.as_bool())
        .unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs
        .get(key)
        .and_then(|v| v.as_i64())
        .unwrap_or(default)
}

/// Custom Component 1: Badge
/// Creates a rounded pill-shaped element with text
fn create_badge_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("üè∑Ô∏è  Creating badge component with attrs: {:?}", attrs);

    // Extract attributes
    let text = get_string_attr(attrs, "text", "Badge");
    let background = get_string_attr(attrs, "background", "blue");
    let color = get_string_attr(attrs, "color", "white");
    let font_size = get_float_attr(attrs, "font_size", 12.0);
    let padding = get_float_attr(attrs, "padding", 8.0);

    // Create text element
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size,
        text_color: color,
        line_width: 200,
        line_spacing: 0.0,
    };
    let text_node = builder.new_text(&text, text_options);

    // Wrap in rounded box
    let box_options = BoxOptions {
        fill_color: Fill::Color(background),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding,
        border_radius: font_size, // Make it pill-shaped
        width_behavior: SizeBehavior::Content, // Auto width based on text
        height_behavior: SizeBehavior::Content, // Auto height based on text    
    };
    let badge = builder.new_box(text_node, box_options);

    println!("‚úÖ Badge '{}' created successfully", text);
    Ok(badge)
}

/// Custom Component 2: Alert Box
/// Creates an alert with optional icon, title, and message
fn create_alert_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("‚ö†Ô∏è  Creating alert component with attrs: {:?}", attrs);

    let alert_type = get_string_attr(attrs, "alert-type", "info");
    let title = get_string_attr(attrs, "title", "Alert");
    let message = get_string_attr(attrs, "message", "Alert message");
    let width = get_float_attr(attrs, "width", 300.0);
    let show_icon = get_bool_attr(attrs, "show_icon", true);

    // Define alert styles
    let (bg_color, border_color, icon) = match alert_type.as_str() {
        "success" => ("#d4edda", "#28a745", "‚úì"),
        "warning" => ("#fff3cd", "#ffc107", "‚ö†"),
        "error" => ("#f8d7da", "#dc3545", "‚úó"),
        "info" | _ => ("#d1ecf1", "#17a2b8", "‚Ñπ"),
    };

    let mut children = Vec::new();

    // Create header with optional icon
    if show_icon {
        let icon_text = builder.new_text(icon, TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 18.0,
            text_color: border_color.to_string(),
            line_width: 50,
            line_spacing: 0.0,
        });

        let title_text = builder.new_text(&title, TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            text_color: "#333".to_string(),
            line_width: (width - 50.0) as usize,
            line_spacing: 0.0,
        });

        let header = builder.new_hstack(vec![icon_text, title_text], VerticalAlignment::Center);
        children.push(header);
    } else {
        let title_text = builder.new_text(&title, TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            text_color: "#333".to_string(),
            line_width: width as usize,
            line_spacing: 0.0,
        });
        children.push(title_text);
    }

    // Add message
    let message_text = builder.new_text(&message, TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 14.0,
        text_color: "#666".to_string(),
        line_width: width as usize,
        line_spacing: 2.0,
    });
    children.push(message_text);

    // Create vertical layout
    let content = builder.new_vstack(children, HorizontalAlignment::Left);

    // Wrap in styled box
    let alert_box = builder.new_box(content, BoxOptions {
        fill_color: Fill::Color(bg_color.to_string()),
        stroke_color: border_color.to_string(),
        stroke_width: 1.0,
        padding: 16.0,
        border_radius: 8.0,
        width_behavior: SizeBehavior::Fixed(width),
        height_behavior: SizeBehavior::Content, // Auto height based on content
    });

    println!("‚úÖ Alert '{}' ({}) created successfully", title, alert_type);
    Ok(alert_box)
}

/// Custom Component 3: Progress Bar
/// Creates a progress bar with background and fill
fn create_progress_bar_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("üìä Creating progress bar component with attrs: {:?}", attrs);

    let width = get_float_attr(attrs, "width", 200.0);
    let height = get_float_attr(attrs, "height", 20.0);
    let progress = get_float_attr(attrs, "progress", 0.5).min(1.0).max(0.0);
    let bg_color = get_string_attr(attrs, "bg_color", "lightgray");
    let fill_color = get_string_attr(attrs, "fill_color", "blue");
    let show_text = get_bool_attr(attrs, "show_text", false);

    // Create background bar
    let bg_rect = builder.new_rectangle(RectOptions {
        width_behavior: SizeBehavior::Fixed(width),
        height_behavior: SizeBehavior::Fixed(height),
        fill_color: Fill::Color(bg_color),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        border_radius: height / 2.0,
    });

    // Create progress fill
    let fill_width = width * progress;
    let fill_rect = builder.new_rectangle(RectOptions {
        width_behavior: SizeBehavior::Fixed(fill_width),
        height_behavior: SizeBehavior::Fixed(height),
        fill_color: Fill::Color(fill_color),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        border_radius: height / 2.0,
    });

    let mut elements = vec![
        (bg_rect, (0.0, 0.0)),
        (fill_rect, (0.0, 0.0)),
    ];

    // Add percentage text if requested
    if show_text {
        let percentage = (progress * 100.0) as i32;
        let text_node = builder.new_text(&format!("{}%", percentage), TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: height * 0.7,
            text_color: "black".to_string(),
            line_width: 100,
            line_spacing: 0.0,
        });
        // Center the text roughly
        let text_x = (width - 30.0) / 2.0; // Rough centering
        let text_y = height * 0.15;
        elements.push((text_node, (text_x, text_y)));
    }

    let progress_bar = builder.new_free_container_with_children(elements);

    println!("‚úÖ Progress bar ({}%) created successfully", (progress * 100.0) as i32);
    Ok(progress_bar)
}

/// Custom Component 4: Button
/// Creates a clickable button with text
fn create_button_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    println!("üîò Creating button component with attrs: {:?}", attrs);

    let text = get_string_attr(attrs, "text", "Button");
    let variant = get_string_attr(attrs, "variant", "primary");
    let size = get_string_attr(attrs, "size", "medium");
    let disabled = get_bool_attr(attrs, "disabled", false);

    // Define button styles based on variant
    let (bg_color, text_color, border_color) = if disabled {
        ("#cccccc", "#666666", "#999999")
    } else {
        match variant.as_str() {
            "primary" => ("#007bff", "white", "#0056b3"),
            "secondary" => ("#6c757d", "white", "#545b62"),
            "success" => ("#28a745", "white", "#1e7e34"),
            "danger" => ("#dc3545", "white", "#bd2130"),
            "warning" => ("#ffc107", "#212529", "#d39e00"),
            _ => ("#007bff", "white", "#0056b3"),
        }
    };

    // Define size-based properties
    let (font_size, padding_x, padding_y) = match size.as_str() {
        "small" => (12.0, 12.0, 6.0),
        "large" => (18.0, 24.0, 12.0),
        _ => (14.0, 16.0, 8.0), // medium
    };

    // Create button text
    let button_text = builder.new_text(&text, TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size,
        text_color: text_color.to_string(),
        line_width: 200,
        line_spacing: 0.0,
    });

    // Wrap in styled box
    let button = builder.new_box(button_text, BoxOptions {
        fill_color: Fill::Color(bg_color.to_string()),
        stroke_color: border_color.to_string(),
        stroke_width: 1.0,
        padding: f32::max(padding_x, padding_y), // Use max for uniform padding
        border_radius: 4.0,
        width_behavior: SizeBehavior::Content, // Auto width based on text
        height_behavior: SizeBehavior::Content, // Auto height based on text
    });

    println!("‚úÖ Button '{}' ({}, {}) created successfully", text, variant, size);
    Ok(button)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üöÄ Custom Component Demo Starting...\n");

    // Create diagram builder and set text measurement function
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all our custom components
    println!("üìù Registering custom components...");
    builder.register_custom_component("badge", create_badge_component);
    builder.register_custom_component("alert", create_alert_component);
    builder.register_custom_component("progress_bar", create_progress_bar_component);
    builder.register_custom_component("button", create_button_component);
    println!("‚úÖ All custom components registered!\n");

    // Demo 1: Direct usage with Rust API
    println!("=== Demo 1: Direct Rust API Usage ===");
    
    // Create components directly
    let badge_attrs = json!({
        "text": "NEW",
        "background": "red",
        "color": "white",
        "font_size": 14.0,
        "padding": 10.0
    }).as_object().unwrap().clone();

    let _badge = builder.create_custom_component("badge", &badge_attrs)?;

    let alert_attrs = json!({
        "type": "success",
        "title": "Success!",
        "message": "Your custom component system is working perfectly!",
        "width": 400.0,
        "show_icon": true
    }).as_object().unwrap().clone();

    let _alert = builder.create_custom_component("alert", &alert_attrs)?;

    println!("‚úÖ Direct API usage successful!\n");

    // Demo 2: JSON Lines usage
    println!("=== Demo 2: JSON Lines Usage ===");
    
    let jsonl_input = r##"
{"id":"root","type":"vstack","children":["title","demo_section","buttons_section","progress_section","alerts_section"],"h_align":"center"}
{"id":"title","type":"text","content":"üé® Custom Components Showcase","font_size":25,"color":"darkblue"}
{"id":"demo_section","type":"hstack","children":["badge1","badge2","badge3"],"v_align":"center"}
{"id":"badge1","type":"badge","text":"NEW","background":"#ff4444","color":"white","font_size":12,"padding":8}
{"id":"badge2","type":"badge","text":"SALE","background":"#44ff44","color":"black","font_size":12,"padding":8}
{"id":"badge3","type":"badge","text":"HOT","background":"#ff8800","color":"white","font_size":12,"padding":8}
{"id":"buttons_section","type":"hstack","children":["btn1","btn2","btn3","btn4"],"v_align":"center"}
{"id":"btn1","type":"button","text":"Primary","variant":"primary","size":"medium"}
{"id":"btn2","type":"button","text":"Success","variant":"success","size":"medium"}
{"id":"btn3","type":"button","text":"Warning","variant":"warning","size":"medium"}
{"id":"btn4","type":"button","text":"Disabled","variant":"secondary","size":"medium","disabled":true}
{"id":"progress_section","type":"vstack","children":["progress1","progress2","progress3"],"h_align":"center"}
{"id":"progress1","type":"progress_bar","width":300,"height":20,"progress":0.25,"fill_color":"#ff4444","show_text":true}
{"id":"progress2","type":"progress_bar","width":300,"height":20,"progress":0.65,"fill_color":"#44ff44","show_text":true}
{"id":"progress3","type":"progress_bar","width":300,"height":20,"progress":0.90,"fill_color":"#4444ff","show_text":true}
{"id":"alerts_section","type":"vstack","children":["alert1","alert2","alert3","alert4"],"h_align":"left"}
{"id":"alert1","type":"alert","alert-type":"success","title":"Success Alert","message":"Everything is working perfectly! Your custom components are rendering correctly.","width":500,"show_icon":true}
{"id":"alert2","type":"alert","alert-type":"warning","title":"Warning Alert","message":"This is a warning message to demonstrate the warning alert style.","width":500,"show_icon":true}
{"id":"alert3","type":"alert","alert-type":"error","title":"Error Alert","message":"This shows how error messages would appear in your application.","width":500,"show_icon":true}
{"id":"alert4","type":"alert","alert-type":"info","title":"Info Alert","message":"Here's some informational content using the info alert component.","width":500,"show_icon":true}
"##;

    // Parse the JSON Lines
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;
    
    // Create a fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);
    
    // Register components with the parse builder
    parse_builder.register_custom_component("badge", create_badge_component);
    parse_builder.register_custom_component("alert", create_alert_component);
    parse_builder.register_custom_component("progress_bar", create_progress_bar_component);
    parse_builder.register_custom_component("button", create_button_component);
    
    // Build the diagram
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    println!("‚úÖ JSON Lines parsing successful!");
    
    // Calculate layout
    println!("üìê Calculating layout...");
    layout::layout_tree_node(&mut parse_builder, &diagram);
    println!("‚úÖ Layout calculation complete!");

    // Demo 3: Render to SVG
    println!("\n=== Demo 3: SVG Rendering ===");
    
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("custom-components-showcase.svg");
    
    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;
    
    println!("‚úÖ SVG rendered successfully!");
    println!("üìÑ File saved to: {}", svg_path.to_str().unwrap());

    

    // Demo 4: Statistics
    println!("\n=== Demo 4: Component Statistics ===");
    let registered_types = parse_builder.get_custom_component_types();
    println!("üìä Registered custom components: {:?}", registered_types);
    println!("üî¢ Total custom components: {}", registered_types.len());
    
    // Count components in the diagram
    fn count_custom_components(node: &diagram_builder::DiagramTreeNode, types: &[&String]) -> usize {
        let mut count = 0;
        if types.iter().any(|t| t.as_str() == format!("{:?}", node.entity_type)) {
            count += 1;
        }
        for child in &node.children {
            count += count_custom_components(child, types);
        }
        count
    }
    
    let custom_count = count_custom_components(&diagram, &registered_types);
    println!("üéØ Custom components in diagram: {}", custom_count);

    println!("\nüéâ Custom Component Demo Complete!");
    println!("üí° Check the generated SVG file to see your custom components in action!");
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        }).as_object().unwrap().clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);
        builder.register_custom_component("alert", create_alert_component);
        builder.register_custom_component("progress_bar", create_progress_bar_component);
        builder.register_custom_component("button", create_button_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 4);
        assert!(builder.has_custom_component("badge"));
        assert!(builder.has_custom_component("alert"));
        assert!(builder.has_custom_component("progress_bar"));
        assert!(builder.has_custom_component("button"));
    }

    #[test]
    fn test_jsonl_with_custom_components() {
        let input = r#"
{"id":"root","type":"badge","text":"Test Badge","background":"red"}
"#;

        let mut parser = parser::JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(measure_text_svg_character_advance);
        builder.register_custom_component("badge", create_badge_component);
        
        let result = parser.build(&root_id, &mut builder);
        assert!(result.is_ok());
    }
}

===/src/bin/sample_components.rs===
// src/bin/useful_components_demo.rs
// A library of practical custom components for real-world usage

use demo::measure_text::measure_text_svg_character_advance;
use serde_json::{json, Map, Value};
use std::fs::File;
use volare_engine_layout::*;

// Helper functions for attribute extraction
fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
    attrs
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
    attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
}

fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
    attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
}

fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
    attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Vec<String> {
    attrs
        .get(key)
        .and_then(|v| v.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default()
}

/// Card Component - A flexible container with header, body, and footer
fn create_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let content = get_string_attr(attrs, "content", "");
    let footer = get_string_attr(attrs, "footer", "");
    let width = get_float_attr(attrs, "width", 300.0);
    let padding = get_float_attr(attrs, "padding", 16.0);
    let border_radius = get_float_attr(attrs, "border_radius", 8.0);
    let shadow = get_bool_attr(attrs, "shadow", true);
    let variant = get_string_attr(attrs, "variant", "default");

    // Define card styles based on variant
    let (bg_color, border_color) = match variant.as_str() {
        "primary" => ("#ffffff", "#007bff"),
        "success" => ("#f8fff8", "#28a745"),
        "warning" => ("#fffdf0", "#ffc107"),
        "danger" => ("#fff8f8", "#dc3545"),
        _ => ("#ffffff", "#e0e0e0"),
    };

    let mut children = Vec::new();

    // Add title if provided
    if !title.is_empty() {
        let title_text = builder.new_text(
            &title,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 18.0,
                text_color: "#333333".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(title_text);
    }

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_text = builder.new_text(
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#666666".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_text);
    }

    // Add content if provided
    if !content.is_empty() {
        let content_text = builder.new_text(
            &content,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#444444".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 4.0,
            },
        );
        children.push(content_text);
    }

    // Add footer if provided
    if !footer.is_empty() {
        let footer_text = builder.new_text(
            &footer,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#888888".to_string(),
                line_width: (width - padding * 2.0) as usize,
                line_spacing: 0.0,
            },
        );
        children.push(footer_text);
    }

    // Create layout
    let content_stack = builder.new_vstack(children, HorizontalAlignment::Left);

    // Apply shadow effect by creating multiple boxes
    if shadow {
        // Shadow box (slightly offset)
        let shadow_box = builder.new_box(
            content_stack,
            BoxOptions {
                fill_color: Fill::Color("#00000010".to_string()),
                stroke_color: "transparent".to_string(),
                stroke_width: 0.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );

        // Main card box
        let main_content = builder.new_rectangle(RectOptions {
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
            fill_color: Fill::Color(bg_color.to_string()),
            stroke_color: border_color.to_string(),
            stroke_width: 1.0,
            border_radius,
        });

        // Use free container to overlay them
        let card = builder.new_free_container_with_children(vec![
            (shadow_box, (2.0, 2.0)),   // Shadow slightly offset
            (main_content, (0.0, 0.0)), // Main card on top
        ]);
        Ok(card)
    } else {
        let card = builder.new_box(
            content_stack,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: 1.0,
                padding,
                border_radius,
                width_behavior: SizeBehavior::Fixed(width),
                height_behavior: SizeBehavior::Content,
            },
        );
        Ok(card)
    }
}

/// List Component - Creates a styled list with bullets or numbers
fn create_list_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let list_type = get_string_attr(attrs, "list_type", "bullet"); // bullet, number, check
    let spacing = get_float_attr(attrs, "spacing", 4.0);
    let width = get_float_attr(attrs, "width", 300.0);
    let font_size = get_float_attr(attrs, "font_size", 14.0);

    if items.is_empty() {
        return Err("List component requires 'items' array".to_string());
    }

    let mut list_children = Vec::new();

    for (index, item) in items.iter().enumerate() {
        // Create bullet/number
        let marker = match list_type.as_str() {
            "number" => format!("{}.", index + 1),
            "check" => "‚úì".to_string(),
            "arrow" => "‚Üí".to_string(),
            _ => "‚Ä¢".to_string(), // bullet
        };

        let marker_text = builder.new_text(
            &marker,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#666666".to_string(),
                line_width: 30,
                line_spacing: 0.0,
            },
        );

        let item_text = builder.new_text(
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size,
                text_color: "#333333".to_string(),
                line_width: (width - 40.0) as usize,
                line_spacing: 0.0,
            },
        );

        let list_item = builder.new_hstack(vec![marker_text, item_text], VerticalAlignment::Top);
        list_children.push(list_item);
    }

    let list = builder.new_vstack(list_children, HorizontalAlignment::Left);
    Ok(list)
}

/// Form Field Component - Creates labeled input-like elements
fn create_form_field_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let label = get_string_attr(attrs, "label", "Field");
    let placeholder = get_string_attr(attrs, "placeholder", "Enter value...");
    let field_type = get_string_attr(attrs, "field_type", "text"); // text, email, password, textarea
    let required = get_bool_attr(attrs, "required", false);
    let width = get_float_attr(attrs, "width", 250.0);
    let error = get_string_attr(attrs, "error", "");

    let mut children = Vec::new();

    // Create label
    let label_text = if required {
        format!("{} *", label)
    } else {
        label
    };

    let label_node = builder.new_text(
        &label_text,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: if required { "#333333" } else { "#666666" }.to_string(),
            line_width: width as usize,
            line_spacing: 0.0,
        },
    );
    children.push(label_node);

    // Create input field representation
    let field_height = match field_type.as_str() {
        "textarea" => 60.0,
        _ => 36.0,
    };

    let placeholder_text = builder.new_text(
        &placeholder,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#999999".to_string(),
            line_width: (width - 24.0) as usize,
            line_spacing: 0.0,
        },
    );

    let input_field = builder.new_box(
        placeholder_text,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: if !error.is_empty() {
                "#dc3545"
            } else {
                "#cccccc"
            }
            .to_string(),
            stroke_width: 1.0,
            padding: 12.0,
            border_radius: 4.0,
            width_behavior: SizeBehavior::Fixed(width),
            height_behavior: SizeBehavior::Fixed(field_height),
        },
    );
    children.push(input_field);

    // Add error message if present
    if !error.is_empty() {
        let error_text = builder.new_text(
            &error,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#dc3545".to_string(),
                line_width: width as usize,
                line_spacing: 0.0,
            },
        );
        children.push(error_text);
    }

    let form_field = builder.new_vstack(children, HorizontalAlignment::Left);
    Ok(form_field)
}

/// Stats Card Component - Displays key metrics with icons
fn create_stats_card_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Metric");
    let value = get_string_attr(attrs, "value", "0");
    let change = get_string_attr(attrs, "change", "");
    let icon = get_string_attr(attrs, "icon", "üìä");
    let trend = get_string_attr(attrs, "trend", "neutral"); // up, down, neutral
    let color = get_string_attr(attrs, "color", "#007bff");

    // Determine trend color and symbol
    let (trend_color, trend_symbol) = match trend.as_str() {
        "up" => ("#28a745", "‚Üó"),
        "down" => ("#dc3545", "‚Üò"),
        _ => ("#6c757d", "‚Üí"),
    };

    // Create icon
    let icon_text = builder.new_text(
        &icon,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            text_color: color,
            line_width: 50,
            line_spacing: 0.0,
        },
    );

    // Create value and title section
    let value_text = builder.new_text(
        &value,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 28.0,
            text_color: "#333333".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let title_text = builder.new_text(
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            text_color: "#666666".to_string(),
            line_width: 150,
            line_spacing: 0.0,
        },
    );

    let mut right_children = vec![value_text, title_text];

    // Add change indicator if provided
    if !change.is_empty() {
        let change_text = format!("{} {}", trend_symbol, change);
        let change_node = builder.new_text(
            &change_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: trend_color.to_string(),
                line_width: 150,
                line_spacing: 0.0,
            },
        );
        right_children.push(change_node);
    }

    let right_section = builder.new_vstack(right_children, HorizontalAlignment::Left);
    let content = builder.new_hstack(vec![icon_text, right_section], VerticalAlignment::Center);

    let stats_card = builder.new_box(
        content,
        BoxOptions {
            fill_color: Fill::Color("#ffffff".to_string()),
            stroke_color: "#e0e0e0".to_string(),
            stroke_width: 1.0,
            padding: 20.0,
            border_radius: 8.0,
            width_behavior: SizeBehavior::Fixed(300.0),
            height_behavior: SizeBehavior::Content,
        },
    );

    Ok(stats_card)
}

/// Navigation Menu Component - Creates a horizontal or vertical menu
fn create_nav_menu_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let items = get_array_attr(attrs, "items");
    let orientation = get_string_attr(attrs, "orientation", "horizontal"); // horizontal, vertical
    let active_item = get_string_attr(attrs, "active_item", "");
    let style = get_string_attr(attrs, "style", "default"); // default, pills, tabs

    if items.is_empty() {
        return Err("Navigation menu requires 'items' array".to_string());
    }

    let mut nav_children = Vec::new();

    for item in items.iter() {
        let is_active = item == &active_item;

        // Style based on state and style type
        let (bg_color, text_color, border_color) = match (is_active, style.as_str()) {
            (true, "pills") => ("#007bff", "#ffffff", "#007bff"),
            (false, "pills") => ("transparent", "#007bff", "transparent"),
            (true, "tabs") => ("#ffffff", "#007bff", "#007bff"),
            (false, "tabs") => ("transparent", "#666666", "#e0e0e0"),
            (true, _) => ("transparent", "#007bff", "transparent"),
            (false, _) => ("transparent", "#666666", "transparent"),
        };

        let nav_text = builder.new_text(
            item,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: text_color.to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );

        let nav_item = builder.new_box(
            nav_text,
            BoxOptions {
                fill_color: Fill::Color(bg_color.to_string()),
                stroke_color: border_color.to_string(),
                stroke_width: if style == "tabs" { 1.0 } else { 0.0 },
                padding: 12.0,
                border_radius: if style == "pills" { 20.0 } else { 4.0 },
                width_behavior: SizeBehavior::Content,
                height_behavior: SizeBehavior::Content,
            },
        );

        nav_children.push(nav_item);
    }

    let nav_menu = match orientation.as_str() {
        "vertical" => builder.new_vstack(nav_children, HorizontalAlignment::Left),
        _ => builder.new_hstack(nav_children, VerticalAlignment::Center),
    };

    Ok(nav_menu)
}

/// Header Component - Creates page headers with optional breadcrumbs
fn create_header_component(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
) -> Result<diagram_builder::DiagramTreeNode, String> {
    let title = get_string_attr(attrs, "title", "Page Title");
    let subtitle = get_string_attr(attrs, "subtitle", "");
    let breadcrumbs = get_array_attr(attrs, "breadcrumbs");
    let show_back = get_bool_attr(attrs, "show_back", false);

    let mut children = Vec::new();

    // Add breadcrumbs if provided
    if !breadcrumbs.is_empty() {
        let breadcrumb_text = breadcrumbs.join(" > ");
        let breadcrumb_node = builder.new_text(
            &breadcrumb_text,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 12.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(breadcrumb_node);
    }

    // Add back button if requested
    if show_back {
        let back_text = builder.new_text(
            "‚Üê Back",
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 14.0,
                text_color: "#007bff".to_string(),
                line_width: 100,
                line_spacing: 0.0,
            },
        );
        children.push(back_text);
    }

    // Add main title
    let title_node = builder.new_text(
        &title,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 32.0,
            text_color: "#333333".to_string(),
            line_width: 600,
            line_spacing: 0.0,
        },
    );
    children.push(title_node);

    // Add subtitle if provided
    if !subtitle.is_empty() {
        let subtitle_node = builder.new_text(
            &subtitle,
            TextOptions {
                font_family: "AnonymicePro Nerd Font".to_string(),
                font_size: 16.0,
                text_color: "#666666".to_string(),
                line_width: 600,
                line_spacing: 0.0,
            },
        );
        children.push(subtitle_node);
    }

    let header = builder.new_vstack(children, HorizontalAlignment::Left);
    Ok(header)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üöÄ Useful Components Demo Starting...\n");

    // Create diagram builder and register components
    let mut builder = DiagramBuilder::new();
    builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register all useful components
    println!("üìù Registering useful components...");
    builder.register_custom_component("card", create_card_component);
    builder.register_custom_component("list", create_list_component);
    builder.register_custom_component("form_field", create_form_field_component);
    builder.register_custom_component("stats_card", create_stats_card_component);
    builder.register_custom_component("nav_menu", create_nav_menu_component);
    builder.register_custom_component("header", create_header_component);
    println!("‚úÖ All useful components registered!\n");

    // The JSONL content - Real-world dashboard example
    let jsonl_input = r##"{"id":"root","type":"vstack","children":["main_header","nav","dashboard_content"],"h_align":"center"}
{"id":"main_header","type":"header","title":"Analytics Dashboard","subtitle":"Monitor your key metrics and performance indicators","breadcrumbs":["Home","Analytics","Dashboard"]}
{"id":"nav","type":"nav_menu","items":["Overview","Analytics","Reports","Settings"],"active_item":"Analytics","style":"tabs","orientation":"horizontal"}
{"id":"dashboard_content","type":"vstack","children":["stats_row","charts_row","recent_activity"],"h_align":"center"}
{"id":"stats_row","type":"hstack","children":["stats1","stats2","stats3","stats4"],"v_align":"top"}
{"id":"stats1","type":"stats_card","title":"Total Users","value":"12,345","change":"+12.5%","trend":"up","icon":"üë•","color":"#007bff"}
{"id":"stats2","type":"stats_card","title":"Revenue","value":"$89,432","change":"+8.2%","trend":"up","icon":"üí∞","color":"#28a745"}
{"id":"stats3","type":"stats_card","title":"Orders","value":"1,234","change":"-2.1%","trend":"down","icon":"üì¶","color":"#ffc107"}
{"id":"stats4","type":"stats_card","title":"Conversion","value":"3.24%","change":"+0.8%","trend":"up","icon":"üìà","color":"#17a2b8"}
{"id":"charts_row","type":"hstack","children":["performance_card","recent_orders_card"],"v_align":"top"}
{"id":"performance_card","type":"card","title":"Performance Metrics","content":"Your application performance has improved by 23% this month. Server response times are optimal and user engagement is at an all-time high.","footer":"Last updated: 2 minutes ago","width":400,"variant":"primary","shadow":true}
{"id":"recent_orders_card","type":"card","title":"Recent Orders","width":400,"variant":"default","shadow":true,"children":["orders_list"]}
{"id":"orders_list","type":"list","items":["Order #1234 - $299.99 - Processing","Order #1235 - $156.78 - Shipped","Order #1236 - $89.50 - Delivered","Order #1237 - $445.20 - Processing"],"list_type":"number","spacing":6,"width":350}
{"id":"recent_activity","type":"vstack","children":["activity_header","activity_content"],"h_align":"left"}
{"id":"activity_header","type":"text","content":"Recent Activity","font_size":20,"color":"#333333"}
{"id":"activity_content","type":"hstack","children":["activity_list","user_form"],"v_align":"top"}
{"id":"activity_list","type":"list","items":["User john.doe logged in","New order received (#1238)","Payment processed for order #1235","User jane.smith updated profile","System backup completed","New user registration: mike.wilson"],"list_type":"arrow","width":400,"font_size":13}
{"id":"user_form","type":"vstack","children":["form_title","name_field","email_field","message_field","submit_section"],"h_align":"left"}
{"id":"form_title","type":"text","content":"Quick Contact","font_size":18,"color":"#333333"}
{"id":"name_field","type":"form_field","label":"Full Name","placeholder":"Enter your full name","required":true,"width":300}
{"id":"email_field","type":"form_field","label":"Email Address","placeholder":"your.email@company.com","field_type":"email","required":true,"width":300}
{"id":"message_field","type":"form_field","label":"Message","placeholder":"Type your message here...","field_type":"textarea","width":300}
{"id":"submit_section","type":"card","content":"Form ready to submit","footer":"All fields are validated","width":300,"variant":"success"}"##;

    // Parse and build the diagram
    let mut parser = parser::JsonLinesParser::new();
    let root_id = parser.parse_string(jsonl_input)?;

    // Create fresh builder for parsing
    let mut parse_builder = DiagramBuilder::new();
    parse_builder.set_measure_text_fn(measure_text_svg_character_advance);

    // Register components
    parse_builder.register_custom_component("card", create_card_component);
    parse_builder.register_custom_component("list", create_list_component);
    parse_builder.register_custom_component("form_field", create_form_field_component);
    parse_builder.register_custom_component("stats_card", create_stats_card_component);
    parse_builder.register_custom_component("nav_menu", create_nav_menu_component);
    parse_builder.register_custom_component("header", create_header_component);

    // Build and layout
    let diagram = parser.build(&root_id, &mut parse_builder)?;
    layout::layout_tree_node(&mut parse_builder, &diagram);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("useful-components-dashboard.svg");

    let svg_renderer = svg_renderer::SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&parse_builder, &diagram, &mut svg_file)?;

    println!("‚úÖ Dashboard rendered successfully!");
    println!("üìÑ File saved to: {}", svg_path.to_str().unwrap());
    println!("\nüéâ Useful Components Demo Complete!");

    Ok(())
}

===/src/lib.rs===
pub mod measure_text; 

===/src/text_renderer_comparison.rs===
// Text Renderer Comparison Test
// This file demonstrates the differences in text positioning and spacing
// between the SVG and PNG renderers

use image_renderer::PNGRenderer;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{
    renderer_base::Renderer,
    BoxOptions,
    TextOptions,
    Fill,
    DiagramBuilder,
    layout::layout_tree_node,
};

// Import measurement function
use crate::measure_text::measure_text;
use std::fs::File;

pub fn run_comparison_test() -> Result<(), Box<dyn std::error::Error>> {
    // Create session
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(measure_text);

    // Create options for the test
    let title_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 18.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let regular_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 14.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let small_text_options = TextOptions {
        font_family: "Roboto".to_string(),
        font_size: 12.0,
        line_width: 500,
        text_color: "black".to_string(),
    };

    let box_options = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 0.0,
    };

    let box_options_no_padding = BoxOptions {
        fill_color: Fill::Color("#EEEEEE".to_string()),
        stroke_color: "#999999".to_string(),
        stroke_width: 1.0,
        padding: 0.0,
        border_radius: 0.0,
    };

    // Create title
    let title = session.new_text(
        "Text Rendering Comparison",
        title_text_options,
    );

    // Create a simple single-line text
    let single_line_text = session.new_text(
        "This is a single line of text.",
        regular_text_options.clone(),
    );
    
    // Create a simple single-line text with a box around it
    let single_line_text_boxed = session.new_text(
        "This is a single line with a box.",
        regular_text_options.clone(),
    );
    let single_line_box = session.new_box(single_line_text_boxed, box_options.clone());

    // Create a simple single-line text with a box around it (no padding)
    let single_line_text_boxed_no_padding = session.new_text(
        "Single line box without padding.",
        regular_text_options.clone(),
    );
    let single_line_box_no_padding = session.new_box(single_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Create a multi-line text example
    let multi_line_text = session.new_text(
        "This is a multi-line text example.\nSecond line of text.\nThird line for testing purposes.",
        regular_text_options.clone(),
    );

    // Create a multi-line text with a box around it
    let multi_line_text_boxed = session.new_text(
        "This is a multi-line text with a box.\nSecond line of text.\nThird line demonstrates the gap.",
        regular_text_options.clone(),
    );
    let multi_line_box = session.new_box(multi_line_text_boxed, box_options.clone());

    // Create a multi-line text with a box (no padding) around it
    let multi_line_text_boxed_no_padding = session.new_text(
        "This is a multi-line text box no padding.\nSecond line without padding.\nThird line gap is more pronounced.",
        regular_text_options.clone(),
    );
    let multi_line_box_no_padding = session.new_box(multi_line_text_boxed_no_padding, box_options_no_padding.clone());

    // Text with linebreaking that causes varying line widths
    let varying_width_text = session.new_text(
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eget ligula eu lectus lobortis condimentum. Aliquam nonummy auctor massa.",
        small_text_options.clone(),
    );
    let varying_width_box = session.new_box(varying_width_text, box_options.clone());

    // Create explanation text
    let explanation = session.new_text(
        "The images above demonstrate differences in text positioning between SVG and PNG renderers. Key issues to observe:\n\n1. Vertical spacing between lines in multi-line text\n2. Text centering in boxes with and without padding\n3. Vertical alignment issues with text baseline",
        small_text_options,
    );

    // Arrange all elements in a vertical stack
    let elements = vec![
        title,
        single_line_text,
        single_line_box,
        single_line_box_no_padding,
        multi_line_text,
        multi_line_box,
        multi_line_box_no_padding,
        varying_width_box,
        explanation,
    ];

    let stack = session.ne(elements);

    // Calculate layout
    layout_tree_node(&mut session, &stack);

    // Render to SVG
    let temp_dir = std::env::temp_dir();
    let mut svg_path = temp_dir.clone();
    svg_path.push("text-comparison-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path)?;
    svg_renderer.render(&session, &stack, &mut svg_file)?;
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render to PNG
    let mut png_path = temp_dir.clone();
    png_path.push("text-comparison-test.png");
    let png_renderer = PNGRenderer {};
    let mut png_file = File::create(&png_path)?;
    png_renderer.render(&session, &stack, &mut png_file)?;
    println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}
===/src/main.rs===
// Create an SVG file with all supported elements

pub mod measure_text;

//import svg_renderer
use image_renderer::PNGRenderer;
use resvg::tiny_skia::Rect;
use svg_renderer::SVGRenderer;
use volare_engine_layout::{RectOptions, SizeBehavior};
use volare_engine_layout::{renderer_base::Renderer, BoxOptions, GradientStop, LineOptions};

//import layout
use volare_engine_layout::{
    diagram_builder::DiagramTreeNode, layout::layout_tree_node, DiagramBuilder, EllipseOptions,
    Fill, TableOptions, TextOptions,
};
//import io modules to write to file
use measure_text::{
    measure_text_svg_character_advance,
}; // Use the ultra-tight measurement for text

use std::fs::File;



fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create session
    let mut session = DiagramBuilder::new();
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 0.0,
    };
    session.set_measure_text_fn(measure_text_svg_character_advance);

    //Create a polyline for a star
    let mut points = Vec::new();
    // Outer vertex
    points.push((10.0, 0.0));
    // Inner vertex
    points.push((16.0, 16.0));
    // Outer vertex
    points.push((0.0, 6.0));
    // Inner vertex
    points.push((20.0, 6.0));
    // Outer vertex
    points.push((4.0, 16.0));
    // Closing the shape by returning to the first point
    points.push((10.0, 0.0));

    let polyline = session.new_polyline(
        points,
        LineOptions {
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //Create horizontal stack with 2 rects and one text, set vertical align to center 
    let mut rectOpts = RectOptions::default();
    rectOpts.width_behavior =  SizeBehavior::Fixed(150.0);
    rectOpts.height_behavior = SizeBehavior::Fixed(150.0);
    rectOpts.stroke_color = "black".to_string();
    rectOpts.stroke_width = 1.0;
    let rect = session.new_rectangle(rectOpts.clone());
    let rect2 = session.new_rectangle(rectOpts.clone());


    let label = session.new_text(
        "Center",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 14.0,
            line_width: 60,
            text_color: "#333333".to_string(),
            line_spacing: 0.0,
        },
    );

    let hstack_centered = session.new_hstack(
        vec![rect, label, rect2],
        volare_engine_layout::VerticalAlignment::Center
    );


    

    // Create a more visible polyline - hexagon
    let mut hex_points = Vec::new();
    let hex_size = 50.0;
    for i in 0..6 {
        let angle = (i as f32) * std::f32::consts::PI / 3.0;
        let x = hex_size * angle.cos() + hex_size;
        let y = hex_size * angle.sin() + hex_size;
        hex_points.push((x, y));
    }
    // Close the shape
    hex_points.push(hex_points[0]);

    let hexagon = session.new_polyline(
        hex_points,
        LineOptions {
            stroke_color: "blue".to_string(),
            stroke_width: 2.0,
        },
    );

    //Create a table with 10 ellipses
    let mut table_items_ellipses: Vec<DiagramTreeNode> = Vec::new();
    for i in 0..10 {
        let ellipse = session.new_elipse(
            (0.0, 0.0),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        table_items_ellipses.push(ellipse);
    }
    let tableEllipses = session.new_table(table_items_ellipses, 5, TableOptions::default());

    //Create a list of 10 texts
    let mut table_items = Vec::new();
    table_items.push(hstack_centered);
    table_items.push(tableEllipses);
    table_items.push(polyline);
    table_items.push(hexagon);
    for i in 0..10 {
        let text = session.new_text(
            &format!("Text hey ‚ò£ {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        table_items.push(text);
        //texts.push(get_test_table(&mut session));
    }
    //Add a couple of ellipses

    //Create an ellipse and wrap it with a box
    let ellipse = session.new_elipse(
        (0.0, 0.0),
        (10.0, 10.0),
        EllipseOptions {
            fill_color: "red".to_string(),
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
        },
    );

    //table_items.push(ellipse);

    //Now add 10 ellipses
    for i in 0..10 {
        let ellipse = session.new_elipse(
            (0.0, 0.0),
            (10.0, 10.0),
            EllipseOptions {
                fill_color: "red".to_string(),
                stroke_color: "black".to_string(),
                stroke_width: 1.0,
            },
        );
        // table_items.push(ellipse);
    }

    //create a paragraph of lorem ipsum
    let lorem_ipsum = br#"
  THE adjustment \u{f1878} factor (currently font_size * 0.05) slightly shifts the text vertically to achieve better visual centering. It's a small empirical correction that helps the
  text appear more naturally centered to the human eye, rather than strictly mathematically centered.

  Without this adjustment, the text might appear slightly too high in the box, even when it's mathematically centered according to its metrics. This is particularly noticeable
  with certain fonts or at larger font sizes.

  In essence, it's an optical adjustment that helps the text look properly centered, compensating for the inherent asymmetry in font design and the way our eyes perceive text
  positioning."#;

    //create text shape
    let text = session.new_text(
        std::str::from_utf8(lorem_ipsum).unwrap(),
        text_options.clone(),
    );
    table_items.push(text);

    //Add sample image from file (first instance)
    let sampleImage = session.new_image_from_file("demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
    //table_items.push(sampleImage);

    //Add sample image from file
    // The path is relative to where the binary is run
    let file_image = session.new_image_from_file("demo/assets/sample.png", (SizeBehavior::Content, SizeBehavior::Content));
   // table_items.push(file_image);

    // Create a FreeContainer with multiple visual elements at specific positions using the new method

    // Create all elements first
    let title_text = session.new_text(
        "FreeContainer Demo",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 18.0,
            line_width: 100,
            text_color: "#000000".to_string(),
            line_spacing: 0.0,
        },
    );

    let red_circle = session.new_elipse(
        (0.0, 0.0),   // center position (will be positioned by container)
        (15.0, 15.0), // radius
        EllipseOptions {
            fill_color: "#FF0000".to_string(), // bright red
            stroke_color: "black".to_string(),
            stroke_width: 2.0,
        },
    );

    let thetext = format!(
        r#"
    Esto es un texto
    Otra linea de texto
    Otra mas...
    "#
    );

    let blue_text = session.new_text(
        &thetext,
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 16.0,
            line_width: 100,
            text_color: "white".to_string(), // white text
            line_spacing: 0.0,
        },
    );

    // Create a box around the blue text
    let box_options = BoxOptions {
        fill_color: Fill::Color("#0000FF".to_string()), // blue background
        stroke_color: "green".to_string(),              // dark blue border
        stroke_width: 1.0,
        padding: 10.0,
        border_radius: 3.0,
        width_behavior: volare_engine_layout::SizeBehavior::Fixed(700.0), // Fixed width for the box
        height_behavior: volare_engine_layout::SizeBehavior::Fixed(200.0), 
        ..BoxOptions::default()
    };
    let blue_box = session.new_box(blue_text, box_options);

    let green_ellipse = session.new_elipse(
        (0.0, 0.0),
        (30.0, 20.0),
        EllipseOptions {
            fill_color: "#00CC00".to_string(),   // green
            stroke_color: "#006600".to_string(), // dark green
            stroke_width: 2.0,
        },
    );

    let subtitle = session.new_text(
        "Absolute positioning of elements",
        TextOptions {
            font_family: "AnonymicePro Nerd Font".to_string(),
            font_size: 12.0,
            line_width: 100,
            text_color: "#555555".to_string(), // dark gray
            line_spacing: 0.0,
        },
    );

    // Create a container with all children at once
    let container_with_elements = session.new_free_container_with_children(vec![
        (title_text, (30.0, 10.0)),
        (red_circle, (40.0, 50.0)),
        (blue_box, (80.0, 40.0)),
        (green_ellipse, (150.0, 70.0)),
        (subtitle, (30.0, 120.0)),
    ]);

    // Add styling to the container with more vibrant colors
    let free_container = session.get_free_container_mut(container_with_elements.entity_id);
    free_container.background_color = Some("#FFDDDD".to_string()); // Light red background (more visible)
    free_container.border_color = Some("#FF0000".to_string()); // Bright red border
    free_container.border_width = 5.0; // Thicker border

    // Add the FreeContainer to the table
    table_items.push(container_with_elements);
    //texts.push(get_test_table(&mut session));
    //Create a table for the texts with 2 columns
    let mut toptions = TableOptions::default();
    toptions.cell_padding = 2;
    let table = session.new_table(table_items, 5, toptions);

    // Calculate layout
    layout_tree_node(&mut session, &table);

    //create writer to file ~/temp/svg-render-test.svg
    //get path for ~/temp
    let temp_dir = std::env::temp_dir();
    //create path for ~/temp/svg-render-test.svg
    // Render SVG
    let mut svg_path = temp_dir.clone();
    svg_path.push("svg-render-test.svg");
    let svg_renderer = SVGRenderer {};
    let mut svg_file = File::create(&svg_path).unwrap();
    let svg_res = svg_renderer.render(&session, &table, &mut svg_file);
    if svg_res.is_err() {
        println!("SVG Render Error: {}", svg_res.err().unwrap());
        std::process::exit(1);
    }
    println!("SVG file written to: {}", svg_path.to_str().unwrap());

    // Render PNG
    // Use other  measure function for PNG rendering
    // let mut png_path = temp_dir.clone();
    // png_path.push("png-render-test.png");
    // let png_renderer = PNGRenderer {};
    // let mut png_file = File::create(&png_path).unwrap();
    // let png_res = png_renderer.render(&session, &table, &mut png_file);
    // if png_res.is_err() {
    //     println!("PNG Render Error: {}", png_res.err().unwrap());
    //     std::process::exit(1);
    // }
    // println!("PNG file written to: {}", png_path.to_str().unwrap());

    Ok(())
}

// Sample image loading is now handled directly through file loading

//function that returns a sample table with 10 elements and 3 columns

/// .
fn get_test_table(session: &mut DiagramBuilder) -> DiagramTreeNode {
    let text_options = TextOptions {
        font_family: "AnonymicePro Nerd Font".to_string(),
        font_size: 12.0,
        line_width: 100,
        text_color: "black".to_string(),
        line_spacing: 5.0,
    };
    //Create a list of 10 texts
    let mut texts = Vec::new();
    for i in 0..10 {
        let text = session.new_text(
            &format!("Text hey {} \nthis is a multiline text", i),
            text_options.clone(),
        );
        texts.push(text);
    }
    //create a table options object with all defaults except the header color
    let table_options = TableOptions {
        header_fill_color: "blue".to_string(),
        ..Default::default()
    };
    //Create a table for the texts with 2 columns
    let table = session.new_table(texts, 3, table_options);
    table
}


