===/Cargo.toml===
[package]
name = "volare_engine_layout"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.2"
cassowary = "0.3"
anyhow = "1.0.99"
uuid = { version = "1.8", features = ["v4"] }
thiserror = "2.0.17"


===/Cargo.lock===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "layout-base"
version = "0.1.0"

===/docs/LLM Transform Operations SPEC.md===
# JSONL Visual Engine - Natural Language to Operations Converter

You are a specialized assistant that converts natural language descriptions into JSONL-formatted operations for a visual layout engine. Your task is to generate valid JSONL documents where each line represents an operation that adds, updates, or deletes visual elements.

## Input Format

You will receive two inputs:

1. **User Request**: Natural language description of what to do
2. **Current Document**: The existing JSONL document (may be empty for new documents)

## Output Format

Each line must be a single, complete JSON object with NO formatting, NO blank lines, and NO extra whitespace:

```jsonl
{"action":"add","item":{"id":"root","type":"vstack","children":["header","content"]}}
{"action":"add","item":{"id":"header","type":"text","content":"Hello World","font_size":24}}
{"action":"update","item":{"id":"header","color":"blue"}}
{"action":"delete","item":{"id":"unwanted_element"}}
```

## Operation Types

### ADD Operation
Inserts a complete new element with all its attributes.
```jsonl
{"action":"add","item":{...complete element definition...}}
```
Note:
New elements only will be visible in the final document if they are referenced by their parent (with exception of the root element). An update operation for the parent element is usually needed.

### UPDATE Operation
Modifies existing element attributes. Only the `id` and attributes to change are needed.
```jsonl
{"action":"update","item":{"id":"element_id","attribute1":"new_value"}}
```
Note: If needed, when updating, the "type" of the element can be updated too (e.g when converting a root element that was text into a container).

### DELETE Operation
Removes an element. Only the `id` is required.
```jsonl
{"action":"delete","item":{"id":"element_id"}}
```

## Critical Rules

1. **STRICT JSONL FORMAT**: One complete JSON object per line, no blank lines
2. **ROOT ELEMENT REQUIREMENT**: 
   - **If Current Document is EMPTY**: The first operation MUST be an `add` operation for the root container element
   - **If Current Document EXISTS**: Analyze existing elements and generate appropriate operations (add/update/delete)
   - The root element is typically named "root" but check the current document to confirm
3. **UNIQUE IDs**: Every element must have a unique `id` attribute (check current document for existing IDs)
4. **VALID CHILDREN**: Container elements reference children by ID in `children` array (children can be defined later)
5. **ONE ROOT ONLY**: Only one root element per document
6. **PRESERVE CONTEXT**: When modifying existing elements, preserve attributes not mentioned in the user request

## JSONL Entity Specification

[PLACEHOLDER_FOR_COMPLETE_JSONL_SPEC]

IMPORTANT NOTE! : This task is about generating the **transformations** which have a different format than the document definition languange as they contain "action" and the items are defined inside the "item" field.

Example:

{"action":"add","item":{"id":"root","type":"vstack","children":["header","content"]}}




## Examples

### Example 1: New Document (Empty Current Document)
**User Request**: "Create a document with a title and a paragraph"
**Current Document**: (empty)

**Output**:
```jsonl
{"action":"add","item":{"id":"root","type":"vstack","children":["title","para"],"h_align":"left"}}
{"action":"add","item":{"id":"title","type":"text","content":"Document Title","font_size":24,"color":"#333"}}
{"action":"add","item":{"id":"para","type":"text","content":"This is the paragraph text.","font_size":12,"color":"#666"}}
```

### Example 2: Update Existing Element
**User Request**: "Change the title color to green and make it bigger"
**Current Document**:
```jsonl
{"id":"root","type":"vstack","children":["title","para"],"h_align":"left"}
{"id":"title","type":"text","content":"Document Title","font_size":24,"color":"#333"}
{"id":"para","type":"text","content":"This is the paragraph text.","font_size":12,"color":"#666"}
```

**Output**:
```jsonl
{"action":"update","item":{"id":"title","color":"green","font_size":32}}
```

### Example 3: Add to Existing Document
**User Request**: "Add a footer with copyright text"
**Current Document**:
```jsonl
{"id":"root","type":"vstack","children":["header","body"],"h_align":"stretch"}
{"id":"header","type":"box","background":"#2c3e50","padding":15,"children":["header_text"]}
{"id":"header_text","type":"text","content":"Dashboard","font_size":20,"color":"white"}
{"id":"body","type":"text","content":"Main content","font_size":14}
```

**Output**:
```jsonl
{"action":"add","item":{"id":"footer","type":"text","content":"© 2024 Company","font_size":10,"color":"gray"}}
{"action":"update","item":{"id":"root","children":["header","body","footer"]}}
```

### Example 4: Delete Elements
**User Request**: "Remove the sidebar"
**Current Document**:
```jsonl
{"id":"root","type":"hstack","children":["sidebar","main"],"v_align":"top"}
{"id":"sidebar","type":"box","width":200,"children":["nav"]}
{"id":"nav","type":"text","content":"Navigation"}
{"id":"main","type":"box","children":["content"]}
{"id":"content","type":"text","content":"Main content"}
```

**Output**:
```jsonl
{"action":"delete","item":{"id":"sidebar"}}
{"action":"delete","item":{"id":"nav"}}
{"action":"update","item":{"id":"root","children":["main"]}}
```

### Example 5: Complex Dashboard (New Document)
**User Request**: "Create a dashboard with header, sidebar, and main content area"
**Current Document**: (empty)
User: "Create a dashboard with header, sidebar, and main content area"

Output:
```jsonl
{"action":"add","item":{"id":"root","type":"vstack","children":["header","body"],"h_align":"stretch"}}
{"action":"add","item":{"id":"header","type":"box","background":"#2c3e50","padding":15,"children":["header_text"]}}
{"action":"add","item":{"id":"header_text","type":"text","content":"Dashboard","font_size":20,"color":"white"}}
{"action":"add","item":{"id":"body","type":"hstack","children":["sidebar","main"],"v_align":"top"}}
{"action":"add","item":{"id":"sidebar","type":"box","background":"#ecf0f1","padding":10,"width":200,"children":["nav"]}}
{"action":"add","item":{"id":"nav","type":"vstack","children":["nav1","nav2","nav3"],"h_align":"left"}}
{"action":"add","item":{"id":"nav1","type":"text","content":"Home","color":"#2c3e50"}}
{"action":"add","item":{"id":"nav2","type":"text","content":"Settings","color":"#2c3e50"}}
{"action":"add","item":{"id":"nav3","type":"text","content":"Profile","color":"#2c3e50"}}
{"action":"add","item":{"id":"main","type":"box","padding":20,"background":"white","children":["main_content"]}}
{"action":"add","item":{"id":"main_content","type":"text","content":"Main content goes here","font_size":14}}
```

### Example 6: Layout with Boxes (New Document)
**User Request**: "Make a horizontal layout with two colored boxes, red on left and blue on right"
**Current Document**: (empty)

**Output**:
```jsonl
{"action":"add","item":{"id":"root","type":"hstack","children":["box1","box2"],"spacing":10}}
{"action":"add","item":{"id":"box1","type":"rect","width":100,"height":100,"fill":"red"}}
{"action":"add","item":{"id":"box2","type":"rect","width":100,"height":100,"fill":"blue"}}
```

### Example 7: Multiple Updates
**User Request**: "Make all text blue and increase font sizes by 2"
**Current Document**:
```jsonl
{"id":"root","type":"vstack","children":["title","subtitle","body"]}
{"id":"title","type":"text","content":"Title","font_size":24,"color":"black"}
{"id":"subtitle","type":"text","content":"Subtitle","font_size":18,"color":"black"}
{"id":"body","type":"text","content":"Body text","font_size":12,"color":"black"}
```

**Output**:
```jsonl
{"action":"update","item":{"id":"title","color":"blue","font_size":26}}
{"action":"update","item":{"id":"subtitle","color":"blue","font_size":20}}
{"action":"update","item":{"id":"body","color":"blue","font_size":14}}
```

## Document Context

When processing requests, analyze the **Current Document** to understand:

1. **Empty Document**:
   - No existing elements
   - First line MUST be: `{"action":"add","item":{"id":"root","type":"...","children":[...]}}`
   - Build complete structure from scratch

2. **Existing Document**:
   - Parse existing elements and their IDs
   - Identify the root element (usually `"id":"root"` in first line)
   - Check existing children arrays to understand structure
   - Generate minimal operations to fulfill user request
   - When adding elements to containers, update their `children` array
   - When deleting elements, also remove them from parent's `children` array and delete orphaned descendants

3. **Operation Guidelines**:
   - **ADD**: Create new elements with unique IDs (check existing IDs to avoid conflicts)
   - **UPDATE**: Modify only the attributes mentioned in user request; preserve others
   - **DELETE**: Remove element and clean up all references to it (children arrays, etc.)

## Analyzing Current Document

When the current document is provided:

1. **Parse all element IDs** to avoid creating duplicates
2. **Identify parent-child relationships** via `children` arrays
3. **Understand layout structure** (stack types, containers, positioning)
4. **Determine what exists** vs what needs to be added/modified/removed
5. **Generate minimal operations** - only change what's necessary

## Important Notes

- Always generate **valid, strict JSONL** (one object per line, no blank lines)
- The **first line must always be the root element**
- Container elements (`vstack`, `hstack`, `box`, `free_container`, etc.) use `children` arrays with IDs
- For positioning, use appropriate containers or `x`, `y` coordinates in `free_container`
- Color values can be named colors ("red", "blue") or hex codes ("#FF0000")
- Text wrapping uses `line_width` attribute
- Spacing between elements in stacks uses `spacing` attribute
- Element alignment uses `h_align` (left/center/right/stretch) and `v_align` (top/center/bottom/stretch)

## Your Task

When given a user request and current document:

1. **Analyze Current Document**:
   - If empty → Creating NEW document, start with root
   - If exists → Parse existing elements, IDs, and structure
   - Identify what elements exist and what needs to change

2. **Determine Operations**:
   - Choose minimal set of operations (add/update/delete) to fulfill request
   - Ensure IDs are unique (check current document)
   - Update parent `children` arrays when adding/removing elements
   - Ensure the "type" is correct when updating an element, update it if needed too.

3. **Generate Valid JSONL**:
   - One complete JSON object per line
   - No blank lines, no extra whitespace
   - For EMPTY documents: First line is always `{"action":"add","item":{"id":"root",...}}`
   - For EXISTING documents: Only generate operations that make requested changes

4. **Use Appropriate Structure**:
   - Choose correct element types and attributes from specification
   - Create unique, descriptive IDs (check existing IDs first)
   - Build proper parent-child relationships via `children` arrays
   - Preserve existing attributes when updating (only change what's requested)
   - For document and section layouts prefer the higher level elements listed in "JSONL Document components Specification". 
   - Always use a `document` element for the root container with header,content and footer elements
   - Use `document.section` for logically grouping components.

5. **Output Format**: 
   - Output ONLY the JSONL operations, no explanations unless requested
   - Each operation should be atomic and complete
   - Operations should be ordered logically (add children before referencing them in parent)

Generate clear, semantic IDs and choose the most appropriate element types and layout containers for the user's description.

 IMPORTANT NOTE! : This task is about generating the **transformations** which have a different format than the document definition languange as they contain "action" and the items are defined inside the "item" field. ALL jsonl elements should have an `action` and an `item` field!

Example line for a a valid transformation:
{"action":"add","item":{"id":"root","type":"vstack","children":["header","content"]}}

NOTE ABOUT ADDITIONS:
When creating "add" actions keep in mind that usually we have to update a reference to the new element in other element and we would have to create an "update" action too. Some elements are referenced in attributes like header_id (for a document element for example) while others are a member of the `children` vector (refer to spec). Please make sure to add update operations if needed.

===/docs/the-diagram-tree-spec.md===
# The diagram Tree.

Diagrams are declared as a tree of nodes.
Each node must contain one of the supported diagram components:

- Box
- Group
- Text
- VerticalStack
- etc.

Each diagram consists in the logic necessary to create the tree, without regard for the element size or position, that's calculated by the engine.


The layout components

Layout components that are containers, expect their children to already exist. So we need an upper layer that creates an abstraction so the user is not concerned with internal details.

Ideally the user defines something like:

VerticalStack({props}, [
    Box ({props}, elem),
    HorizontalStack({props}, [
        elem1,
        elem2,
        elem3
    ]),
    Table({props}, [
        [elem1,elem2,elem3],
        [elem4,elem5,elem6]
    ])
])

What we are building is something similar to a virtual representation.
Like react virtual dom.


Each function should return a DiagramNode


Another option is to have vectors for each type of node in the parent element,
and just store the index in DiagramNode

```
struct DiagramNode {
    entity_type: EntityType,
    ix: usize,
    children: Vec<(ix, EntityType)>
}
```

This way we would have a way to retrieve the specific element from a different array.

Where would those arrays live?

Some kind of DiagramBuilder object

## Builder pattern

```rust
let builder = DiagramBuilder::new();

let root = builder.newVerticalStack()
root.add(builder.newBox(...))
.add(builder.newHorizontalStack(...).
    add(builder.newBox({}, builder.Text("Hey"))))

```

Having a builder api with methods that make it easy to create a diagram
by adding nodes is useful to create the API

Then, we can pass the DiagramNode object to the render api.

What happens inside newBox method inside the builder?

- The builder populates the BoxShape component and adds it to the boxes list
- Returns the position of the item in the array **and the entity type**
- (ix, EntityType)

Inside `add`:

Each children is a pair of (ix, EntityType).

Now we have a space where the properties are stored, and each node store indexes and an identifier
to have a way to know what array to look for.

Each index is valid only for the lifetime of the builder object.

## Stage 2

We already have a diagram representation, but no entities have been created.
The properties for each component will be required by the renderer layer (e.g color).
So they should be passed to the render layer somehow.

The renderer can receive an instance of the builder to have access to the internal details for each element?

The properties do affect layout and are used by rendering.




===/docs/diagrams/ichikawa.md===
# Ishikawa Diagram (Fishbone Diagram) - JSONL Specification

## Overview
The Ishikawa diagram, also known as a fishbone diagram or cause-and-effect diagram, is used to visualize the potential causes of a problem. The diagram consists of a central "spine" leading to the problem statement, with category "branches" extending from the spine, each containing items that represent causes.

## Basic Structure

```jsonl
{"type":"ishikawa","id":"unique_id","problem":"Problem Statement","categories":[...]}
```

## Parameters

### Root Level Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `type` | string | Yes | Must be `"ishikawa"` |
| `id` | string | Yes | Unique identifier for the diagram (e.g., `"root"`) |
| `problem` | string | Yes | The main problem or effect being analyzed. Displayed in the "head" box on the right side of the diagram |
| `categories` | array | Yes | Array of category objects representing major cause categories |

### Category Object

Each category represents a major classification of causes (e.g., People, Process, Technology, Environment).

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | Yes | Name of the category (e.g., `"People"`, `"Process"`) |
| `items` | array | Yes | Array of item objects representing causes within this category |

**Automatic Distribution**: Categories are automatically distributed between top and bottom branches:
- First half of categories → top branches
- Second half of categories → bottom branches
- Example: 4 categories = 2 top, 2 bottom

### Item Object

Items represent individual causes or factors. Items can have nested children for sub-causes.

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | Yes | Name/description of the cause (e.g., `"High turnover"`, `"Lack of training"`) |
| `children` | array | No | Array of nested item objects representing sub-causes. Can be nested multiple levels deep |

**Automatic Distribution**: Items within each category are automatically distributed:
- First half of items → left side of branch
- Second half of items → right side of branch
- Example: 5 items = 3 left, 2 right

## Complete Examples

### Example 1: Simple Ishikawa Diagram

```jsonl
{"type":"ishikawa","id":"root","problem":"Customer Complaints","categories":[{"name":"People","items":[{"name":"Insufficient training"},{"name":"High turnover"}]},{"name":"Process","items":[{"name":"No quality checks"},{"name":"Unclear procedures"}]}]}
```

**Result:**
- **Top branch**: People (Insufficient training on left, High turnover on right)
- **Bottom branch**: Process (No quality checks on left, Unclear procedures on right)

### Example 2: Complex Ishikawa with Nested Children

```jsonl
{"type":"ishikawa","id":"root","problem":"Low Product Quality","categories":[{"name":"People","items":[{"name":"Training","children":[{"name":"Lack of courses"},{"name":"Poor quality materials"}]},{"name":"High turnover"},{"name":"Low motivation"}]},{"name":"Process","items":[{"name":"Documentation incomplete"},{"name":"Lack of reviews"},{"name":"No standardization"}]},{"name":"Technology","items":[{"name":"Obsolete hardware"},{"name":"Software issues","children":[{"name":"No patches"},{"name":"Old versions"}]},{"name":"Lack of integration"}]},{"name":"Environment","items":[{"name":"Unstable temperature"},{"name":"High humidity"}]}]}
```

**Result:**
- **Top branches**: People, Process
- **Bottom branches**: Technology, Environment
- **Nested items**: "Training" and "Software issues" have sub-causes displayed hierarchically

### Example 3: Six Categories (6M Method)

```jsonl
{"type":"ishikawa","id":"root","problem":"Production Defects","categories":[{"name":"Man","items":[{"name":"Skill gaps"},{"name":"Fatigue"}]},{"name":"Method","items":[{"name":"Outdated procedures"},{"name":"No documentation"}]},{"name":"Machine","items":[{"name":"Poor maintenance"},{"name":"Old equipment"}]},{"name":"Material","items":[{"name":"Low quality suppliers"},{"name":"Inconsistent batches"}]},{"name":"Measurement","items":[{"name":"Uncalibrated tools"},{"name":"Inconsistent standards"}]},{"name":"Mother Nature","items":[{"name":"Temperature fluctuations"},{"name":"Humidity"}]}]}
```

**Result:**
- **Top branches** (3): Man, Method, Machine
- **Bottom branches** (3): Material, Measurement, Mother Nature

## Visual Layout

```
         [Item]─┐
                │
    [Item]──────┤     [Category]
                │          │
         [Item]─┘          │
                           │
═══════════════════════════╪═══════════════════ [Problem]
                           │
         [Item]─┐          │
                │          │
    [Item]──────┤     [Category]
                │
         [Item]─┘
```

## Best Practices

1. **Problem Statement**: Be specific and measurable (e.g., "Customer satisfaction below 80%" rather than "Poor service")

2. **Category Names**: Use standard frameworks when applicable:
   - **4M**: Man, Method, Machine, Material
   - **6M**: Add Measurement, Mother Nature (Environment)
   - **8P** (Service): People, Process, Place, Promotion, Product, Price, Physical Evidence, Positioning
   - Or create custom categories relevant to your domain

3. **Items**:
   - Keep descriptions concise (2-5 words)
   - Use specific, actionable causes
   - Nest related sub-causes using `children` for clarity

4. **Distribution**:
   - Aim for balanced categories (2-6 items per category)
   - The system automatically balances left/right distribution
   - Odd numbers work fine (e.g., 5 items = 3 left, 2 right)

5. **Nesting Depth**:
   - Use 1-2 levels of nesting for clarity
   - Avoid more than 3 levels (becomes hard to read)

## Common Use Cases

- **Manufacturing Quality**: Using 6M framework
- **Service Quality**: Using 8P framework
- **Project Issues**: Custom categories like Resources, Planning, Communication, Technology
- **Root Cause Analysis**: Any domain-specific categories
- **Problem Solving**: Brainstorming and organizing potential causes

## Notes

- All visual layout (positioning, spacing, connector lines) is handled automatically
- Categories are evenly distributed between top and bottom branches
- Items within categories are evenly distributed between left and right sides
- The diagram adapts to any number of categories and items
===/docs/JSONL Document components.md===
# JSONL Document components Specification (high level document components)

These components are higher level elements used to present information with good typography and spacing settings. 

## document

the root document container
**Always use the `document` element as the root**

attributes
- header_id (optional)
- content_id (optional)
- footer_id (optional)

## document.section

```
{"id":"section-example", "type":"document.section", "title":"the section title",  "meta":"Design Theory - 2024", "columns":["col1","col2","col3"]}
```

attributes
- title (string - optional)
- columns: (array of ids)
- meta: (optional) complementary text

The section provides a multi column layout, the columns attribute contains the array of ids of the elements that contain the column content.

columns can also be sections for composing more complex layouts

## document.properties

A component used to present information in a table based with two columns, first column is the attribute name, and second column is the attribute value

```
{"id":"properties-car", "type":"document.properties", "meta":"Car Properties", "properties"=[["name", "mustang"], ["value":"3000"]]}
```

Attributes:
- properties: A list of two value lists (first is name of the property and second is the value, both strings)
- meta: (optional) a short text that is display on top of the element to give some context to the reader.

## document.text

A text paragraph with good default typography settings with optional title

```
{"id":"explanation", "type":"document.text", "variant":"default|large|small|subtle|emphasized "text":"the content" "title": "paragraph title", "width":"sm|md|lg|xl|full|<number>"}
```

Variants: 

default: Standard content blocks
large: Hero sections or main headings
small: Compact spaces or secondary information
subtle: Labels or supporting content
emphasized: Important callouts or quotes

width (optional)

Any of the following strings or 
"sm" : Small width (approx 480px)
"md" : Medium width (approx 640px)
"lg" : Large (840px)
"xl" : X-Large (1024)
"full": 1200

width can also be a number e.g "300"


## document.bullet_list

A bullet point list of elements with good typography and spacing settings

```
{"id":"item-list", "type":"document.bullet_list", "meta":"A useful list" "items":["first","second","third"]}
```


## numbered-list (NOT IMPLEMENTED YET!)

A numbered list of elements with good typography and spacing settings

```
{"id":"item-list", "type":"numbered-list", "items":["first","second","third"]}
```

## card (NOT IMPLEMENTED YET!)

attributes

- meta : information that describes or categorizes the main content
- title : string
- content: string (if the content is text)
- content_id: (if other element should be instantiated in the content area)


## quote-block (NOT IMPLEMENTED YET)

Left border emphasis for important information

## code-block (NOT IMPLEMENTED YET)

Monospace content with background differentiation


===/docs/JSONL Diagram Specification.md===
# JSONL Diagram Specification (Complete Reference)
v1.2 - Complete specification based on parser implementation

This specification describes the JSON Lines format for creating documents using the Volare Layout Engine. Each line in a JSONL file represents a single entity with its properties.

## Basic Structure

**CRITICAL: The first line of every JSONL document MUST be the root element.**

### Format Rules:
- **First line is always root** - The very first object in the file must be your root container (typically `id:"root"`) with a `children` array referencing other elements
- **One JSON object per line** - no formatted/pretty JSON  
- **No blank lines** between objects
- **Children can be referenced before being defined** - forward references are supported
- **All IDs must be unique** within the document

### Example:
```jsonl
{"id":"root","type":"vstack","children":["header","body"]}
{"id":"header","type":"text","content":"Title"}
{"id":"body","type":"text","content":"Content"}
```
❌ **WRONG - root is not first:**
```jsonl
{"id":"header","type":"text","content":"Title"}
{"id":"root","type":"vstack","children":["header"]}
```

---

## Core Entity Types

### Text (`"type": "text"`)
Renders text content with styling options.

**Required Attributes:**
- `content` or `text` (string) - The text to display

**Optional Attributes:**
- `font_size` (number) - Font size in pixels (default: 12)
- `color` or `text_color` (string) - Text color (default: "black")
- `font_family` (string) - Font family name (default: "Arial")
- `line_width` (number) - Maximum characters per line for wrapping (default: 200)
- `line_spacing` (number) - Space between lines (default: 0)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"title","type":"text","content":"Hello World","font_size":24,"color":"blue"}
{"id":"positioned_text","type":"text","content":"Positioned","x":50,"y":100}
```

---

### Box (`"type": "box"`)
Wraps a single child element with padding, background, and border.

**Required Attributes:**
- `children` (array with exactly one element) - Child element ID

**Optional Attributes:**
- `padding` (number) - Inner padding (default: 0)
- `background`, `background_color`, or `fill` (string) - Background color (default: "white")
- `border_color` or `stroke_color` (string) - Border color (default: "black")
- `border_width` or `stroke_width` (number) - Border thickness (default: 1)
- `border_radius` (number) - Corner radius (default: 0)
- `width` (number or "content"/"grow") - Width behavior
- `height` (number or "content"/"grow") - Height behavior
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"container","type":"box","padding":10,"background":"lightblue","border_radius":5,"children":["text1"]}
```

**Note:** Children array must contain exactly one element ID.

---

### Rectangle (`"type": "rect"`)
Draws a rectangle shape.

**Required Attributes:**
- `width` (number or "content"/"grow") - Rectangle width
- `height` (number or "content"/"grow") - Rectangle height

**Optional Attributes:**
- `background`, `background_color`, or `fill` (string) - Fill color (default: "white")
- `border_color`, `stroke_color`, or `stroke` (string) - Border color (default: "black")
- `border_width` or `stroke_width` (number) - Border thickness (default: 1)
- `border_radius` (number) - Corner radius (default: 0)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"rect1","type":"rect","width":100,"height":50,"fill":"red","border_radius":5}
{"id":"rect2","type":"rect","width":80,"height":60,"fill":"blue","x":150,"y":100}
```

---

### Ellipse (`"type": "ellipse"`)
Draws an ellipse or circle.

**Required Attributes:**
- `rx` or `radius_x` (number) - Horizontal radius
- `ry` or `radius_y` (number) - Vertical radius

**Optional Attributes:**
- `fill`, `fill_color`, or `background` (string) - Fill color (default: "white")
- `stroke`, `stroke_color`, or `border_color` (string) - Stroke color (default: "black")
- `stroke_width` or `border_width` (number) - Stroke width (default: 1)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"circle","type":"ellipse","rx":25,"ry":25,"fill":"yellow","stroke":"orange","stroke_width":2}
{"id":"ellipse","type":"ellipse","rx":40,"ry":20,"fill":"lightblue","x":100,"y":50}
```

**Important Notes:**
- Element size is `2*rx` by `2*ry`
- `cx` and `cy` attributes are parsed but IGNORED - use `x`, `y` for positioning
- Ellipse is centered within its bounding box

---

### Line (`"type": "line"`)
Draws a straight line between two points.

**Required Attributes:**
- `start_x` or `x1` (number) - Starting X coordinate
- `start_y` or `y1` (number) - Starting Y coordinate
- `end_x` or `x2` (number) - Ending X coordinate
- `end_y` or `y2` (number) - Ending Y coordinate

**Optional Attributes:**
- `stroke_color` or `color` (string) - Line color (default: "black")
- `stroke_width` (number) - Line thickness (default: 1)
- `x` (number) - X position of line's bounding box in free_container
- `y` (number) - Y position of line's bounding box in free_container

**Example:**
```json
{"id":"line1","type":"line","start_x":0,"start_y":0,"end_x":100,"end_y":50,"stroke_color":"blue","stroke_width":2}
```

---

### Arc (`"type": "arc"`)
Draws an arc segment.

**Required Attributes:**
- `radius` or `r` (number) - Arc radius (default: 50)
- `start_angle` or `start` (number) - Start angle in degrees (default: 0)
- `end_angle` or `end` (number) - End angle in degrees (default: 90)

**Optional Attributes:**
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the arc sector (default: false)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"quarter","type":"arc","radius":40,"start_angle":0,"end_angle":90,"stroke_color":"red","stroke_width":2}
{"id":"semicircle","type":"arc","radius":30,"start_angle":0,"end_angle":180,"filled":true,"fill_color":"blue"}
{"id":"circle","type":"arc","radius":25,"start_angle":0,"end_angle":360,"filled":true,"fill_color":"green"}
```

**Notes:**
- Arc size is always `diameter = radius * 2`
- Arc is centered within its bounding box
- 360° arcs render as full circles
- Filled arcs create pie-slice shapes

---

### Semicircle (`"type": "semicircle"`)
Convenience type for 180° arcs.

**Required Attributes:**
- `radius` or `r` (number) - Semicircle radius (default: 50)

**Optional Attributes:**
- `facing_up` or `up` (boolean) - True for top (180°-360°), false for bottom (0°-180°) (default: true)
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill (default: false)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"semi1","type":"semicircle","radius":40,"facing_up":false,"filled":true,"fill_color":"green"}
```

---

### Quarter Circle (`"type": "quarter_circle"`)
Convenience type for 90° arcs.

**Required Attributes:**
- `radius` or `r` (number) - Radius (default: 50)
- `quadrant` (number) - Quadrant: 1, 2, 3, or 4 (default: 1)

**Optional Attributes:**
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill (default: false)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"quarter1","type":"quarter_circle","radius":30,"quadrant":1,"filled":true,"fill_color":"orange"}
```

---

### Polyline (`"type": "polyline"`)
Draws connected line segments through multiple points.

**Required Attributes:**
- `points` (array of [x,y] arrays) - Coordinate pairs

**Optional Attributes:**
- `stroke_color` or `color` (string) - Line color (default: "black")
- `stroke_width` (number) - Line thickness (default: 1)
- `x` (number) - X position of polyline's bounding box in free_container
- `y` (number) - Y position of polyline's bounding box in free_container

**Example:**
```json
{"id":"poly1","type":"polyline","points":[[0,0],[50,25],[100,0],[150,50]],"stroke_color":"purple","stroke_width":2}
```

---

### Image (`"type": "image"`)
Displays an image from URL or file path.

**Required Attributes (one of):**
- `src` (string) - Image URL or base64 data
- `file_path` (string) - Path to image file

**Required Size:**
- `width` (number or "content"/"grow") - Image width
- `height` (number or "content"/"grow") - Image height

**Optional Attributes:**
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"img1","type":"image","src":"https://example.com/logo.png","width":200,"height":150}
{"id":"img2","type":"image","file_path":"assets/photo.jpg","width":300,"height":200,"x":50,"y":50}
```

---

### Connector (`"type": "connector"`)
Automatically draws a line connecting two elements from their centers.

**Required Attributes:**
- `source`, `source_id`, or `from` (string) - Source element ID
- `target`, `target_id`, or `to` (string) - Target element ID

**Optional Attributes:**
- `stroke_color`, `color`, or `stroke` (string) - Line color (default: "black")
- `stroke_width` (number) - Line width (default: 1)
- `connector_type` (string) - "straight", "curved", or "orthogonal" (default: "straight")
- `curve_offset` or `curve_amount` (number) - Curve offset for "curved" type



**Optional Port Attributes:**
- `source_port` (string) - Port on source element: "center", "top", "bottom", "left", "right", "top_left", "top_right", "bottom_left", "bottom_right" (default: "center")
- `target_port` (string) - Port on target element (same options as source_port)

**Example:**
```json
{"id":"conn1","type":"connector","source":"box1","source_port":"right","target":"box2","target_port":"left","stroke_color":"red","stroke_width":2}
{"id":"conn2","type":"connector","source":"header","source_port":"bottom","target":"body","target_port":"top","stroke_color":"blue","stroke_width":2}
```

**Example:**
```json
{"id":"conn1","type":"connector","source":"box1","target":"box2","stroke_color":"red","stroke_width":2}
{"id":"conn2","type":"connector","from":"elem1","to":"elem2","connector_type":"curved","curve_offset":20}
```
**Optional Arrow Attributes:**
- `arrow_start` or `arrow_begin` (boolean) - Add arrowhead at source end (default: false)
- `arrow_end` (boolean) - Add arrowhead at target end (default: false)
- `arrow_size` (number) - Size of arrowheads (default: 8.0)

**Example:**
```json
{"id":"conn1","type":"connector","source":"box1","target":"box2","arrow_end":true,"stroke_color":"blue","stroke_width":2}
{"id":"conn2","type":"connector","source":"box2","target":"box3","arrow_start":true,"arrow_end":true,"stroke_color":"red","stroke_width":2}
{"id":"conn3","type":"connector","source":"box1","source_port":"right","target":"box2","target_port":"left","arrow_end":true,"arrow_size":12,"stroke_color":"green","stroke_width":3}
```

**Notes:**
- Connectors calculate positions automatically based on source/target centers
- Must be in a container that can access both source and target elements
- Connectors auto-promote in tree structure to ensure element access

---

### Spacer (`"type": "spacer"`)
Creates spacing between elements.

**Optional Attributes:**
- `width` (number) - Width (default: 1)
- `height` (number) - Height (default: 20)
- `direction` (string) - "horizontal", "vertical", or "both" (default: "vertical")

**Example:**
```json
{"id":"spacer1","type":"spacer","height":30}
{"id":"spacer2","type":"spacer","width":50,"direction":"horizontal"}
```

---

## Layout Containers

### Vertical Stack (`"type": "vstack"`)
Stacks children vertically.

**Required Attributes:**
- `children` (array) - Child element IDs

**Optional Attributes:**
- `h_align` or `horizontal_alignment` (string) - "left", "center", "right" (default: "center")
- `spacing` (number) - Vertical spacing between children (default: 0)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"stack1","type":"vstack","children":["elem1","elem2","elem3"],"h_align":"left","spacing":10}
```

---

### Horizontal Stack (`"type": "hstack"`)
Stacks children horizontally.

**Required Attributes:**
- `children` (array) - Child element IDs

**Optional Attributes:**
- `v_align` or `vertical_alignment` (string) - "top", "center", "bottom" (default: "center")
- `spacing` (number) - Horizontal spacing between children (default: 0)
- `x` (number) - X position in free_container
- `y` (number) - Y position in free_container

**Example:**
```json
{"id":"stack2","type":"hstack","children":["elem1","elem2"],"v_align":"top","spacing":15}
```

---

### Group (`"type": "group"`)
Groups elements without layout constraints.

**Required Attributes:**
- `children` (array) - Child element IDs

**Example:**
```json
{"id":"group1","type":"group","children":["elem1","elem2","elem3"]}
```

**Note:** Group imposes no layout - children render in natural positions.

---

### Table (`"type": "table"`)
Arranges children in grid layout.

**Required Attributes:**
- `children` (array) - Cell element IDs (filled row by row)
- `cols` or `columns` (number) - Number of columns

**Optional Attributes:**
- `header_fill_color` or `header_background` (string) - First row background (default: "lightgray")
- `fill_color` or `background` (string) - Table background (default: "white")
- `border_color` (string) - Border color (default: "black")
- `border_width` (number) - Border thickness (default: 1)
- `cell_padding` or `padding` (number) - Cell padding (default: 20)

**Example:**
```json
{"id":"table1","type":"table","children":["h1","h2","c1","c2","c3","c4"],"cols":2,"cell_padding":15}
```

---

### Free Container (`"type": "free_container"`)
Allows absolute positioning of children using x,y coordinates.

**Required Attributes:**
- `children` (array) - Child element IDs

**Optional Attributes:**
- `width` (number) - Container width
- `height` (number) - Container height
- `background` or `background_color` (string) - Background color
- `border_color` (string) - Border color
- `border_width` (number) - Border thickness
- `x` (number) - X position in parent free_container
- `y` (number) - Y position in parent free_container

**Example:**
```json
{"id":"container","type":"free_container","width":400,"height":300,"children":["item1","item2"]}
{"id":"item1","type":"text","content":"Text","x":50,"y":100}
{"id":"item2","type":"rect","width":60,"height":40,"fill":"blue","x":200,"y":150}
```

**Critical:** Each child MUST have `x` and `y` attributes for positioning.

---

### Constraint Container (`"type": "constraint_container"`)
Uses constraint-based layout for positioning.

**Required Attributes:**
- `children` (array) - Child element IDs

**Optional Attributes:**
- `constraints` (array) - Constraint objects (see Constraints section)

**Example:**
```json
{"id":"layout","type":"constraint_container","children":["box1","box2"],"constraints":[{"type":"align_left","entities":["box1","box2"]},{"type":"below","entities":["box2","box1"]}]}
```

---

## Transform Attributes

All elements support transform attributes:

- `rotation` (number) - Rotation in degrees (around element center)
- `scale_x` (number) - Horizontal scale factor
- `scale_y` (number) - Vertical scale factor
- `transform` (string) - CSS-style transform (experimental, limited support)

**Example:**
```json
{"id":"rotated","type":"rect","width":50,"height":30,"fill":"blue","rotation":45}
{"id":"scaled","type":"text","content":"Big","scale_x":2.0,"scale_y":1.5}
```

---

## Size Behaviors

For `width` and `height` attributes:

- **Number** - Fixed size in pixels: `100`
- **"content"** - Size based on content (default for most elements)
- **"grow"** - Expand to fill available space

**Example:**
```json
{"id":"fixed","type":"rect","width":100,"height":50}
{"id":"content_sized","type":"box","width":"content","height":"content","children":["text1"]}
{"id":"growing","type":"rect","width":"grow","height":50}
```

---

## Color Values

Supported color formats:
- Named: `"red"`, `"blue"`, `"lightgray"`
- Hex: `"#FF0000"`, `"#0066CC"`, `"#f0f0f0"`
- RGB: `"rgb(255,0,0)"`

---

## Attribute Aliases

The parser accepts multiple names for the same attribute:

| Concept | Aliases |
|---------|---------|
| Background color | `background`, `background_color`, `fill` |
| Border/stroke color | `border_color`, `stroke_color`, `stroke` |
| Border/stroke width | `border_width`, `stroke_width` |
| Text content | `content`, `text` |
| Text color | `color`, `text_color` |
| Source | `source`, `source_id`, `from` |
| Target | `target`, `target_id`, `to` |
| Radius X | `rx`, `radius_x` |
| Radius Y | `ry`, `radius_y` |
| Radius | `radius`, `r` |
| Columns | `cols`, `columns` |
| Cell padding | `padding`, `cell_padding` |
| H-alignment | `h_align`, `horizontal_alignment` |
| V-alignment | `v_align`, `vertical_alignment` |
| Line start X | `start_x`, `x1` |
| Line start Y | `start_y`, `y1` |
| Line end X | `end_x`, `x2` |
| Line end Y | `end_y`, `y2` |
| Arc start | `start_angle`, `start` |
| Arc end | `end_angle`, `end` |

---

## Constraint Types

Constraints are ONLY valid within `constraint_container`.

### Alignment Constraints
Align multiple entities. First entity is reference.

```json
{"type":"align_left","entities":["rect1","rect2","rect3"]}
{"type":"align_right","entities":["rect1","rect2"]}
{"type":"align_top","entities":["rect1","rect2","rect3"]}
{"type":"align_bottom","entities":["rect1","rect2"]}
{"type":"align_center_horizontal","entities":["rect1","rect2"]}
{"type":"align_center_vertical","entities":["rect1","rect2","rect3"]}
```

### Directional Positioning
Position the first entity relative to the second entity (reference).
```json
{"type":"right_of","entities":["elem_A","elem_B"]}  // A is to the right of B
{"type":"left_of","entities":["elem_A","elem_B"]}   // A is to the left of B
{"type":"above","entities":["elem_A","elem_B"]}     // A is above B
{"type":"below","entities":["elem_A","elem_B"]}     // A is below B
```

**Syntax:** `{"type":"<direction>","entities":[<positioned>,<reference>]}`
- First element is the one being positioned
- Second element is the reference/anchor element

**Examples:**
```json
// Place header above content
{"type":"above","entities":["header","content"]}

// Place footer below content  
{"type":"below","entities":["footer","content"]}

// Place sidebar to the left of main area
{"type":"left_of","entities":["sidebar","main"]}
```
### Spacing Constraints

```json
{"type":"horizontal_spacing","entities":["rect1","rect2"],"spacing":20.0}
{"type":"vertical_spacing","entities":["rect1","rect2"],"spacing":15.0}
{"type":"fixed_distance","entities":["rect1","rect2"],"distance":100.0}
```

### Layout Stacking

```json
{"type":"stack_horizontal","entities":["rect1","rect2","rect3"],"spacing":10.0}
{"type":"stack_vertical","entities":["rect1","rect2","rect3"],"spacing":8.0}
```

### Size Constraints

```json
{"type":"same_width","entities":["rect1","rect2","rect3"]}
{"type":"same_height","entities":["rect1","rect2"]}
{"type":"same_size","entities":["rect1","rect2"]}
{"type":"at_least_same_height","entities":["rect1","rect2"]}
{"type":"proportional_width","entities":["rect1","rect2"],"ratio":1.5}
{"type":"proportional_height","entities":["rect1","rect2"],"ratio":0.8}
{"type":"min_height","entity":"rect1","height":50.0}
```

### Advanced Constraints

```json
{"type":"aspect_ratio","entity":"rect1","ratio":1.618}
{"type":"distribute_horizontally","entities":["rect1","rect2","rect3"]}
{"type":"distribute_vertically","entities":["rect1","rect2","rect3"]}
```

---

## Complete Examples

### Basic Document
```jsonl
{"id":"root","type":"vstack","children":["header","content","footer"],"h_align":"center","spacing":10}
{"id":"header","type":"box","padding":15,"background":"#2c3e50","children":["title"]}
{"id":"title","type":"text","content":"My Document","font_size":24,"color":"white"}
{"id":"content","type":"hstack","children":["sidebar","main"],"v_align":"top","spacing":20}
{"id":"sidebar","type":"vstack","children":["nav1","nav2","nav3"],"h_align":"left","spacing":5}
{"id":"nav1","type":"text","content":"Home","color":"blue"}
{"id":"nav2","type":"text","content":"About","color":"blue"}
{"id":"nav3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":20,"background":"white","children":["article"]}
{"id":"article","type":"text","content":"Main content area.","line_width":300}
{"id":"footer","type":"text","content":"© 2024","font_size":10,"color":"gray"}
```

### Free Container with Connectors
```jsonl
{"id":"root","type":"free_container","width":500,"height":300,"children":["box1","box2","box3","conn1","conn2"]}
{"id":"box1","type":"rect","x":50,"y":120,"width":80,"height":60,"fill":"lightblue","stroke":"blue","stroke_width":2}
{"id":"box2","type":"rect","x":220,"y":120,"width":80,"height":60,"fill":"lightgreen","stroke":"green","stroke_width":2}
{"id":"box3","type":"rect","x":390,"y":120,"width":80,"height":60,"fill":"lightyellow","stroke":"orange","stroke_width":2}
{"id":"conn1","type":"connector","source":"box1","target":"box2","stroke_color":"blue","stroke_width":2}
{"id":"conn2","type":"connector","source":"box2","target":"box3","stroke_color":"green","stroke_width":2}
```

### Constraint Layout
```jsonl
{"id":"rect1","type":"rect","width":100,"height":60,"fill":"blue"}
{"id":"rect2","type":"rect","width":100,"height":60,"fill":"red"}
{"id":"rect3","type":"rect","width":100,"height":60,"fill":"green"}
{"id":"root","type":"constraint_container","children":["rect1","rect2","rect3"],"constraints":[{"type":"stack_horizontal","entities":["rect1","rect2","rect3"],"spacing":20.0},{"type":"align_center_vertical","entities":["rect1","rect2","rect3"]},{"type":"same_height","entities":["rect1","rect2","rect3"]}]}
```

---

## Custom Components

Custom components are registered via `builder.register_custom_component()` and can accept any attributes their implementation defines.

**Example:**
```json
{"id":"badge1","type":"badge","text":"NEW","background":"red"}
```

---

## Implementation References

- **Parser:** `volare_engine_layout/src/parser.rs`
- **Layout Engine:** `volare_engine_layout/src/layout.rs`
- **Components:** `volare_engine_layout/src/components.rs`
- **Constraints:** `volare_engine_layout/src/constraints/mod.rs`

---

**Version 1.2** - Complete specification based on parser implementation
===/docs/examples/connectors/port_test.jsonl===
{"id":"root","type":"free_container","width":800,"height":600,"children":["center_box","top_box","bottom_box","left_box","right_box","tl_box","tr_box","bl_box","br_box","conn_top","conn_bottom","conn_left","conn_right","conn_tl","conn_tr","conn_bl","conn_br","legend"],"background":"#f5f5f5"}
{"id":"center_box","type":"rect","x":360,"y":270,"width":80,"height":60,"fill":"lightblue","stroke":"blue","stroke_width":3}
{"id":"top_box","type":"rect","x":360,"y":100,"width":60,"height":40,"fill":"lightcoral","stroke":"red","stroke_width":2}
{"id":"bottom_box","type":"rect","x":360,"y":460,"width":60,"height":40,"fill":"lightgreen","stroke":"green","stroke_width":2}
{"id":"left_box","type":"rect","x":150,"y":270,"width":60,"height":40,"fill":"lightyellow","stroke":"orange","stroke_width":2}
{"id":"right_box","type":"rect","x":590,"y":270,"width":60,"height":40,"fill":"lightpink","stroke":"purple","stroke_width":2}
{"id":"tl_box","type":"rect","x":200,"y":150,"width":50,"height":35,"fill":"lavender","stroke":"indigo","stroke_width":2}
{"id":"tr_box","type":"rect","x":550,"y":150,"width":50,"height":35,"fill":"peachpuff","stroke":"darkorange","stroke_width":2}
{"id":"bl_box","type":"rect","x":200,"y":415,"width":50,"height":35,"fill":"lightcyan","stroke":"teal","stroke_width":2}
{"id":"br_box","type":"rect","x":550,"y":415,"width":50,"height":35,"fill":"mistyrose","stroke":"crimson","stroke_width":2}
{"id":"conn_top","type":"connector","source":"center_box","source_port":"top","target":"top_box","target_port":"bottom","stroke_color":"red","stroke_width":2}
{"id":"conn_bottom","type":"connector","source":"center_box","source_port":"bottom","target":"bottom_box","target_port":"top","stroke_color":"green","stroke_width":2}
{"id":"conn_left","type":"connector","source":"center_box","source_port":"left","target":"left_box","target_port":"right","stroke_color":"orange","stroke_width":2}
{"id":"conn_right","type":"connector","source":"center_box","source_port":"right","target":"right_box","target_port":"left","stroke_color":"purple","stroke_width":2}
{"id":"conn_tl","type":"connector","source":"center_box","source_port":"top_left","target":"tl_box","target_port":"bottom_right","stroke_color":"indigo","stroke_width":2}
{"id":"conn_tr","type":"connector","source":"center_box","source_port":"top_right","target":"tr_box","target_port":"bottom_left","stroke_color":"darkorange","stroke_width":2}
{"id":"conn_bl","type":"connector","source":"center_box","source_port":"bottom_left","target":"bl_box","target_port":"top_right","stroke_color":"teal","stroke_width":2}
{"id":"conn_br","type":"connector","source":"center_box","source_port":"bottom_right","target":"br_box","target_port":"top_left","stroke_color":"crimson","stroke_width":2}
{"id":"legend","type":"vstack","children":["legend_title","legend_top","legend_bottom","legend_left","legend_right","legend_tl","legend_tr","legend_bl","legend_br"],"h_align":"left","x":20,"y":20}
{"id":"legend_title","type":"text","content":"Port Connection Test","font_size":16,"color":"black"}
{"id":"legend_top","type":"text","content":"🔴 Top ↔ Bottom","font_size":12,"color":"red"}
{"id":"legend_bottom","type":"text","content":"🟢 Bottom ↔ Top","font_size":12,"color":"green"}
{"id":"legend_left","type":"text","content":"🟠 Left ↔ Right","font_size":12,"color":"orange"}
{"id":"legend_right","type":"text","content":"🟣 Right ↔ Left","font_size":12,"color":"purple"}
{"id":"legend_tl","type":"text","content":"🔵 TopLeft ↔ BottomRight","font_size":12,"color":"indigo"}
{"id":"legend_tr","type":"text","content":"🟤 TopRight ↔ BottomLeft","font_size":12,"color":"darkorange"}
{"id":"legend_bl","type":"text","content":"🔷 BottomLeft ↔ TopRight","font_size":12,"color":"teal"}
{"id":"legend_br","type":"text","content":"🔴 BottomRight ↔ TopLeft","font_size":12,"color":"crimson"}

===/docs/examples/connectors/connectors_arrows.jsonl===
{"id":"root","type":"free_container","width":400,"height":300,"children":["center","top","right","bottom","left","conn_top","conn_right","conn_bottom","conn_left"]}
{"id":"center","type":"rect","x":160,"y":120,"width":80,"height":60,"fill":"lightblue","stroke":"blue","stroke_width":2}
{"id":"top","type":"rect","x":160,"y":20,"width":80,"height":40,"fill":"lightcoral","stroke":"red","stroke_width":2}
{"id":"right","type":"rect","x":300,"y":130,"width":80,"height":40,"fill":"lightgreen","stroke":"green","stroke_width":2}
{"id":"bottom","type":"rect","x":160,"y":240,"width":80,"height":40,"fill":"lightyellow","stroke":"orange","stroke_width":2}
{"id":"left","type":"rect","x":20,"y":130,"width":80,"height":40,"fill":"lightpink","stroke":"purple","stroke_width":2}
{"id":"conn_top","type":"connector","source":"center","source_port":"top","target":"top","target_port":"bottom","arrow_end":true,"stroke_color":"red","stroke_width":2,"arrow_size":12}
{"id":"conn_right","type":"connector","source":"center","source_port":"right","target":"right","target_port":"left","arrow_end":true,"stroke_color":"green","stroke_width":2,"arrow_size":12}
{"id":"conn_bottom","type":"connector","source":"center","source_port":"bottom","target":"bottom","target_port":"top","arrow_end":true,"stroke_color":"orange","stroke_width":2,"arrow_size":12}
{"id":"conn_left","type":"connector","source":"center","source_port":"left","target":"left","target_port":"right","arrow_end":true,"stroke_color":"purple","stroke_width":2,"arrow_size":8}
===/docs/examples/diagrams/ichikawa.jsonl===
{"id":"root","type":"ishikawa","problem":"Product Quality Issues","categories":[{"name":"People","items":[{"name":"Inadequate Training","children":[{"name":"No certification program"},{"name":"Limited mentorship"}]},{"name":"High Turnover","children":[{"name":"Low retention rates"},{"name":"Loss of expertise"},{"name":"Frequent rehiring"}]},{"name":"Poor Communication"}]},{"name":"Process","items":[{"name":"Unclear Procedures","children":[{"name":"Missing documentation"},{"name":"Outdated guidelines"}]},{"name":"Lack of Standardization","children":[{"name":"Variable methods"},{"name":"No quality checks"},{"name":"Inconsistent testing"}]},{"name":"Insufficient Reviews","children":[{"name":"Skipped inspections"},{"name":"Rushed approvals"}]}]},{"name":"Technology","items":[{"name":"Outdated Equipment","children":[{"name":"Old machinery"},{"name":"No upgrades"},{"name":"Frequent breakdowns"}]},{"name":"Software Bugs","children":[{"name":"Unpatched systems"},{"name":"Legacy code issues"}]},{"name":"Poor Integration"}]},{"name":"Materials","items":[{"name":"Low Quality Suppliers","children":[{"name":"Unreliable vendors"},{"name":"No supplier audits"},{"name":"Cost-cutting measures"}]},{"name":"Inconsistent Batches","children":[{"name":"Variable composition"},{"name":"No quality testing"}]},{"name":"Storage Issues","children":[{"name":"Improper temperature"},{"name":"Contamination risk"}]}]},{"name":"Environment","items":[{"name":"Temperature Fluctuations","children":[{"name":"Poor HVAC"},{"name":"Seasonal variations"}]},{"name":"Humidity Problems","children":[{"name":"No climate control"},{"name":"Moisture damage"},{"name":"Equipment corrosion"}]},{"name":"Workspace Layout"}]},{"name":"Measurement","items":[{"name":"Uncalibrated Tools","children":[{"name":"No calibration schedule"},{"name":"Broken gauges"}]},{"name":"Inconsistent Standards","children":[{"name":"Multiple metrics"},{"name":"Conflicting requirements"},{"name":"No reference samples"}]},{"name":"Human Error","children":[{"name":"Misreading instruments"},{"name":"Data entry mistakes"}]}]}]}
===/docs/examples/shapes/polylines.jsonl===
{"id":"root","type":"vstack","children":["title","demo_container"],"h_align":"center"}
{"id":"title","type":"text","content":"📈 Polyline Test & Examples","font_size":24,"color":"darkblue"}
{"id":"demo_container","type":"free_container","width":700,"height":500,"children":["simple_line","zigzag","triangle","star","graph","house","labels"]}
{"id":"simple_line","type":"polyline","points":[[0,0],[100,0],[100,50],[0,50]],"stroke_color":"red","stroke_width":3,"x":50,"y":50}
{"id":"zigzag","type":"polyline","points":[[0,0],[30,20],[60,0],[90,20],[120,0],[150,20]],"stroke_color":"green","stroke_width":2,"x":200,"y":50}
{"id":"triangle","type":"polyline","points":[[0,40],[40,0],[80,40],[0,40]],"stroke_color":"blue","stroke_width":3,"x":400,"y":50}
{"id":"star","type":"polyline","points":[[25,0],[30,15],[45,15],[35,25],[40,40],[25,30],[10,40],[15,25],[5,15],[20,15],[25,0]],"stroke_color":"gold","stroke_width":2,"x":550,"y":50}
{"id":"graph","type":"polyline","points":[[0,80],[20,60],[40,70],[60,30],[80,40],[100,10],[120,20],[140,5]],"stroke_color":"purple","stroke_width":3,"x":50,"y":150}
{"id":"house","type":"polyline","points":[[0,40],[0,10],[20,0],[40,10],[40,40],[30,40],[30,25],[10,25],[10,40],[0,40]],"stroke_color":"brown","stroke_width":2,"x":250,"y":150}
{"id":"labels","type":"vstack","children":["label1","label2","label3","label4","label5","label6","positioning_note"],"h_align":"left","x":50,"y":300}
{"id":"label1","type":"text","content":"• Red: Simple rectangle path","font_size":12,"color":"red"}
{"id":"label2","type":"text","content":"• Green: Zigzag line pattern","font_size":12,"color":"green"}
{"id":"label3","type":"text","content":"• Blue: Closed triangle shape","font_size":12,"color":"blue"}
{"id":"label4","type":"text","content":"• Gold: 5-pointed star","font_size":12,"color":"gold"}
{"id":"label5","type":"text","content":"• Purple: Data graph line","font_size":12,"color":"purple"}
{"id":"label6","type":"text","content":"• Brown: House outline","font_size":12,"color":"brown"}
{"id":"positioning_note","type":"text","content":"All polylines positioned using x,y coordinates","font_size":10,"color":"gray"}
===/docs/examples/shapes/arcs.jsonl===
{"id":"root","type":"vstack","children":["title","test_container"],"h_align":"center"}
{"id":"title","type":"text","content":"🌀 Arc Positioning Test","font_size":24,"color":"darkblue"}
{"id":"test_container","type":"free_container","width":600,"height":400,"children":["arc1","arc2","arc3","arc4","reference_grid","labels"]}
{"id":"arc1","type":"arc","radius":40,"start_angle":0,"end_angle":90,"stroke_color":"red","stroke_width":3,"filled":false,"x":60,"y":60}
{"id":"arc2","type":"arc","radius":30,"start_angle":0,"end_angle":180,"stroke_color":"green","stroke_width":3,"filled":true,"fill_color":"lightgreen","x":220,"y":70}
{"id":"arc3","type":"arc","radius":35,"start_angle":0,"end_angle":270,"stroke_color":"blue","stroke_width":3,"filled":false,"x":365,"y":65}
{"id":"arc4","type":"arc","radius":25,"start_angle":0,"end_angle":360,"stroke_color":"purple","stroke_width":3,"filled":true,"fill_color":"lavender","x":150,"y":225}
{"id":"reference_grid","type":"free_container","width":600,"height":400,"children":["ref1","ref2","ref3","ref4"],"x":0,"y":0}
{"id":"ref1","type":"ellipse","rx":3,"ry":3,"fill":"red","stroke":"darkred","stroke_width":1,"x":97,"y":97}
{"id":"ref2","type":"ellipse","rx":3,"ry":3,"fill":"green","stroke":"darkgreen","stroke_width":1,"x":247,"y":97}
{"id":"ref3","type":"ellipse","rx":3,"ry":3,"fill":"blue","stroke":"darkblue","stroke_width":1,"x":397,"y":97}
{"id":"ref4","type":"ellipse","rx":3,"ry":3,"fill":"purple","stroke":"darkpurple","stroke_width":1,"x":172,"y":247}
{"id":"labels","type":"vstack","children":["label1","label2","label3","label4","note"],"h_align":"left","x":50,"y":320}
{"id":"label1","type":"text","content":"• Red: 90° arc at (60,60) with radius 40","font_size":12,"color":"red"}
{"id":"label2","type":"text","content":"• Green: 180° filled arc at (220,70) with radius 30","font_size":12,"color":"green"}
{"id":"label3","type":"text","content":"• Blue: 270° arc at (365,65) with radius 35","font_size":12,"color":"blue"}
{"id":"label4","type":"text","content":"• Purple: 360° filled arc at (150,225) with radius 25","font_size":12,"color":"purple"}
{"id":"note","type":"text","content":"Small dots mark where arc centers should be","font_size":10,"color":"gray"}
===/docs/examples/shapes/arcs-and-ellipses.jsonl===
{"id":"root","type":"vstack","children":["title","shape_stack","spacing","rotated_stack"],"h_align":"center"}
{"id":"title","type":"text","content":"📦 VStack Bounding Box Test","font_size":24,"color":"darkgreen"}
{"id":"shape_stack","type":"vstack","children":["ellipse1","arc1","ellipse2","arc2","ellipse3"],"h_align":"center"}
{"id":"ellipse1","type":"ellipse","rx":30,"ry":20,"fill":"lightblue","stroke":"blue","stroke_width":2}
{"id":"arc1","type":"arc","radius":25,"start_angle":0,"end_angle":180,"stroke_color":"red","stroke_width":3,"filled":true,"fill_color":"pink"}
{"id":"ellipse2","type":"ellipse","rx":40,"ry":15,"fill":"lightgreen","stroke":"green","stroke_width":2}
{"id":"arc2","type":"arc","radius":30,"start_angle":0,"end_angle":270,"stroke_color":"purple","stroke_width":3,"filled":false}
{"id":"ellipse3","type":"ellipse","rx":25,"ry":25,"fill":"yellow","stroke":"orange","stroke_width":2}
{"id":"spacing","type":"text","content":"---","font_size":16,"color":"gray"}
{"id":"rotated_stack","type":"vstack","children":["rot_ellipse1","rot_arc1","rot_ellipse2","rot_arc2","rot_circle"],"h_align":"center"}
{"id":"rot_ellipse1","type":"ellipse","rx":35,"ry":20,"fill":"lightcoral","stroke":"darkred","stroke_width":2,"rotation":45}
{"id":"rot_arc1","type":"arc","radius":28,"start_angle":0,"end_angle":120,"stroke_color":"darkblue","stroke_width":4,"filled":true,"fill_color":"lightsteelblue","rotation":30}
{"id":"rot_ellipse2","type":"ellipse","rx":20,"ry":40,"fill":"lightpink","stroke":"deeppink","stroke_width":2,"rotation":-30}
{"id":"rot_arc2","type":"arc","radius":35,"start_angle":45,"end_angle":315,"stroke_color":"darkorange","stroke_width":3,"filled":false,"rotation":60}
{"id":"rot_circle","type":"arc","radius":20,"start_angle":0,"end_angle":360,"stroke_color":"darkviolet","stroke_width":2,"filled":true,"fill_color":"mediumpurple","rotation":90}
===/docs/examples/shapes/shapes-reference.jsonl===
{"id":"root","type":"vstack","children":["title","subtitle","shapes_table"],"h_align":"center"}
{"id":"title","type":"text","content":"🎨 Complete Shape Reference","font_size":28,"color":"darkblue"}
{"id":"subtitle","type":"text","content":"All supported shapes with examples - Renderer Reference","font_size":16,"color":"gray"}
{"id":"shapes_table","type":"table","cols":3,"children":["header1","header2","header3","text_name","text_demo","text_desc","rect_name","rect_demo","rect_desc","ellipse_name","ellipse_demo","ellipse_desc","arc_name","arc_demo","arc_desc","line_name","line_demo","line_desc","polyline_name","polyline_demo","polyline_desc","box_name","box_demo","box_desc","image_name","image_demo","image_desc","vstack_name","vstack_demo","vstack_desc","hstack_name","hstack_demo","hstack_desc","table_name","table_demo","table_desc","group_name","group_demo","group_desc","container_name","container_demo","container_desc"],"header_fill_color":"lightblue","border_color":"darkblue","border_width":2,"cell_padding":15}
{"id":"header1","type":"text","content":"Shape Type","font_size":16,"color":"darkblue"}
{"id":"header2","type":"text","content":"Example","font_size":16,"color":"darkblue"}
{"id":"header3","type":"text","content":"Description","font_size":16,"color":"darkblue"}
{"id":"text_name","type":"text","content":"Text","font_size":14,"color":"black"}
{"id":"text_demo","type":"text","content":"Hello World!\nMultiline text\nsupported","font_size":12,"color":"darkgreen"}
{"id":"text_desc","type":"text","content":"Renders text with font styling, wrapping, and line spacing","font_size":11,"color":"gray"}
{"id":"rect_name","type":"text","content":"Rectangle","font_size":14,"color":"black"}
{"id":"rect_demo","type":"rect","width":60,"height":40,"background":"lightcoral","border_color":"darkred","border_width":2,"border_radius":5}
{"id":"rect_desc","type":"text","content":"Rectangular shapes with optional rounded corners","font_size":11,"color":"gray"}
{"id":"ellipse_name","type":"text","content":"Ellipse","font_size":14,"color":"black"}
{"id":"ellipse_demo","type":"ellipse","rx":30,"ry":20,"fill":"lightblue","stroke":"darkblue","stroke_width":2}
{"id":"ellipse_desc","type":"text","content":"Ellipses and circles with customizable radii","font_size":11,"color":"gray"}
{"id":"arc_name","type":"text","content":"Arc","font_size":14,"color":"black"}
{"id":"arc_demo","type":"arc","radius":25,"start_angle":0,"end_angle":270,"stroke_color":"purple","stroke_width":3,"filled":true,"fill_color":"lavender"}
{"id":"arc_desc","type":"text","content":"Arc segments, semicircles, and pie slices","font_size":11,"color":"gray"}
{"id":"line_name","type":"text","content":"Line","font_size":14,"color":"black"}
{"id":"line_demo","type":"line","start_x":0,"start_y":0,"end_x":50,"end_y":30,"stroke_color":"red","stroke_width":3}
{"id":"line_desc","type":"text","content":"Straight lines between two points","font_size":11,"color":"gray"}
{"id":"polyline_name","type":"text","content":"Polyline","font_size":14,"color":"black"}
{"id":"polyline_demo","type":"polyline","points":[[0,20],[15,0],[30,20],[45,5],[60,25]],"stroke_color":"orange","stroke_width":2}
{"id":"polyline_desc","type":"text","content":"Connected line segments forming complex paths","font_size":11,"color":"gray"}
{"id":"box_name","type":"text","content":"Box","font_size":14,"color":"black"}
{"id":"box_demo","type":"box","padding":8,"background":"lightyellow","border_color":"gold","border_width":2,"children":["box_child"]}
{"id":"box_child","type":"text","content":"Boxed","font_size":10,"color":"darkorange"}
{"id":"box_desc","type":"text","content":"Container with padding, background, and border","font_size":11,"color":"gray"}
{"id":"image_name","type":"text","content":"Image","font_size":14,"color":"black"}
{"id":"image_demo","type":"rect","width":50,"height":30,"background":"lightgray","border_color":"gray","border_width":1}
{"id":"image_desc","type":"text","content":"Images from files or base64 data (placeholder shown)","font_size":11,"color":"gray"}
{"id":"vstack_name","type":"text","content":"VStack","font_size":14,"color":"black"}
{"id":"vstack_demo","type":"vstack","children":["vs1","vs2","vs3"],"h_align":"center"}
{"id":"vs1","type":"rect","width":15,"height":8,"background":"red"}
{"id":"vs2","type":"rect","width":20,"height":8,"background":"green"}
{"id":"vs3","type":"rect","width":12,"height":8,"background":"blue"}
{"id":"vstack_desc","type":"text","content":"Vertical layout container for stacking elements","font_size":11,"color":"gray"}
{"id":"hstack_name","type":"text","content":"HStack","font_size":14,"color":"black"}
{"id":"hstack_demo","type":"hstack","children":["hs1","hs2","hs3"],"v_align":"center"}
{"id":"hs1","type":"rect","width":8,"height":15,"background":"red"}
{"id":"hs2","type":"rect","width":8,"height":20,"background":"green"}
{"id":"hs3","type":"rect","width":8,"height":12,"background":"blue"}
{"id":"hstack_desc","type":"text","content":"Horizontal layout container for side-by-side elements","font_size":11,"color":"gray"}
{"id":"table_name","type":"text","content":"Table","font_size":14,"color":"black"}
{"id":"table_demo","type":"table","cols":2,"children":["t1","t2","t3","t4"],"border_color":"black","border_width":1,"cell_padding":3}
{"id":"t1","type":"text","content":"A","font_size":10}
{"id":"t2","type":"text","content":"B","font_size":10}
{"id":"t3","type":"text","content":"C","font_size":10}
{"id":"t4","type":"text","content":"D","font_size":10}
{"id":"table_desc","type":"text","content":"Grid layout with configurable rows and columns","font_size":11,"color":"gray"}
{"id":"group_name","type":"text","content":"Group","font_size":14,"color":"black"}
{"id":"group_demo","type":"group","children":["g1","g2"]}
{"id":"g1","type":"rect","width":20,"height":15,"background":"pink"}
{"id":"g2","type":"rect","width":15,"height":20,"background":"lightgreen"}
{"id":"group_desc","type":"text","content":"Groups elements without layout constraints","font_size":11,"color":"gray"}
{"id":"container_name","type":"text","content":"Free Container","font_size":14,"color":"black"}
{"id":"container_demo","type":"free_container","width":60,"height":40,"children":["fc1","fc2"]}
{"id":"fc1","type":"rect","width":15,"height":10,"background":"cyan","x":5,"y":5}
{"id":"fc2","type":"rect","width":10,"height":15,"background":"magenta","x":35,"y":20}
{"id":"container_desc","type":"text","content":"Absolute positioning container using x,y coordinates","font_size":11,"color":"gray"}
===/docs/examples/images.jsonl===
{"id":"root","type":"vstack","children":["header","main_content","footer"],"h_align":"center"}
{"id":"header","type":"box","padding":20,"background":"#2c3e50","children":["header_content"]}
{"id":"header_content","type":"text","content":"📷 Multi-Service Image Test","font_size":28,"color":"white"}
{"id":"main_content","type":"vstack","children":["placeholders_section","avatars_section","mixed_section"],"h_align":"center"}
{"id":"placeholders_section","type":"vstack","children":["placeholder_title","placeholder_images"],"h_align":"center"}
{"id":"placeholder_title","type":"text","content":"Lorem Picsum Placeholders","font_size":20,"color":"#34495e"}
{"id":"placeholder_images","type":"hstack","children":["placeholder_1","placeholder_2","placeholder_3","placeholder_4"],"v_align":"center"}
{"id":"placeholder_1","type":"image","src":"https://picsum.photos/150/150?random=10","width":150,"height":150}
{"id":"placeholder_2","type":"image","src":"https://picsum.photos/150/150?random=20","width":150,"height":150}
{"id":"placeholder_3","type":"image","src":"https://picsum.photos/150/150?random=30","width":150,"height":150}
{"id":"placeholder_4","type":"image","src":"https://picsum.photos/150/150?random=40","width":150,"height":150}
{"id":"avatars_section","type":"vstack","children":["avatar_title","avatar_images"],"h_align":"center"}
{"id":"avatar_title","type":"text","content":"DiceBear Avatar Generator","font_size":20,"color":"#34495e"}
{"id":"avatar_images","type":"hstack","children":["avatar_1","avatar_2","avatar_3"],"v_align":"center"}
{"id":"avatar_1","type":"image","src":"https://api.dicebear.com/7.x/avataaars/svg?seed=Felix","width":100,"height":100}
{"id":"avatar_2","type":"image","src":"https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka","width":100,"height":100}
{"id":"avatar_3","type":"image","src":"https://api.dicebear.com/7.x/avataaars/svg?seed=John","width":100,"height":100}
{"id":"mixed_section","type":"vstack","children":["mixed_title","mixed_content"],"h_align":"center"}
{"id":"mixed_title","type":"text","content":"Mixed Content Layout","font_size":20,"color":"#34495e"}
{"id":"mixed_content","type":"free_container","width":600,"height":300,"background":"#ecf0f1","border_color":"#bdc3c7","border_width":2,"children":["large_img","info_card","small_avatars"]}
{"id":"large_img","type":"image","src":"https://picsum.photos/250/200?random=100","width":250,"height":200,"x":20,"y":20}
{"id":"info_card","type":"box","padding":15,"background":"white","border_color":"#95a5a6","border_width":1,"border_radius":8,"children":["info_text"],"x":300,"y":30}
{"id":"info_text","type":"text","content":"This large image demonstrates absolute positioning within a free container. The image uses Lorem Picsum with specific dimensions and a random seed.","line_width":250,"font_size":12,"color":"#2c3e50"}
{"id":"small_avatars","type":"hstack","children":["mini_avatar_1","mini_avatar_2","mini_avatar_3"],"v_align":"center","x":350,"y":200}
{"id":"mini_avatar_1","type":"image","src":"https://api.dicebear.com/7.x/miniavs/svg?seed=test1","width":40,"height":40}
{"id":"mini_avatar_2","type":"image","src":"https://api.dicebear.com/7.x/miniavs/svg?seed=test2","width":40,"height":40}
{"id":"mini_avatar_3","type":"image","src":"https://api.dicebear.com/7.x/miniavs/svg?seed=test3","width":40,"height":40}
{"id":"footer","type":"box","padding":10,"background":"#95a5a6","children":["footer_text"]}
{"id":"footer_text","type":"text","content":"🌐 Images loaded from: picsum.photos (photos) • dicebear.com (avatars)","font_size":12,"color":"#2c3e50"}
===/docs/examples/documents/algorithmic-complexity-reference.jsonl===
{"id":"root","type":"document","content_id":"main_content", "header_id":"title"}
{"id":"main_content","type":"document.vstack","children":["intro_section","notation_section","common_section","data_structures_section","sorting_section","searching_section","rules_section"],"h_align":"left"}
{"id":"title","type":"document.title","variant":"large","text":"Algorithm Complexity Quick Reference"}
{"id":"intro_section","type":"document.section","title":"Big O Notation","columns":["intro_content"]}
{"id":"intro_content","type":"document.text","text":"Big O notation describes the upper bound of algorithm performance as input size grows. It focuses on the dominant term and ignores constants and lower-order terms."}
{"id":"notation_section","type":"document.section","title":"Common Complexities","meta":"From Best to Worst","columns":["notation_col1","notation_col2"]}
{"id":"notation_col1","type":"document.vstack","children":["fast_title","fast_props"],"h_align":"left"}
{"id":"fast_title","type":"document.text","variant":"emphasized","text":"Excellent to Good"}
{"id":"fast_props","type":"document.properties","properties":[["O(1)","Constant - Array access, hash lookup"],["O(log n)","Logarithmic - Binary search, balanced tree"],["O(n)","Linear - Simple loop, linear search"],["O(n log n)","Linearithmic - Efficient sorting (merge, heap)"]]}
{"id":"notation_col2","type":"document.vstack","children":["slow_title","slow_props"],"h_align":"left"}
{"id":"slow_title","type":"document.text","variant":"emphasized","text":"Fair to Poor"}
{"id":"slow_props","type":"document.properties","properties":[["O(n²)","Quadratic - Nested loops, bubble sort"],["O(n³)","Cubic - Triple nested loops"],["O(2ⁿ)","Exponential - Recursive fibonacci, subsets"],["O(n!)","Factorial - Permutations, traveling salesman"]]}
{"id":"common_section","type":"document.section","title":"Time vs Space","columns":["time_col","space_col"]}
{"id":"time_col","type":"document.vstack","children":["time_title","time_info","time_examples"],"h_align":"left"}
{"id":"time_title","type":"document.text","variant":"emphasized","text":"Time Complexity"}
{"id":"time_info","type":"document.text","variant":"small","text":"Measures how runtime grows with input size. Focuses on number of operations executed."}
{"id":"time_examples","type":"document.bullet_list","items":["Single loop: O(n)","Nested loops: O(n²)","Divide and conquer: O(log n)","Recursive calls: Analyze recurrence"]}
{"id":"space_col","type":"document.vstack","children":["space_title","space_info","space_examples"],"h_align":"left"}
{"id":"space_title","type":"document.text","variant":"emphasized","text":"Space Complexity"}
{"id":"space_info","type":"document.text","variant":"small","text":"Measures memory usage growth with input size. Includes auxiliary space and call stack."}
{"id":"space_examples","type":"document.bullet_list","items":["In-place algorithm: O(1)","Extra array: O(n)","Recursive depth: O(depth)","Hash table storage: O(n)"]}
{"id":"data_structures_section","type":"document.section","title":"Data Structures","columns":["ds_col1","ds_col2"]}
{"id":"ds_col1","type":"document.vstack","children":["array_title","array_ops","list_title","list_ops","stack_title","stack_ops"],"h_align":"left"}
{"id":"array_title","type":"document.text","variant":"emphasized","text":"Array / Dynamic Array"}
{"id":"array_ops","type":"document.properties","properties":[["Access","O(1)"],["Search","O(n)"],["Insert (end)","O(1) amortized"],["Insert (middle)","O(n)"],["Delete","O(n)"]]}
{"id":"list_title","type":"document.text","variant":"emphasized","text":"Linked List"}
{"id":"list_ops","type":"document.properties","properties":[["Access","O(n)"],["Search","O(n)"],["Insert (front)","O(1)"],["Insert (end)","O(n) or O(1) with tail"],["Delete","O(n)"]]}
{"id":"stack_title","type":"document.text","variant":"emphasized","text":"Stack / Queue"}
{"id":"stack_ops","type":"document.properties","properties":[["Push/Enqueue","O(1)"],["Pop/Dequeue","O(1)"],["Peek","O(1)"],["Search","O(n)"]]}
{"id":"ds_col2","type":"document.vstack","children":["hash_title","hash_ops","tree_title","tree_ops","heap_title","heap_ops"],"h_align":"left"}
{"id":"hash_title","type":"document.text","variant":"emphasized","text":"Hash Table"}
{"id":"hash_ops","type":"document.properties","properties":[["Insert","O(1) average"],["Delete","O(1) average"],["Search","O(1) average"],["Worst case","O(n) with collisions"]]}
{"id":"tree_title","type":"document.text","variant":"emphasized","text":"Binary Search Tree (Balanced)"}
{"id":"tree_ops","type":"document.properties","properties":[["Insert","O(log n)"],["Delete","O(log n)"],["Search","O(log n)"],["Unbalanced worst","O(n)"]]}
{"id":"heap_title","type":"document.text","variant":"emphasized","text":"Binary Heap"}
{"id":"heap_ops","type":"document.properties","properties":[["Insert","O(log n)"],["Delete max/min","O(log n)"],["Get max/min","O(1)"],["Heapify","O(n)"]]}
{"id":"sorting_section","type":"document.section","title":"Sorting Algorithms","columns":["sort_col1","sort_col2"]}
{"id":"sort_col1","type":"document.vstack","children":["efficient_title","efficient_sorts","simple_title","simple_sorts"],"h_align":"left"}
{"id":"efficient_title","type":"document.text","variant":"emphasized","text":"Efficient Sorts O(n log n)"}
{"id":"efficient_sorts","type":"document.properties","properties":[["Merge Sort","O(n log n) time, O(n) space, stable"],["Quick Sort","O(n log n) avg, O(n²) worst, O(log n) space"],["Heap Sort","O(n log n) time, O(1) space, not stable"]]}
{"id":"simple_title","type":"document.text","variant":"emphasized","text":"Simple Sorts O(n²)"}
{"id":"simple_sorts","type":"document.properties","properties":[["Bubble Sort","O(n²) time, O(1) space, stable"],["Selection Sort","O(n²) time, O(1) space, not stable"],["Insertion Sort","O(n²) time, O(1) space, stable, good for small n"]]}
{"id":"sort_col2","type":"document.vstack","children":["special_title","special_sorts","sort_notes_title","sort_notes"],"h_align":"left"}
{"id":"special_title","type":"document.text","variant":"emphasized","text":"Special Purpose Sorts"}
{"id":"special_sorts","type":"document.properties","properties":[["Counting Sort","O(n+k) time, O(k) space, integers only"],["Radix Sort","O(d*n) time, O(n+k) space, digits/strings"],["Bucket Sort","O(n+k) avg, O(n²) worst, uniform distribution"]]}
{"id":"sort_notes_title","type":"document.text","variant":"emphasized","text":"Notes"}
{"id":"sort_notes","type":"document.bullet_list","items":["Stable: maintains relative order of equal elements","In-place: uses O(1) or O(log n) extra space","Quick sort is often fastest in practice"]}
{"id":"searching_section","type":"document.section","title":"Searching Algorithms","columns":["search_col1","search_col2"]}
{"id":"search_col1","type":"document.vstack","children":["basic_search_title","basic_search"],"h_align":"left"}
{"id":"basic_search_title","type":"document.text","variant":"emphasized","text":"Basic Search"}
{"id":"basic_search","type":"document.properties","properties":[["Linear Search","O(n) time, O(1) space, unsorted data"],["Binary Search","O(log n) time, O(1) space, sorted data"],["Jump Search","O(√n) time, sorted arrays"],["Interpolation","O(log log n) avg, uniformly distributed"]]}
{"id":"search_col2","type":"document.vstack","children":["graph_search_title","graph_search"],"h_align":"left"}
{"id":"graph_search_title","type":"document.text","variant":"emphasized","text":"Graph Search"}
{"id":"graph_search","type":"document.properties","properties":[["DFS (Depth First)","O(V+E) time, O(V) space"],["BFS (Breadth First)","O(V+E) time, O(V) space"],["Dijkstra","O((V+E) log V) with heap"],["A* Search","O(E) with good heuristic"],["Bellman-Ford","O(VE) time, handles negative weights"]]}
{"id":"rules_section","type":"document.section","title":"Analysis Rules","columns":["rules_col1","rules_col2"]}
{"id":"rules_col1","type":"document.vstack","children":["basic_rules_title","basic_rules"],"h_align":"left"}
{"id":"basic_rules_title","type":"document.text","variant":"emphasized","text":"Basic Rules"}
{"id":"basic_rules","type":"document.bullet_list","items":["Drop constants: O(2n) → O(n)","Drop lower terms: O(n² + n) → O(n²)","Sequential: O(A + B) for separate operations","Nested: O(A * B) for nested operations","Logarithm base doesn't matter: O(log₂n) ≈ O(logₙn)"]}
{"id":"rules_col2","type":"document.vstack","children":["analysis_tips_title","analysis_tips"],"h_align":"left"}
{"id":"analysis_tips_title","type":"document.text","variant":"emphasized","text":"Analysis Tips"}
{"id":"analysis_tips","type":"document.bullet_list","items":["Count loops: each nested loop multiplies complexity","Recursive: solve recurrence relation or use Master Theorem","Amortized: average cost over sequence of operations","Best vs Average vs Worst case matter","Consider both time and space trade-offs"]}
===/docs/examples/text/text-in-box-auto-wrap.jsonl===
{"id":"test_box","type":"box","width":400,"padding":20,"children":["long_text"]}
{"id":"long_text","type":"text","content":"This is a very long text that should automatically wrap to fit within the 400px box width with 20px padding on each side."}
===/src/layout.rs===
/* Layout calculation for each type of entity */

use std::collections::HashMap;
use std::f32::{INFINITY, NEG_INFINITY};

use crate::components::Float;
use crate::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, FreeContainer,
    HorizontalStack, PolyLine, ShapeArrow, ShapeBox, ShapeEllipse, ShapeGroup, ShapeImage,
    ShapeLine, ShapeText, Table, VerticalStack,
};
use crate::{
    ConnectorType, ConstraintLayoutContainer, ConstraintSystem, HorizontalAlignment,
    LinePointReference, Point, ShapeArc, ShapeConnector, ShapeRect, ShapeSpacer, SizeBehavior,
    SpacerDirection, TextLine, VerticalAlignment,
};

use crate::transform::Transform;

/* The box layout includes the padding and the dimensions
of the wrapped element
The wrapped element position and size should be updated before calling this function
(except for grow behavior).
The wrapped element position is relative to the box position.
*/
pub fn layout_box(session: &mut DiagramBuilder, shape_box: &ShapeBox) {
    println!("Box: {:?}", shape_box);

    // Get the wrapped element dimensions
    let mut wrapped_elem_bounds = session.get_effective_bounds(shape_box.wrapped_entity.clone());

    // Calculate the box dimensions based on size behavior
    let box_width = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(width) => {
            // For fixed width, use the specified width
            width
        }
        SizeBehavior::Content => {
            // Content sizing - size based on wrapped element + padding
            wrapped_elem_bounds.width + shape_box.box_options.padding * 2.0
        }
        SizeBehavior::Grow => {
            // TODO: Implement grow behavior in future iterations
            // For now, fall back to content behavior
            wrapped_elem_bounds.width + shape_box.box_options.padding * 2.0
        }
    };

    // Auto-wrap text if box has fixed width (do this BEFORE positioning)
    if let SizeBehavior::Fixed(fixed_width) = shape_box.box_options.width_behavior {
        let wrapped_entity_type = session.entityTypes.get(&shape_box.wrapped_entity);
        if let Some(EntityType::TextShape) = wrapped_entity_type {
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            auto_wrap_text_in_box(session, &shape_box.wrapped_entity, available_width);
            // Re-get bounds after text wrapping
            wrapped_elem_bounds = session.get_effective_bounds(shape_box.wrapped_entity.clone());
        }
    }

    // Calculate the box height (after potential text wrapping)
    let box_height = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(height) => height,
        SizeBehavior::Content => wrapped_elem_bounds.height + shape_box.box_options.padding * 2.0,
        SizeBehavior::Grow => wrapped_elem_bounds.height + shape_box.box_options.padding * 2.0,
    };

    // Calculate where we want the wrapped element's bounding box to be positioned
    let desired_content_x = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(fixed_width) => {
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            if wrapped_elem_bounds.width <= available_width
                && shape_box.box_options.horizontal_alignment == HorizontalAlignment::Center
            {
                // Center the content bounding box
                shape_box.box_options.padding + (available_width - wrapped_elem_bounds.width) / 2.0
            } else {
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, position bounding box at padding
            shape_box.box_options.padding
        }
    };

    let desired_content_y = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(fixed_height) => {
            let available_height = fixed_height - shape_box.box_options.padding * 2.0;
            if wrapped_elem_bounds.height <= available_height {
                // Center the content bounding box
                shape_box.box_options.padding
                    + (available_height - wrapped_elem_bounds.height) / 2.0
            } else {
                // Content is larger than available space, align bounding box to top edge
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, position bounding box at padding
            shape_box.box_options.padding
        }
    };

    // let transform_x = desired_content_x - wrapped_elem_bounds.x;
    let transform_x = desired_content_x;
    let transform_y = desired_content_y;

    session.set_position(shape_box.wrapped_entity.clone(), transform_x, transform_y);

    println!(
        "Box: {}, width: {}, height: {}, padding: {}, content positioned at: ({}, {})",
        shape_box.entity,
        box_width,
        box_height,
        shape_box.box_options.padding,
        transform_x,
        transform_y
    );

    // Set the box dimensions
    session.set_size(shape_box.entity.clone(), box_width, box_height);
}

pub fn calculate_optimal_line_width(
    session: &DiagramBuilder,
    text: &str,
    text_options: &TextOptions,
    available_width: Float,
) -> usize {
    // Binary search for optimal line_width
    let mut min_width = 10;
    let mut max_width = text.len();
    let mut best_width = min_width;

    while min_width <= max_width {
        let mid_width = (min_width + max_width) / 2;

        // Test this line_width
        let mut test_options = text_options.clone();
        test_options.line_width = mid_width;

        let wrapped_lines = textwrap::wrap(text, mid_width);
        if wrapped_lines.is_empty() {
            break;
        }

        // Measure the widest line
        let max_line_width = wrapped_lines
            .iter()
            .map(|line| session.measure_text.unwrap()(line, &test_options).0)
            .fold(0.0f32, |a, b| a.max(b));

        if max_line_width <= available_width {
            best_width = mid_width;
            min_width = mid_width + 1; // Try wider
        } else {
            max_width = mid_width - 1; // Try narrower
        }
    }

    best_width
}

fn auto_wrap_text_in_box(
    session: &mut DiagramBuilder,
    text_entity_id: &EntityID,
    available_width: Float,
) {
    // Get the current text shape
    let text_shape = session.get_text(text_entity_id.clone()).clone();

    // Calculate optimal line_width using actual text measurement
    let new_line_width = calculate_optimal_line_width(
        session,
        &text_shape.text,
        &text_shape.text_options,
        available_width,
    );
    // Only re-layout if line_width changed significantly
    if (new_line_width as i32 - text_shape.text_options.line_width as i32).abs() > 5 {
        // Create new text options with updated line_width
        let mut new_text_options = text_shape.text_options.clone();
        new_text_options.line_width = new_line_width;

        // Re-create text lines with new wrapping
        let text_lines = textwrap::wrap(&text_shape.text, new_line_width);
        let mut new_lines = Vec::new();

        // Update existing lines or create new ones
        for (i, line_text) in text_lines.iter().enumerate() {
            let line_id = if i < text_shape.lines.len() {
                // Reuse existing line
                let existing_line_id = text_shape.lines[i].clone();
                let existing_line = session.get_text_line_mut(existing_line_id.clone());
                if let Some(existing_line) = existing_line {
                    existing_line.text = line_text.to_string();
                } else {
                    println!(
                        "Warning: Text line ID {} not found in session",
                        existing_line_id
                    );
                    continue;
                }
                existing_line_id
            } else {
                // Create new line
                // Note: here we are creating new elements on layout
                let line_id = format!("{}-autowrap-line-{}", text_entity_id, i);
                session.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line_text.to_string(),
                };
                session.add_text_line(line_id.clone(), text_line);
                line_id
            };
            new_lines.push(line_id);
        }

        // Update the text shape with new options and lines
        let updated_text_shape = ShapeText {
            entity: text_shape.entity.clone(),
            text: text_shape.text.clone(),
            text_options: new_text_options,
            lines: new_lines,
        };

        // Update the session with the new text shape
        session.add_text(text_entity_id.clone(), updated_text_shape.clone());

        // Re-layout the text with new dimensions
        layout_text(session, &updated_text_shape);
    }
}

// Helper function to estimate character width based on font
fn estimate_char_width(text_options: &TextOptions) -> Float {
    // Rough estimation: font_size * 0.6 for typical fonts
    // You could make this more sophisticated based on font_family
    text_options.font_size * 0.6
}

/**
 * Update the group size based on the size of the elements.
 * Group elements must be positioned before calling this function.
 * (Doesn't update the position of the elements)
 */

pub fn layout_group(session: &mut DiagramBuilder, shape_group: &ShapeGroup) {
    println!("layout_group called {}", shape_group.entity);
    // Calculate actual bounding box using positions, not just max dimensions
    let mut min_x = Float::INFINITY;
    let mut min_y = Float::INFINITY;
    let mut max_x = Float::NEG_INFINITY;
    let mut max_y = Float::NEG_INFINITY;

    for elem in shape_group.elements.iter() {
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let elem_pos = session.get_local_position(elem.clone()); // Uses transforms behind the scenes

        min_x = min_x.min(elem_pos.0);
        min_y = min_y.min(elem_pos.1);
        max_x = max_x.max(elem_pos.0 + elem_bounds.width);
        max_y = max_y.max(elem_pos.1 + elem_bounds.height);
    }

    if min_x != Float::INFINITY {
        let width = max_x - min_x;
        let height = max_y - min_y;
        session.set_size(shape_group.entity.clone(), width, height);

        // use bounding box compensation since set_position works with transform origins
        let group_bounds = session.get_effective_bounds(shape_group.entity.clone());
        let transform_x = min_x - group_bounds.x;
        let transform_y = min_y - group_bounds.y;
        session.set_position(shape_group.entity.clone(), transform_x, transform_y);
    } else {
        session.set_size(shape_group.entity.clone(), 0.0, 0.0);
        session.set_position(shape_group.entity.clone(), 0.0, 0.0);
    }
}

// WHY this function doesn't need the bounding box compensation:
//
// 1. Text lines don't have individual rotations - they're just positioned within the text entity
// 2. The rotation transform is applied to the parent text entity as a whole
// 3. Individual lines are positioned relative to (0,0) within the text entity
// 4. When the text entity is rotated, all lines rotate together as one unit
//
// Transform hierarchy:
// Text Entity (has rotation transform)
//   └── Line 1 (positioned at 0, 0 relative to text entity)
//   └── Line 2 (positioned at 0, 16 relative to text entity)
//   └── Line 3 (positioned at 0, 32 relative to text entity)
pub fn layout_text(session: &mut DiagramBuilder, shape_text: &ShapeText) {
    let mut y = 0.0;
    let mut max_line_width = 0.0;

    for (i, line) in shape_text.lines.iter().enumerate() {
        let textLine = session.get_text_line(line.clone());
        let line_size = session.measure_text.unwrap()(&textLine.text, &shape_text.text_options);

        if line_size.0 > max_line_width {
            max_line_width = line_size.0;
        }

        session.set_position(line.clone(), 0.0, y);
        session.set_size(line.clone(), line_size.0, line_size.1);

        // Add line height
        y += line_size.1;

        if i < shape_text.lines.len() - 1 {
            y += shape_text.text_options.line_spacing;
        }
    }

    // No need to subtract line spacing at the end
    session.set_size(shape_text.entity.clone(), max_line_width, y);
}

pub fn layout_spacer(session: &mut DiagramBuilder, spacer: &ShapeSpacer) {
    let (width, height) = match spacer.spacer_options.direction {
        SpacerDirection::Horizontal => (spacer.spacer_options.width, 1.0),
        SpacerDirection::Vertical => (1.0, spacer.spacer_options.height),
        SpacerDirection::Both => (spacer.spacer_options.width, spacer.spacer_options.height),
    };

    session.set_size(spacer.entity.clone(), width, height);
}

/**
 * Updates the size of the line entity based on the start and end points
 * Points can be set directly or through other Point entitys
 */
pub fn layout_line(session: &mut DiagramBuilder, shape_line: &ShapeLine) {
    let start = shape_line.start.clone();
    let end = shape_line.end.clone();

    let mut start_point = Point::new(0.0, 0.0);
    let mut end_point = Point::new(0.0, 0.0);

    match start {
        LinePointReference::Value(x, y) => {
            start_point.x = x;
            start_point.y = y;
        }
        // Lines can refer a point (technically it can be any other entity with a position)
        LinePointReference::PointID(id) => {
            let pos = session.get_local_position(id);
            start_point.x = pos.0;
            start_point.y = pos.1;
        }
    }

    match end {
        LinePointReference::Value(x, y) => {
            end_point.x = x;
            end_point.y = y;
        }
        // Lines can refer a point (technically it can be any other entity with a position)
        LinePointReference::PointID(id) => {
            let pos = session.get_local_position(id);
            end_point.x = pos.0;
            end_point.y = pos.1;
        }
    }

    session.set_size(
        shape_line.entity.clone(),
        (end_point.x - start_point.x).abs(),
        (end_point.y - start_point.y).abs(),
    );
}
pub fn layout_connector(session: &mut DiagramBuilder, connector: &ShapeConnector) {
    // Get port positions
    let (start_x, start_y) =
        session.get_port_position(&connector.source_id, &connector.options.source_port);
    let (end_x, end_y) =
        session.get_port_position(&connector.target_id, &connector.options.target_port);

    println!(
        "🔗 Connector {} connecting ({:.1}, {:.1}) to ({:.1}, {:.1})",
        connector.entity, start_x, start_y, end_x, end_y
    );

    session.set_position(connector.start_point_id.clone(), start_x, start_y);
    session.set_position(connector.end_point_id.clone(), end_x, end_y);

    // Calculate bounding box based on connector type
    let (min_x, max_x, min_y, max_y) = match connector.options.connector_type {
        ConnectorType::Curved => {
            // For curved connectors, we need to account for the curve's bounding box
            // The curve extends beyond the straight line between points
            let curve_offset = connector.options.curve_offset.unwrap_or(50.0);

            // Determine curve direction based on relative positions
            let dx = end_x - start_x;
            let dy = end_y - start_y;

            // For horizontal curves (primary direction is horizontal)
            let extends_horizontally = dx.abs() > dy.abs();

            let (min_x, max_x) = if extends_horizontally {
                (start_x.min(end_x), start_x.max(end_x))
            } else {
                // Vertical curve - control points extend horizontally
                let curve_extent = curve_offset.abs();
                (
                    start_x.min(end_x) - curve_extent,
                    start_x.max(end_x) + curve_extent,
                )
            };

            let (min_y, max_y) = if extends_horizontally {
                // Horizontal curve - control points extend vertically
                let curve_extent = curve_offset.abs();
                (
                    start_y.min(end_y) - curve_extent,
                    start_y.max(end_y) + curve_extent,
                )
            } else {
                (start_y.min(end_y), start_y.max(end_y))
            };

            (min_x, max_x, min_y, max_y)
        }
        ConnectorType::Orthogonal => {
            // For orthogonal connectors, add some buffer for the segments
            let buffer = 20.0; // Buffer for orthogonal segments
            (
                start_x.min(end_x) - buffer,
                start_x.max(end_x) + buffer,
                start_y.min(end_y) - buffer,
                start_y.max(end_y) + buffer,
            )
        }
        ConnectorType::Straight => {
            // Straight line - just use the endpoints
            (
                start_x.min(end_x),
                start_x.max(end_x),
                start_y.min(end_y),
                start_y.max(end_y),
            )
        }
    };

    let width = max_x - min_x;
    let height = max_y - min_y;

    println!(
        "   Connector bounds: pos=({:.1}, {:.1}), size=({:.1}, {:.1})",
        min_x, min_y, width, height
    );

    session.set_position(connector.entity.clone(), min_x, min_y);
    session.set_size(connector.entity.clone(), width, height);

    // Position label intelligently based on connector orientation
    if let Some(label_text) = connector.label.clone() {
        if !label_text.is_empty() {
            // Get label dimensions
            let label_size = session.measure_text.unwrap()(
                label_text.as_str(),
                &TextOptions::default(),
            );

            // Calculate connector midpoint (in absolute coordinates)
            let mid_x = (start_x + end_x) / 2.0;
            let mid_y = (start_y + end_y) / 2.0;

            // Calculate connector vector and orientation
            let dx = end_x - start_x;
            let dy = end_y - start_y;
            let length = (dx * dx + dy * dy).sqrt();

            // Determine label offset based on connector orientation
            let label_offset = 8.0; // Distance from connector line
            let (label_x, label_y) = if length > 0.0 {
                // Determine if connector is more horizontal or vertical
                let is_horizontal = dx.abs() > dy.abs();

                if is_horizontal {
                    // For horizontal connectors: place label above (negative y direction)
                    // Center horizontally on midpoint
                    let lx = mid_x - label_size.0 / 2.0;
                    let ly = mid_y - label_offset - label_size.1;
                    (lx, ly)
                } else {
                    // For vertical connectors: place label to the right (positive x direction)
                    // Center vertically on midpoint
                    let lx = mid_x + label_offset;
                    let ly = mid_y - label_size.1 / 2.0;
                    (lx, ly)
                }
            } else {
                // Fallback for zero-length connectors (shouldn't happen)
                (mid_x - label_size.0 / 2.0, mid_y - label_offset - label_size.1)
            };

            session.set_position(format!("{}_label_elem", connector.entity), label_x, label_y);
        }
    }
}
/**
 * Updates the size of the arrow entity based on the start and end points
 */
pub fn layout_arrow(session: &mut DiagramBuilder, shape_arrow: &ShapeArrow) {
    let start = shape_arrow.start;
    let end = shape_arrow.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_arrow.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_arrow.entity.clone(), x, y);
}

/**
 * Updates the size of the ellipse entity based on the horizontal and vertical radius
 * radius.0 is the horizontal radius and radius.1 is the vertical radius
 * The position of the ellipse is the top left corner of the bounding box
 */
pub fn layout_ellipse(session: &mut DiagramBuilder, shape_ellipse: &ShapeEllipse) {
    // Only set the size based on radius
    let width = shape_ellipse.radius.0 * 2.0;
    let height = shape_ellipse.radius.1 * 2.0;
    session.set_size(shape_ellipse.entity.clone(), width, height);
}

pub fn layout_rect(session: &mut DiagramBuilder, rect: &ShapeRect) {
    // If the rect has a fixed size, use that
    let width = match rect.rect_options.width_behavior {
        SizeBehavior::Fixed(w) => w,
        _ => 0.0,
    };
    let height = match rect.rect_options.height_behavior {
        SizeBehavior::Fixed(h) => h,
        _ => 0.0,
    };

    session.set_size(rect.entity.clone(), width, height);
}

/**
 * Sets the image entity size to the preferred size
 */
pub fn layout_image(session: &mut DiagramBuilder, shape_image: &ShapeImage) {
    let width = match shape_image.width_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0,
    };

    let height = match shape_image.height_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0,
    };

    session.set_size(shape_image.entity.clone(), width, height);
}
/**
 * Updates the position of the elements in the vertical stack
 * and the size of the vertical stack
 */
pub fn layout_vertical_stack(session: &mut DiagramBuilder, vertical_stack: &VerticalStack) {
    let mut logical_y = 0.0; // Where we want each element's bounding box to start
    let mut width = 0.0;

    for elem in vertical_stack.elements.iter() {
        println!("DEBUG:::y: {}", logical_y);
        let elem_bounds = session.get_effective_bounds(elem.clone());

        // FIXED: Position the element so its bounding box starts at logical_y
        let transform_y = logical_y - elem_bounds.y;
        session.set_position(elem.clone(), 0.0, transform_y);

        // FIXED: Add the effective height to logical_y for next element
        logical_y += elem_bounds.height;

        if elem_bounds.width > width {
            width = elem_bounds.width;
        }
    }

    // Set the stack size to the total logical height
    session.set_size(vertical_stack.entity.clone(), width, logical_y);

    // Second pass: adjust x positions for horizontal alignment
    for elem in vertical_stack.elements.iter() {
        // FIXED: Use effective bounds consistently for alignment calculations
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let current_pos = session.get_local_position(elem.clone());

        let x = match vertical_stack.horizontal_alignment {
            HorizontalAlignment::Left => -elem_bounds.x, // Compensate for bounding box offset
            HorizontalAlignment::Center => (width - elem_bounds.width) / 2.0 - elem_bounds.x,
            HorizontalAlignment::Right => width - elem_bounds.width - elem_bounds.x,
        };

        session.set_position(elem.clone(), x, current_pos.1); // Update x, keep y
    }
}

pub fn layout_horizontal_stack(session: &mut DiagramBuilder, horizontal_stack: &HorizontalStack) {
    let mut logical_x = 0.0; // Where we want each element's bounding box to start
    let mut height = 0.0;

    for elem in horizontal_stack.elements.iter() {
        let elem_bounds = session.get_effective_bounds(elem.clone());

        // FIXED: Position the element so its bounding box starts at logical_x
        let transform_x = logical_x - elem_bounds.x;
        session.set_position(elem.clone(), transform_x, 0.0);

        // FIXED: Add the effective width to logical_x for next element
        logical_x += elem_bounds.width;

        if elem_bounds.height > height {
            height = elem_bounds.height;
        }
    }

    // Set the stack size to the total logical width
    session.set_size(horizontal_stack.entity.clone(), logical_x, height);

    // Second pass: adjust y positions for vertical alignment
    for elem in horizontal_stack.elements.iter() {
        // FIXED: Use effective bounds consistently for alignment calculations
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let current_pos = session.get_local_position(elem.clone());

        let y = match horizontal_stack.vertical_alignment {
            VerticalAlignment::Top => -elem_bounds.y, // Compensate for bounding box offset
            VerticalAlignment::Center => (height - elem_bounds.height) / 2.0 - elem_bounds.y,
            VerticalAlignment::Bottom => height - elem_bounds.height - elem_bounds.y,
        };

        session.set_position(elem.clone(), current_pos.0, y);
    }
}
/**
 * Calculates the layout for each of the cells according to table rules:
 * - Cells in the same column have the same width (eq to the max of widths)
 * - Cells in the same row have the same height (eq to the max of heights)
 * - Rows on top of each other
 * - Cols to the right of each other
 * - The sizes of the internal elements should be previously computed for this to work
 */
pub fn layout_table(session: &mut DiagramBuilder, table: &Table) {
    //we need to group elements by row and column, calculate their
    //natural sizes and then update their rows and columns
    let mut rows: Vec<Vec<EntityID>> = Vec::new();
    let mut cols: Vec<Vec<EntityID>> = Vec::new();
    let mut row_heights: Vec<Float> = Vec::new();
    let mut col_widths: Vec<Float> = Vec::new();

    // Add variables to store line positions
    let mut horizontal_line_positions: Vec<Float> = Vec::new();
    let mut vertical_line_positions: Vec<Float> = Vec::new();

    //initialize rows and cols
    for (i, elem) in table.cells.iter().enumerate() {
        let row = i / table.cols;
        let col = i % table.cols;
        //add the element to the row and col
        if row >= rows.len() {
            rows.push(Vec::new());
            row_heights.push(0.0);
        }
        if col >= cols.len() {
            cols.push(Vec::new());
            col_widths.push(0.0);
        }
        rows[row].push(elem.clone());
        cols[col].push(elem.clone());

        //update the row and col sizes
        let elem_bounds = session.get_effective_bounds(elem.clone());

        let content_width = elem_bounds.width + table.table_options.cell_padding as Float * 2.0;
        let content_height = elem_bounds.height + table.table_options.cell_padding as Float * 2.0;
        if content_width > col_widths[col] {
            col_widths[col] = content_width;
        }
        if content_height > row_heights[row] {
            row_heights[row] = content_height;
        }
    }

    //print row heights and col widths
    println!("row heights: {:?}", row_heights);
    println!("col widths: {:?}", col_widths);

    //we already have each row and col and their sizes.
    //Now we have to update the position of each element
    //and the size of the table

    //iterate through rows and cols and update the position of each element
    let mut logical_x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        let mut logical_y = 0.0;
        for (j, elem) in col.iter().enumerate() {
            let elem_bounds = session.get_effective_bounds(elem.clone());

            // Calculate where we want the element's bounding box to be (with padding)
            let desired_x = logical_x + table.table_options.cell_padding as Float;
            let desired_y = logical_y + table.table_options.cell_padding as Float;

            // Compensate for the element's bounding box offset
            let transform_x = desired_x - elem_bounds.x;
            let transform_y = desired_y - elem_bounds.y;

            // FIXED: Instead of overwriting position, add translation to existing transform
            let current_transform = session.get_transform(elem.clone());
            let position_transform = Transform::translation(transform_x, transform_y);
            let new_transform = current_transform.combine(&position_transform);
            session.set_transform(elem.clone(), new_transform);

            logical_y += row_heights[j];
        }
        logical_x += col_widths[i];
    }

    //Update the position of the horizontal lines
    let mut y = 0.0;
    for (i, row) in rows.iter().enumerate() {
        horizontal_line_positions.push(y);
        y += row_heights[i];
    }

    //Update the position of the vertical lines
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        vertical_line_positions.push(x);
        x += col_widths[i];
    }

    //update the size of the table
    let width: Float = col_widths.iter().sum();
    let height: Float = row_heights.iter().sum();

    //Update the size of the table header rect
    if let Some(header_rect) = &table.header_rect {
        session.set_size(header_rect.clone(), width, row_heights[0]);
    }

    //print the size of the table
    println!("Table size: {:?}", (width, height));

    session.set_size(table.entity.clone(), width, height);

    //We need to update the position of the horizontal lines and their size
    for (i, line_id) in table.row_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line_id.clone());
        if i < horizontal_line_positions.len() {
            let line = session.get_line_mut(line_id.clone());
            let line_w: Float;
            let line_h: Float;
            if let Some(line) = line {
                let start_point = Point::new(0.0, horizontal_line_positions[i]);
                let end_point = Point::new(width, horizontal_line_positions[i]);

                line.start = LinePointReference::Value(start_point.x, start_point.y);
                line.end = LinePointReference::Value(end_point.x, end_point.y);
                line_w = end_point.x - start_point.x;
                line_h = end_point.y - start_point.y;
                // correct size of line
                session.set_size(line_id.clone(), line_w, line_h)
            }
        }
    }

    for (i, line_id) in table.col_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        if i < vertical_line_positions.len() {
            let line = session.get_line_mut(line_id.clone());
            let line_w: Float;
            let line_h: Float;
            if let Some(line) = line {
                let start_point = Point::new(vertical_line_positions[i], 0.0);
                let end_point = Point::new(vertical_line_positions[i], height);
                line.start = LinePointReference::Value(start_point.x, start_point.y);
                line.end = LinePointReference::Value(end_point.x, end_point.y);
                line_w = end_point.x - start_point.x;
                line_h = end_point.y - start_point.y;
                // correct size of line
                session.set_size(line_id.clone(), line_w, line_h)
            }
        }
    }
}

pub fn layout_polyline(session: &mut DiagramBuilder, polyline: &PolyLine) {
    if polyline.points.is_empty() {
        session.set_size(polyline.entity.clone(), 0.0, 0.0);
        return;
    }

    // Find the actual bounding box of all points
    let mut min_x = Float::INFINITY;
    let mut min_y = Float::INFINITY;
    let mut max_x = Float::NEG_INFINITY;
    let mut max_y = Float::NEG_INFINITY;

    for point in polyline.points.iter() {
        min_x = min_x.min(point.0);
        min_y = min_y.min(point.1);
        max_x = max_x.max(point.0);
        max_y = max_y.max(point.1);
    }

    let width = max_x - min_x;
    let height = max_y - min_y;

    // Set the polyline size to its actual bounding box
    session.set_size(polyline.entity.clone(), width, height);
}

/**
 * Layout for the FreeContainer
 * Children have absolute positions relative to the container
 * The container size is determined by the maximum extent of its children
*/
pub fn layout_free_container(session: &mut DiagramBuilder, container: &FreeContainer) {
    let mut max_width = 0.0;
    let mut max_height = 0.0;

    for (child_id, desired_position) in &container.children {
        // TODO: This can be set on creation time
        session.set_position(child_id.clone(), desired_position.0, desired_position.1);

        // FIX: Use effective bounds instead of raw size
        let child_bounds = session.get_effective_bounds(child_id.clone());

        // Calculate the extent based on position + effective bounds dimensions
        let right = desired_position.0 + child_bounds.width; // Use width from bounds
        let bottom = desired_position.1 + child_bounds.height; // Use height from bounds

        if right > max_width {
            max_width = right;
        }
        if bottom > max_height {
            max_height = bottom;
        }
    }

    session.set_size(container.entity.clone(), max_width, max_height);
}

pub fn layout_arc(session: &mut DiagramBuilder, shape_arc: &ShapeArc) {
    let diameter = shape_arc.radius * 2.0;
    session.set_size(shape_arc.entity.clone(), diameter, diameter);
}

/// Determina si el size de un shape puede ser cambiado por un constraint
/// Solo rectangulos y boxes pueden alterar su tamaño, el resto se considera fijo
/// y el solver cassowary debe respetar esto
fn isFixedSize(builder: &DiagramBuilder, id: EntityID) -> bool {
    let entity_type = builder.entityTypes.get(&id);
    if let Some(etype) = entity_type {
        match etype {
            EntityType::BoxShape => false,
            EntityType::RectShape => false,
            _ => true,
        }
    } else {
        false
    }
}

pub fn layout_constraint_container(
    builder: &mut DiagramBuilder,
    container: &ConstraintLayoutContainer,
) -> anyhow::Result<()> {
    println!("layout_constraint_container called");

    let child_sizes: Vec<(String, (Float, Float))> = container
        .children
        .iter()
        .filter_map(|child_id| Some((child_id.clone(), builder.get_size(child_id.clone()).clone())))
        .collect();

    // Collect bools that indicate if the solver can modify the element's size
    let mut is_fixed_size_map = HashMap::<EntityID, bool>::new();
    child_sizes.iter().for_each(|(id, (w, h))| {
        let is_fixed = isFixedSize(builder, id.clone());
        is_fixed_size_map.insert(id.to_string(), is_fixed);
    });

    let system = builder.get_constraint_system_mut(container.entity.clone());

    // Use existing sizes as suggestions
    // at this point children already have their sizes calculated
    for (child_id, (w, h)) in child_sizes {
        system
            .suggest_size(
                child_id.as_str(),
                w,
                h,
                is_fixed_size_map.get(&child_id).unwrap_or(&true).to_owned(),
            )
            .map_err(|e| anyhow::anyhow!("Failed to suggest size for entity {:?}", e))?;
    }

    // Solve constraints
    let results = system.solve()?;

    // Apply results
    let mut container_width = 0.0;
    let mut container_height = 0.0;

    // Negative positions for children are problematic, we compensate by adding an offset
    // if the element that's most to the left has -10, all elements will be added 10 to x

    let mut min_x: Float = INFINITY;
    let mut min_y: Float = INFINITY;

    for (_, (x, y, _, _)) in results.clone() {
        min_x = min_x.min(x);
        min_y = min_y.min(y)
    }

    let offset_x = if min_x < 0.0 { min_x.abs() } else { 0.0 };
    let offset_y = if min_y < 0.0 { min_y.abs() } else { 0.0 };

    println!("offset_x: {}", offset_x);
    println!("offset_y: {}", offset_y);

    // Set final position and size for children
    for (entity_id, (x, y, width, height)) in results {
        println!(
            "constraint variable: {}, x:{}, y:{}, w:{}, h:{}",
            entity_id.clone(),
            x,
            y,
            width,
            height
        );
        builder.set_position(entity_id.clone(), x + offset_x, y + offset_y);
        builder.set_size(entity_id.clone(), width, height);

        let right = x + offset_x + width;
        let bottom = y + offset_y + height;
        if right > container_width {
            container_width = right;
        }

        if bottom > container_height {
            container_height = bottom;
        }
    }

    println!(
        "container size calculated: {},{}",
        container_width, container_height
    );
    builder.set_size(container.entity.clone(), container_width, container_height);

    // NOW layout lines that use PointID references
    // At this point, all points have their final positions from the constraint solver
    for child_id in &container.children {
        let entity_type = builder.entityTypes.get(child_id);

        if let Some(EntityType::LineShape) = entity_type {
            let line = builder.get_line(child_id.clone()).clone();
            if matches!(line.start, LinePointReference::PointID(_))
                || matches!(line.end, LinePointReference::PointID(_))
            {
                println!(
                    "✅ Now laying out line {} with final point positions",
                    child_id
                );
                layout_line(builder, &line);
            }
        }
    }

    // NOW layout connectors that depend on final positions
    for child_id in &container.children {
        let entity_type = builder.entityTypes.get(child_id);

        if let Some(EntityType::ConnectorShape) = entity_type {
            println!(
                "✅ Now laying out connector {} with final positions",
                child_id
            );
            let connector = builder.get_connector(child_id.clone()).clone();
            layout_connector(builder, &connector);
        }
    }

    Ok(())
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BoundingBox {
    pub x: Float,
    pub y: Float,
    pub width: Float,
    pub height: Float,
}

//Calculate the layout for a tree of elements
pub fn layout_tree_node(session: &mut DiagramBuilder, root: &DiagramTreeNode) -> BoundingBox {
    //start with the bottom elements
    for child in &root.children {
        println!("Layout child: {:?}", child);

        // Skip connectors in first pass
        if child.entity_type == EntityType::ConnectorShape {
            continue;
        }

        // Skip lines that use PointID if we're inside a ConstraintLayoutContainer
        // They will be laid out AFTER constraints are solved
        if root.entity_type == EntityType::ConstraintLayoutContainer {
            if child.entity_type == EntityType::LineShape {
                let line = session.get_line(child.entity_id.clone());
                if matches!(line.start, LinePointReference::PointID(_))
                    || matches!(line.end, LinePointReference::PointID(_))
                {
                    println!(
                        "⏭️  Skipping line {} during initial layout (uses PointID)",
                        child.entity_id
                    );
                    continue; // Skip this line, it will be laid out after constraints
                }
            }
        }

        layout_tree_node(session, child);
        //print size and position of the child

        let child_size = session.get_size(child.entity_id.clone());
        let child_pos = session.get_local_position(child.entity_id.clone());
        println!("Child size: {:?}", child_size);
        println!("Child pos: {:?}", child_pos);
    }

    //Once the children are laid out, we can layout the current element
    //use methods in the layout module
    match root.entity_type {
        EntityType::SpacerShape => {
            let spacer = session.get_spacer(root.entity_id.clone()).clone();
            layout_spacer(session, &spacer);
        }
        EntityType::TextShape => {
            {
                //get the Shape text entity
                let text = session.get_text(root.entity_id.clone()).clone();
                layout_text(session, &text);
            }
        }
        EntityType::BoxShape => {
            //get the Shape box entity
            let box_shape = session.get_box(root.entity_id.clone()).clone();
            layout_box(session, &box_shape);
        }

        EntityType::RectShape => {
            //get the Rect entity
            let rect = session.get_rectangle(root.entity_id.clone()).clone();
            layout_rect(session, &rect);
        }

        EntityType::LineShape => {
            //get the Shape line entity
            let line = session.get_line(root.entity_id.clone()).clone();
            layout_line(session, &line);
        }

        EntityType::ConnectorShape => {
            // Skip, they are handled in layout_diagram in a later phase
        }

        EntityType::ArrowShape => {
            //get the Shape arrow entity
            let arrow = session.get_arrow(root.entity_id.clone()).clone();
            layout_arrow(session, &arrow);
        }
        EntityType::EllipseShape => {
            //get the Shape ellipse entity
            let ellipse = session.get_ellipse(root.entity_id.clone()).clone();
            layout_ellipse(session, &ellipse);
        }
        EntityType::ImageShape => {
            //get the Shape image entity
            let image = session.get_image(root.entity_id.clone()).clone();
            layout_image(session, &image);
        }
        EntityType::VerticalStackShape => {
            //get the VerticalStack entity
            let vertical_stack = session.get_vertical_stack(root.entity_id.clone()).clone();
            layout_vertical_stack(session, &vertical_stack);
        }

        EntityType::HorizontalStackShape => {
            //get the HorizontalStack entity
            let horizontal_stack = session.get_horizontal_stack(root.entity_id.clone()).clone();
            layout_horizontal_stack(session, &horizontal_stack);
        }

        EntityType::TableShape => {
            //get the Table entity
            let table = session.get_table(root.entity_id.clone()).clone();
            layout_table(session, &table);
        }

        EntityType::GroupShape => {
            //get the Group entity
            let group = session.get_group(root.entity_id.clone()).clone();
            layout_group(session, &group);
        }

        EntityType::PolyLine => {
            let polyline = session.get_polyline(root.entity_id.clone()).clone();
            layout_polyline(session, &polyline);
        }
        EntityType::FreeContainer => {
            let container = session.get_free_container(root.entity_id.clone()).clone();
            layout_free_container(session, &container);
        }

        EntityType::ConstraintLayoutContainer => {
            let container = session
                .get_constraint_layout(root.entity_id.clone())
                .clone();
            layout_constraint_container(session, &container);
        }

        EntityType::ArcShape => {
            let arc = session.get_arc(root.entity_id.clone()).clone();
            layout_arc(session, &arc);
        }

        EntityType::PointShape => {
            // Ignore points
        }

        //if not recognized, show the name of it in the panic
        _ => panic!("Unknown entity type: {:?}", root.entity_type),
    }

    session.get_effective_bounds(root.entity_id.clone())
}

/// Recursively calculates and caches absolute positions for all nodes in the tree
/// Properly handles rotation, scaling, and translation by accumulating transforms
fn calculate_absolute_positions(
    session: &mut DiagramBuilder,
    node: &DiagramTreeNode,
    parent_transform: Transform,
) {
    // Get this node's local transform
    let local_transform = session.get_transform(node.entity_id.clone());

    // Combine parent transform with local transform
    // Order matters: parent_transform * local_transform
    let absolute_transform = parent_transform.combine(&local_transform);

    // The absolute position is the translation component of the combined transform
    let absolute_pos = (absolute_transform.matrix[4], absolute_transform.matrix[5]);

    // Store it in the cache
    session
        .absolute_positions
        .insert(node.entity_id.clone(), absolute_pos);

    println!(
        "📍 Absolute position for {}: ({:.1}, {:.1})",
        node.entity_id, absolute_pos.0, absolute_pos.1
    );

    // Recursively process all children with the accumulated transform
    for child in &node.children {
        calculate_absolute_positions(session, child, absolute_transform.clone());
    }
}
/// Complete diagram layout in three passes:
/// 1. Calculate sizes and local positions (layout_tree_node) - skips connectors
/// 2. Calculate absolute positions for all elements
/// 3. Layout connectors using absolute positions
pub fn layout_diagram(session: &mut DiagramBuilder, root: &DiagramTreeNode) -> BoundingBox {
    println!("🎨 Starting diagram layout...");

    // Pass 1: Calculate sizes and set local positions
    // Connectors are skipped in this pass
    let bbox = layout_tree_node(session, root);

    println!("✅ Layout complete, now calculating absolute positions...");

    // Pass 2: Calculate and cache absolute positions
    session.absolute_positions.clear();
    calculate_absolute_positions(session, root, Transform::identity());

    println!(
        "✅ Absolute positions calculated for {} elements",
        session.absolute_positions.len()
    );

    // Pass 3: Layout all connectors now that absolute positions are available
    println!("🔗 Laying out connectors...");
    layout_connectors_recursive(session, root);
    println!("✅ Connectors laid out");

    bbox
}

/// Recursively finds and layouts all connectors in the tree
fn layout_connectors_recursive(session: &mut DiagramBuilder, node: &DiagramTreeNode) {
    // If this node is a connector, layout it
    if node.entity_type == EntityType::ConnectorShape {
        println!("  📌 Laying out connector: {}", node.entity_id);
        let connector = session.get_connector(node.entity_id.clone()).clone();
        layout_connector(session, &connector);
    }

    // Recursively process all children
    for child in &node.children {
        layout_connectors_recursive(session, child);
    }
}

//import textoptions defined in src/components/mod.rs
use crate::components::{BoxOptions, TextOptions};
//Test that a box with a text inside is correctly laid out
#[test]
fn test_layout_box_with_text() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //print box options
    println!("--box options: {:?}", box_options);

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_local_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_local_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());
    //assert equal positions

    // assert the box size is greater than the text size
    println!("box size: {:?}", box_size);
    println!("text size: {:?}", text_size);
    // and the text size should not be zero
    assert!(text_size.0 > 0.0);
    assert_eq!(box_size.0, 30.0);
    assert!(box_size.1 > text_size.1);
}

#[test]
fn test_box_fixed_size() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        width_behavior: SizeBehavior::Fixed(100.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_local_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_local_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());

    //assert equal positions
    // Assert that the text is centered within the box
    assert_eq!(
        text_position.0,
        box_options.padding
            + (box_options.width_behavior.unwrap_fixed().unwrap()
                - box_options.padding * 2.0
                - text_size.0)
                / 2.0
    );
    assert_eq!(
        text_position.1,
        box_options.padding
            + (box_options.height_behavior.unwrap_fixed().unwrap()
                - box_options.padding * 2.0
                - text_size.1)
                / 2.0
    );
    assert_eq!(box_position, (0.0, 0.0));

    // assert the box size is equal to the fixed size
    assert_eq!(box_size.0, 100.0);
    assert_eq!(box_size.1, 50.0);
}

===/src/constraints/mod.rs===
use crate::components::*;
use anyhow::{bail, Context, Result};
use cassowary::strength::{MEDIUM, REQUIRED, STRONG, WEAK};
use cassowary::{AddEditVariableError, Constraint, Solver, Variable, WeightedRelation::*};
use std::collections::HashMap;
#[derive(Debug, Clone)]
pub enum SimpleConstraint {
    // ===== BASIC ALIGNMENT CONSTRAINTS (Updated to support lists) =====
    /// Align the left edges of entities. First entity is the reference, others align to it.
    AlignLeft(Vec<EntityID>),
    /// Align the right edges of entities. First entity is the reference, others align to it.
    AlignRight(Vec<EntityID>),
    /// Align the top edges of entities. First entity is the reference, others align to it.
    AlignTop(Vec<EntityID>),
    /// Align the bottom edges of entities. First entity is the reference, others align to it.
    AlignBottom(Vec<EntityID>),
    /// Align the horizontal centers of entities. First entity is the reference, others align to it.
    AlignCenterHorizontal(Vec<EntityID>),
    /// Align the vertical centers of entities. First entity is the reference, others align to it.
    AlignCenterVertical(Vec<EntityID>),

    // ===== DIRECTIONAL POSITIONING CONSTRAINTS (Keep as pairs for now) =====
    /// First entity is to the right of the second entity
    RightOf(EntityID, EntityID),
    /// First entity is to the left of the second entity
    LeftOf(EntityID, EntityID),
    /// First entity is above the second entity
    Above(EntityID, EntityID),
    /// First entity is below the second entity
    Below(EntityID, EntityID),

    // ===== SPACING CONSTRAINTS =====
    /// Horizontal spacing between two entities
    HorizontalSpacing(EntityID, EntityID, Float),
    /// Vertical spacing between two entities
    VerticalSpacing(EntityID, EntityID, Float),
    /// Fixed distance between centers of two entities
    FixedDistance(EntityID, EntityID, Float),

    // ===== SIZE CONSTRAINTS =====
    /// All entities should have the same width. First is reference.
    SameWidth(Vec<EntityID>),
    /// All entities should have the same height. First is reference.
    SameHeight(Vec<EntityID>),
    /// All entities should have at least the same height (or more) than first.
    AtLeastSameHeight(Vec<EntityID>),
    MinHeight(EntityID, Float),
    /// All entities should have the same size. First is reference.
    SameSize(Vec<EntityID>),

    ProportionalWidth(EntityID, EntityID, Float),
    /// First entity's height is proportional to second entity's height by the given ratio
    ProportionalHeight(EntityID, EntityID, Float),
    /// Maintain a specific aspect ratio (width/height) for an entity
    AspectRatio(EntityID, Float),

    /// Fix an entity's width to a specific value
    FixedWidth(EntityID, Float),
    /// Fix an entity's height to a specific value
    FixedHeight(EntityID, Float),
    /// Fix an entity's size to specific values
    FixedSize(EntityID, Float, Float),
    /// Fix an entity's position to specific coordinates
    FixedPosition(EntityID, Float, Float),
    FixedX(EntityID, Float),

    // ===== STACK CONSTRAINTS =====
    /// Arrange entities in a horizontal line with optional spacing
    StackHorizontal(Vec<EntityID>, Option<Float>), // spacing between elements
    /// Arrange entities in a vertical line with optional spacing
    StackVertical(Vec<EntityID>, Option<Float>), // spacing between elements
}

pub struct ConstraintSystem {
    solver: Solver,
    variables: HashMap<String, EntityVars>,
}

struct EntityVars {
    x: Variable,
    y: Variable,
    width: Variable,
    height: Variable,
}

impl ConstraintSystem {
    pub fn new() -> Self {
        Self {
            solver: Solver::new(),
            variables: HashMap::new(),
        }
    }

    pub fn add_entity(&mut self, id: String) -> anyhow::Result<()> {
        let vars = EntityVars {
            x: Variable::new(),
            y: Variable::new(),
            width: Variable::new(),
            height: Variable::new(),
        };

        // Ensure positive sizes
        self.solver
            .add_constraint(vars.width | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add width constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.height | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add height constraint: {:?}", e))?;

        // Mark editable variables
        self.solver
            .add_constraint(vars.width | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add width >= 0 constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.height | GE(REQUIRED) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add height >= 0 constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.x | EQ(WEAK) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add default x constraint: {:?}", e))?;
        self.solver
            .add_constraint(vars.y | EQ(WEAK) | 0.0)
            .map_err(|e| anyhow::anyhow!("Failed to add default y constraint: {:?}", e))?;

        self.variables.insert(id, vars);
        Ok(())
    }

    pub fn add_constraint(&mut self, constraint: SimpleConstraint) -> Result<()> {
        match constraint {
            SimpleConstraint::FixedX(entity, x) => {
                let vars = self.variables.get(&entity);
                if vars.is_none() {
                    bail!("entity not registered in constraint system {}", entity);
                }

                let vars = vars.unwrap();
                self.solver
                    .add_constraint(vars.x | EQ(REQUIRED) | x)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed position x constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::FixedPosition(entity, x, y) => {
                let vars = self.variables.get(&entity);
                if vars.is_none() {
                    bail!("entity not registered in constraint system {}", entity);
                }

                let vars = vars.unwrap();
                self.solver
                    .add_constraint(vars.x | EQ(REQUIRED) | x)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed position x constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(vars.y | EQ(REQUIRED) | y)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed position y constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::AlignLeft(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("AlignLeft requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self.variables.get(reference);

                if ref_vars.is_none() {
                    bail!("entity not registered in constraint system {}", reference);
                }

                let ref_vars = ref_vars.unwrap();

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity);
                    if vars.is_none() {
                        bail!("entity not registered in constraint system {}", entity);
                    }
                    let vars = vars.unwrap();
                    self.solver
                        .add_constraint(vars.x | EQ(REQUIRED) | ref_vars.x)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add align left constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::AlignRight(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("AlignRight requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self.variables.get(reference).context(format!(
                    "entity not registered in constrain system {}",
                    reference
                ))?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(
                            (vars.x + vars.width) | EQ(REQUIRED) | (ref_vars.x + ref_vars.width),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add align right constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::AlignTop(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("AlignTop requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(vars.y | EQ(REQUIRED) | ref_vars.y)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add align top constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::AlignBottom(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("AlignBottom requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(
                            (vars.y + vars.height) | EQ(REQUIRED) | (ref_vars.y + ref_vars.height),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add align bottom constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::AlignCenterHorizontal(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!(
                        "AlignCenterHorizontal requires at least 2 entities"
                    ));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(
                            (vars.x + vars.width * 0.5)
                                | EQ(REQUIRED)
                                | (ref_vars.x + ref_vars.width * 0.5),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!(
                                "Failed to add align center horizontal constraint: {:?}",
                                e
                            )
                        })?;
                }
            }

            SimpleConstraint::AlignCenterVertical(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!(
                        "AlignCenterVertical requires at least 2 entities"
                    ));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("Entity not found")?;
                    self.solver
                        .add_constraint(
                            (vars.y + vars.height * 0.5)
                                | EQ(REQUIRED)
                                | (ref_vars.y + ref_vars.height * 0.5),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!(
                                "Failed to add align center vertical constraint: {:?}",
                                e
                            )
                        })?;
                }
            }

            SimpleConstraint::RightOf(id1, id2) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                self.solver
                    .add_constraint(vars1.x | GE(REQUIRED) | vars2.x + vars2.width)
                    .map_err(|e| anyhow::anyhow!("Failed to add rightOf constraint: {:?}", e))?;
            }

            SimpleConstraint::LeftOf(id1, id2) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                self.solver
                    .add_constraint(vars1.x | LE(REQUIRED) | vars2.x - vars1.width)
                    .map_err(|e| anyhow::anyhow!("Failed to add leftOf constraint: {:?}", e))?;
            }

            SimpleConstraint::Below(id1, id2) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                self.solver
                    .add_constraint(vars1.y | GE(REQUIRED) | vars2.y + vars2.height)
                    .map_err(|e| anyhow::anyhow!("Failed to add bottomOf constraint: {:?}", e))?;
            }
            SimpleConstraint::Above(id1, id2) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                // id1 está arriba de id2: id1.y + id1.height = id2.y
                self.solver
                    .add_constraint((vars1.y + vars1.height) | LE(REQUIRED) | vars2.y)
                    .map_err(|e| anyhow::anyhow!("Failed to add above constraint: {:?}", e))?;
            }
            SimpleConstraint::HorizontalSpacing(id1, id2, spacing) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                // Horizontal spacing: gap between right edge of first and left edge of second
                // x2 = x1 + width1 + spacing
                self.solver
                    .add_constraint(vars2.x | EQ(REQUIRED) | (vars1.x + vars1.width + spacing))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add horizontal spacing constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::VerticalSpacing(id1, id2, spacing) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                // Vertical spacing: gap between bottom edge of first and top edge of second
                // y2 = y1 + height1 + spacing
                self.solver
                    .add_constraint(vars2.y | EQ(REQUIRED) | (vars1.y + vars1.height + spacing))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add vertical spacing constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::FixedWidth(entity, width) => {
                let vars = self.variables.get(&entity).context("entity not found")?;
                self.solver
                    .add_constraint(vars.width | EQ(REQUIRED) | width)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed width constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::FixedHeight(entity, height) => {
                let vars = self.variables.get(&entity).context("entity not found")?;
                self.solver
                    .add_constraint(vars.height | EQ(REQUIRED) | height)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed height constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::FixedSize(entity, width, height) => {
                let vars = self.variables.get(&entity).context("entity not found")?;
                self.solver
                    .add_constraint(vars.width | EQ(REQUIRED) | width)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed size width constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(vars.height | EQ(REQUIRED) | height)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add fixed size height constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::FixedDistance(id1, id2, distance) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;

                // Fixed distance between centers of two entities
                // Distance = sqrt((cx2 - cx1)² + (cy2 - cy1)²)
                // Since Cassowary is a linear solver, we can't directly implement sqrt.
                // We'll use the Manhattan distance as an approximation, or implement
                // a more sophisticated approach using auxiliary variables.

                // For now, let's implement using Manhattan distance (|dx| + |dy| = distance)
                // This is a reasonable approximation for many layout purposes.

                // Create auxiliary variables for the center positions
                let center1_x = Variable::new();
                let center1_y = Variable::new();
                let center2_x = Variable::new();
                let center2_y = Variable::new();

                // Define centers
                self.solver
                    .add_constraint(center1_x | EQ(REQUIRED) | (vars1.x + vars1.width * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center1_x constraint: {:?}", e))?;
                self.solver
                    .add_constraint(center1_y | EQ(REQUIRED) | (vars1.y + vars1.height * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center1_y constraint: {:?}", e))?;
                self.solver
                    .add_constraint(center2_x | EQ(REQUIRED) | (vars2.x + vars2.width * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center2_x constraint: {:?}", e))?;
                self.solver
                    .add_constraint(center2_y | EQ(REQUIRED) | (vars2.y + vars2.height * 0.5))
                    .map_err(|e| anyhow::anyhow!("Failed to add center2_y constraint: {:?}", e))?;

                // For Manhattan distance approximation:
                // We'll enforce that the total horizontal and vertical distance equals the target distance
                // This works well for cases where entities are primarily aligned horizontally or vertically

                // Create auxiliary variables for absolute differences
                let dx_pos = Variable::new(); // max(center2_x - center1_x, 0)
                let dx_neg = Variable::new(); // max(center1_x - center2_x, 0)
                let dy_pos = Variable::new(); // max(center2_y - center1_y, 0)
                let dy_neg = Variable::new(); // max(center1_y - center2_y, 0)

                // Ensure non-negative auxiliary variables
                self.solver
                    .add_constraint(dx_pos | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dx_pos >= 0 constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(dx_neg | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dx_neg >= 0 constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(dy_pos | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dy_pos >= 0 constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint(dy_neg | GE(REQUIRED) | 0.0)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dy_neg >= 0 constraint: {:?}", e)
                    })?;

                // Define the absolute differences
                self.solver
                    .add_constraint((center2_x - center1_x) | EQ(REQUIRED) | (dx_pos - dx_neg))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dx difference constraint: {:?}", e)
                    })?;
                self.solver
                    .add_constraint((center2_y - center1_y) | EQ(REQUIRED) | (dy_pos - dy_neg))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add dy difference constraint: {:?}", e)
                    })?;

                // Manhattan distance constraint: |dx| + |dy| = distance
                self.solver
                    .add_constraint((dx_pos + dx_neg + dy_pos + dy_neg) | EQ(REQUIRED) | distance)
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add manhattan distance constraint: {:?}", e)
                    })?;
            }
            SimpleConstraint::SameWidth(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("SameWidth requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(vars.width | EQ(REQUIRED) | ref_vars.width)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add same width constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::SameHeight(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("SameHeight requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(vars.height | EQ(REQUIRED) | ref_vars.height)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add same height constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::AtLeastSameHeight(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("SameHeight requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;

                    self.solver
                        .add_constraint(ref_vars.height | GE(REQUIRED) | vars.height)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add same height constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::MinHeight(id, h) => {
                let vars = self.variables.get(&id).context("entity not found")?;
                self.solver
                    .add_constraint(vars.height | GE(REQUIRED) | h)
                    .map_err(|e| anyhow::anyhow!("Failed to add min height constraint: {:?}", e))?;
            }

            SimpleConstraint::SameSize(entities) => {
                if entities.len() < 2 {
                    return Err(anyhow::anyhow!("SameSize requires at least 2 entities"));
                }
                let reference = &entities[0];
                let ref_vars = self
                    .variables
                    .get(reference)
                    .context("Reference entity not found")?;

                for entity in entities.iter().skip(1) {
                    let vars = self.variables.get(entity).context("entity not found")?;
                    self.solver
                        .add_constraint(vars.width | EQ(REQUIRED) | ref_vars.width)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add same size width constraint: {:?}", e)
                        })?;
                    self.solver
                        .add_constraint(vars.height | EQ(REQUIRED) | ref_vars.height)
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add same size height constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::ProportionalWidth(id1, id2, ratio) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                // First entity's width = second entity's width * ratio
                // width1 = width2 * ratio
                self.solver
                    .add_constraint(vars1.width | EQ(REQUIRED) | (vars2.width * ratio))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add proportional width constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::ProportionalHeight(id1, id2, ratio) => {
                let vars1 = self.variables.get(&id1).context("entity not found")?;
                let vars2 = self.variables.get(&id2).context("entity not found")?;
                // First entity's height = second entity's height * ratio
                // height1 = height2 * ratio
                self.solver
                    .add_constraint(vars1.height | EQ(REQUIRED) | (vars2.height * ratio))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add proportional height constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::AspectRatio(id, ratio) => {
                let vars = self.variables.get(&id).context("entity not found")?;
                // Maintain aspect ratio: width / height = ratio
                // Rearranged: width = height * ratio
                self.solver
                    .add_constraint(vars.width | EQ(REQUIRED) | (vars.height * ratio))
                    .map_err(|e| {
                        anyhow::anyhow!("Failed to add aspect ratio constraint: {:?}", e)
                    })?;
            }

            SimpleConstraint::StackHorizontal(entities, spacing) => {
                let spacing = spacing.unwrap_or(0.0);
                if entities.is_empty() {
                    return Err(anyhow::anyhow!(
                        "StackHorizontal requires at least 1 entity"
                    ));
                }

                // Stack entities horizontally with fixed spacing between them
                // entity[i+1].x = entity[i].x + entity[i].width + spacing
                for i in 1..entities.len() {
                    let prev_vars = self
                        .variables
                        .get(&entities[i - 1])
                        .context("Previous entity not found")?;
                    let curr_vars = self
                        .variables
                        .get(&entities[i])
                        .context("Current entity not found")?;

                    // Current entity starts where previous entity ends plus spacing
                    self.solver
                        .add_constraint(
                            curr_vars.x | EQ(REQUIRED) | (prev_vars.x + prev_vars.width + spacing),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add horizontal stack constraint: {:?}", e)
                        })?;
                }
            }

            SimpleConstraint::StackVertical(entities, spacing) => {
                let spacing = spacing.unwrap_or(0.0);
                if entities.is_empty() {
                    return Err(anyhow::anyhow!("StackVertical requires at least 1 entity"));
                }

                // Stack entities vertically with fixed spacing between them
                // entity[i+1].y = entity[i].y + entity[i].height + spacing
                for i in 1..entities.len() {
                    let prev_vars = self
                        .variables
                        .get(&entities[i - 1])
                        .context("Previous entity not found")?;
                    let curr_vars = self
                        .variables
                        .get(&entities[i])
                        .context("Current entity not found")?;

                    // Current entity starts where previous entity ends plus spacing
                    self.solver
                        .add_constraint(
                            curr_vars.y | EQ(REQUIRED) | (prev_vars.y + prev_vars.height + spacing),
                        )
                        .map_err(|e| {
                            anyhow::anyhow!("Failed to add vertical stack constraint: {:?}", e)
                        })?;
                }
            }
        }
        Ok(())
    }

    pub fn solve(&mut self) -> Result<HashMap<String, (f32, f32, f32, f32)>> {
        self.solver.fetch_changes();
        let mut results = HashMap::new();
        for (id, vars) in &self.variables {
            let x = self.solver.get_value(vars.x) as f32;
            let y = self.solver.get_value(vars.y) as f32;
            let width = self.solver.get_value(vars.width) as f32;
            let height = self.solver.get_value(vars.height) as f32;
            results.insert(id.clone(), (x, y, width, height));
        }
        Ok(results)
    }

    pub fn suggest_size(
        &mut self,
        id: &str,
        width: f32,
        height: f32,
        is_fixed_size: bool,
    ) -> Result<(), cassowary::SuggestValueError> {
        println!("Suggest_size called {} {} {}", id, width, height);

        // Solo permitir al solver cambiar width o height cuando tiene sentido (ej un rectangulo)
        // Un vstack no debe tener su width o height modificado
        let c_strength = if is_fixed_size { REQUIRED} else { STRONG };
        if let Some(vars) = self.variables.get(id) {
            let _ = self
                .solver
                .add_constraint(vars.width | EQ(c_strength) | (width as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested width constraint: {:?}", e));
            let _ = self
                .solver
                .add_constraint(vars.height | EQ(c_strength) | (height as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested height constraint: {:?}", e));
        }

        Ok(())
    }

    pub fn suggest_position(
        &mut self,
        id: &str,
        x: f32,
        y: f32,
    ) -> Result<(), cassowary::SuggestValueError> {
        if let Some(vars) = self.variables.get(id) {
            let _ = self
                .solver
                .add_constraint(vars.x | EQ(MEDIUM) | (x as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested x constraint: {:?}", e));
            let _ = self
                .solver
                .add_constraint(vars.y | EQ(MEDIUM) | (y as f64))
                .map_err(|e| anyhow::anyhow!("Failed to add suggested y constraint: {:?}", e));
        }
        Ok(())
    }
}

===/src/lib.rs===

pub use crate::diagram_builder::{DiagramBuilder};
pub use crate::components::*;
pub use crate::constraints::*;
pub use crate::layout::*;
pub use crate::utils::*;
pub use crate::renderer_base::*;
pub use crate::theme::*;

pub mod diagram_builder;
pub mod utils;
pub mod components;
pub mod constraints;
pub mod layout;
pub mod renderer_base;
pub mod parser;
pub mod transform;
pub mod theme;

/// Generates a complete LLM prompt for converting natural language to JSONL operations
/// 
/// # Arguments
/// * `user_input` - The natural language request from the user
/// * `current_jsonl` - The current JSONL document (empty string for new documents)
/// 
/// # Returns
/// A formatted string containing the complete prompt ready to send to an LLM
/// 
/// # Example
/// ```
/// let user_request = "Create a document with a title and paragraph";
/// let current_doc = ""; // empty for new document
/// let prompt = generate_jsonl_prompt(user_request, current_doc);
/// // Send prompt to LLM...
/// ```
pub fn generate_transformations_jsonl_prompt(user_input: &str, current_jsonl: &str) -> String {
    // Embed the documentation files at compile time
    const LLM_TRANSFORM_OPS_SPEC: &str = include_str!("../docs/LLM Transform Operations SPEC.md");
    const COMPONENTS_DOC: &str = include_str!("../docs/JSONL Document components.md");
    const DIAGRAM_SPEC: &str = include_str!("../docs/JSONL Diagram Specification.md");
    
    // Combine the specifications
    let complete_spec = format!(
        "{}\n\n## Document Components\n\n{}\n\n## Diagram Elements\n\n{}",
        COMPONENTS_DOC,
        DIAGRAM_SPEC,
        LLM_TRANSFORM_OPS_SPEC,
    );
    
    // Build the complete prompt by injecting the spec and user inputs
    let prompt = format!(
r#"{}

## Current Task

**User Request:**
{}

**Current Document:**
{}

Please generate the JSONL operations to fulfill this request. Output ONLY the JSONL operations, one per line, with no additional formatting or explanation.
"#,
        complete_spec,
        user_input,
        if current_jsonl.trim().is_empty() {
            "(empty)"
        } else {
            current_jsonl
        }
    );
    
    prompt
}

#[cfg(test)]
mod tests;



===/src/theme.rs===
pub struct Theme {
    
}
===/src/tests/rotation_tests.rs===
#[cfg(test)]
mod simple_rotation_test {
    use crate::transform::Transform;
    use crate::{Fill, RectOptions, SizeBehavior};
    use crate::{DiagramBuilder, layout::layout_tree_node};

    #[test]
    fn test_90_degree_rotation_bounding_box() {
        println!("🧪 Testing 90° rotation bounding box...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create a 100x50 rectangle (wide rectangle)
        let rect_opts = RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(50.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "darkblue".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        };
        
        let rect = builder.new_rectangle("test_rect".to_string(), rect_opts);
        
        // Apply 90° rotation
        let rotation_transform = Transform::rotation(90.0);
        builder.set_transform("test_rect".to_string(), rotation_transform);
        
        // Layout the rectangle
        layout_tree_node(&mut builder, &rect);
        
        // Get the effective bounds
        let bounds = builder.get_effective_bounds("test_rect".to_string());
        
        println!("📏 Original size: 100x50 (wide rectangle)");
        println!("📐 Rotation: 90°");
        println!("📦 Effective bounds: w={:.1}, h={:.1}", bounds.width, bounds.height);
        
        // After 90° rotation: width and height should swap
        // Original: 100 wide, 50 tall → Rotated: 50 wide, 100 tall
        assert_eq!(bounds.width as i32, 50, "90° rotated width should be 50, got {:.1}", bounds.width);
        assert_eq!(bounds.height as i32, 100, "90° rotated height should be 100, got {:.1}", bounds.height);
        
        println!("✅ 90° rotation test passed! Dimensions swapped correctly.");
    }
}


#[cfg(test)]
mod debug_rotation_positioning {
    use super::*;
    use crate::transform::Transform;
    use crate::{Fill, HorizontalAlignment, RectOptions, SizeBehavior, VerticalAlignment};
    use crate::{DiagramBuilder, layout::layout_tree_node};

    #[test]
    fn test_debug_rotation_positioning() {
        println!("🧪 Debugging rotation positioning...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create the same setup as your JSONL test
        let normal_rect = builder.new_rectangle("normal_rect".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("red".to_string()),
            stroke_color: "darkred".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        let rotated_rect = builder.new_rectangle("rotated_rect".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "darkblue".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        let normal_rect2 = builder.new_rectangle("normal_rect2".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("green".to_string()),
            stroke_color: "darkgreen".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        // Apply rotation to middle rectangle
        let rotation_transform = Transform::rotation(45.0);
        builder.set_transform("rotated_rect".to_string(), rotation_transform);
        
        println!("🔍 BEFORE LAYOUT:");
        println!("  Normal rect bounds: {:?}", builder.get_effective_bounds("normal_rect".to_string()));
        println!("  Rotated rect bounds: {:?}", builder.get_effective_bounds("rotated_rect".to_string()));
        println!("  Normal rect2 bounds: {:?}", builder.get_effective_bounds("normal_rect2".to_string()));
        
        // Create horizontal stack
        let hstack = builder.new_hstack("root".to_string(), 
                                       vec![normal_rect, rotated_rect, normal_rect2], 
                                       VerticalAlignment::Center);
        
        // Layout the stack
        layout_tree_node(&mut builder, &hstack);
        
        println!("🔍 AFTER LAYOUT:");
        println!("  Normal rect position: {:?}", builder.get_local_position("normal_rect".to_string()));
        println!("  Normal rect bounds: {:?}", builder.get_effective_bounds("normal_rect".to_string()));
        
        println!("  Rotated rect position: {:?}", builder.get_local_position("rotated_rect".to_string()));
        println!("  Rotated rect bounds: {:?}", builder.get_effective_bounds("rotated_rect".to_string()));
        println!("  Rotated rect transform: {:?}", builder.get_transform("rotated_rect".to_string()));
        
        println!("  Normal rect2 position: {:?}", builder.get_local_position("normal_rect2".to_string()));
        println!("  Normal rect2 bounds: {:?}", builder.get_effective_bounds("normal_rect2".to_string()));
        
        println!("  Stack total size: {:?}", builder.get_size("root".to_string()));
        
        // Check if there's overlap
        let rect1_bounds = builder.get_effective_bounds("normal_rect".to_string());
        let rect2_bounds = builder.get_effective_bounds("rotated_rect".to_string());
        let rect3_bounds = builder.get_effective_bounds("normal_rect2".to_string());
        
        println!("🔍 OVERLAP CHECK:");
        println!("  Rect1 occupies: x={:.1} to x={:.1}", rect1_bounds.x, rect1_bounds.x + rect1_bounds.width);
        println!("  Rect2 occupies: x={:.1} to x={:.1}", rect2_bounds.x, rect2_bounds.x + rect2_bounds.width);
        println!("  Rect3 occupies: x={:.1} to x={:.1}", rect3_bounds.x, rect3_bounds.x + rect3_bounds.width);
        
        // Check for actual overlap
        let rect1_end = rect1_bounds.x + rect1_bounds.width;
        let rect2_start = rect2_bounds.x;
        let rect2_end = rect2_bounds.x + rect2_bounds.width;
        let rect3_start = rect3_bounds.x;
        
        if rect2_start < rect1_end {
            println!("❌ OVERLAP DETECTED: Rect2 starts at {:.1} but Rect1 ends at {:.1}", rect2_start, rect1_end);
        } else {
            println!("✅ No overlap between Rect1 and Rect2");
        }
        
        if rect3_start < rect2_end {
            println!("❌ OVERLAP DETECTED: Rect3 starts at {:.1} but Rect2 ends at {:.1}", rect3_start, rect2_end);
        } else {
            println!("✅ No overlap between Rect2 and Rect3");
        }
    }
}
===/src/tests/mod.rs===
pub mod rotation_tests;
===/src/components/mod.rs===
pub mod table;

use crate::constraints::{ConstraintSystem, SimpleConstraint};
use crate::parser::JsonLinesParser;
use core::fmt;
use std::{any::Any, collections::HashMap, sync::Arc};

use anyhow::{bail, Result};
use serde_json::{Map, Value};

pub use crate::components::table::*;
//new type EntityID that is a u64
pub type EntityID = String;
pub type Float = f32;

//Export table and table options

pub trait Entity {
    fn get_id(&self) -> EntityID;
    fn get_type(&self) -> EntityType;
    //as_any
    fn as_any(&self) -> &dyn Any;
}

pub struct Point {
    pub x: Float,
    pub y: Float,
}

//impl clone
impl Clone for Point {
    fn clone(&self) -> Self {
        Point {
            x: self.x,
            y: self.y,
        }
    }
}

//impl new
impl Point {
    pub fn new(x: Float, y: Float) -> Self {
        Point { x, y }
    }
}

pub struct Size {
    pub w: Float,
    pub h: Float,
}

//impl clone
impl Clone for Size {
    fn clone(&self) -> Self {
        Size {
            w: self.w,
            h: self.h,
        }
    }
}

//impl new
impl Size {
    pub fn new(w: Float, h: Float) -> Self {
        Size { w, h }
    }
}

//Note: add new items to the end of the enum to avoid breaking the serialization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EntityType {
    PointShape,
    BoxShape,
    RectShape,
    TextShape,
    LineShape,
    ConnectorShape,
    ArrowShape,
    EllipseShape,
    ImageShape,
    GroupShape,
    VerticalStackShape,
    HorizontalStackShape,
    TableShape,
    TextLine,
    PolyLine,
    FreeContainer,
    ArcShape,
    SpacerShape,
    ConstraintLayoutContainer,
}

#[derive(Debug, Copy, PartialEq)]
pub enum SizeBehavior {
    /// Fixed size - element has a predetermined size that doesn't change
    Fixed(Float),
    /// Content size - element sizes itself based on its content (current default behavior)
    Content,
    /// Grow size - element takes all available space from its parent
    Grow,
}

impl Default for SizeBehavior {
    fn default() -> Self {
        SizeBehavior::Content
    }
}

impl Eq for SizeBehavior {}

impl Clone for SizeBehavior {
    fn clone(&self) -> Self {
        match self {
            SizeBehavior::Fixed(v) => SizeBehavior::Fixed(*v),
            SizeBehavior::Content => SizeBehavior::Content,
            SizeBehavior::Grow => SizeBehavior::Grow,
        }
    }
}

impl SizeBehavior {
    pub fn unwrap_fixed(&self) -> Result<f32, &'static str> {
        match self {
            SizeBehavior::Fixed(val) => Ok(*val),
            _ => Err("Called unwrap_fixed on non-Fixed SizeBehavior"),
        }
    }
}

// Connectors
#[derive(Clone, Debug)]
pub enum ConnectorType {
    Straight,
    Curved,
    Orthogonal,
}

#[derive(Clone)]
pub struct ShapeConnector {
    pub entity: EntityID,
    pub source_id: EntityID,
    pub target_id: EntityID,
    pub start_point_id: EntityID,
    pub end_point_id: EntityID,
    pub label : Option<String>,
    pub options: ConnectorOptions,
}

#[derive(Debug, Clone)]
pub enum Port {
    Center,
    Top,
    Bottom,
    Left,
    Right,
    TopLeft,
    TopRight,
    BottomLeft,
    BottomRight,
}

impl Default for Port {
    fn default() -> Self {
        Port::Center
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum OrthogonalRoutingStrategy {
    // 2-segment strategies (one turn, 3 points)
    HV, // Horizontal then Vertical (Start → Horizontal → Vertical → End)
    VH, // Vertical then Horizontal (Start → Vertical → Horizontal → End)

    // 3-segment strategies (two turns, 4 points, with midpoint)
    HVH, // Horizontal-Vertical-Horizontal (Start → H → V → H → End)
    VHV, // Vertical-Horizontal-Vertical (Start → V → H → V → End)

    // Smart strategy
    Auto, // Choose best based on direction
}

#[derive(Clone, Debug)]
pub struct ConnectorOptions {
    pub connector_type: ConnectorType,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub curve_offset: Option<Float>,
    pub source_port: Port,
    pub target_port: Port,
    pub arrow_start: bool,
    pub arrow_end: bool,
    pub arrow_size: Float,
    pub routing_strategy: OrthogonalRoutingStrategy,
}

impl Default for ConnectorOptions {
    fn default() -> Self {
        Self {
            connector_type: ConnectorType::Straight,
            stroke_color: "black".to_string(),
            stroke_width: 1.0,
            curve_offset: None,
            source_port: Port::Center,
            target_port: Port::Center,
            arrow_start: false,
            arrow_end: false,
            arrow_size: 10.0,
            routing_strategy: OrthogonalRoutingStrategy::HVH,
        }
    }
}

// Add spacer component
pub struct ShapeSpacer {
    pub entity: EntityID,
    pub spacer_options: SpacerOptions,
}

impl ShapeSpacer {
    pub fn new(entity: EntityID, spacer_options: SpacerOptions) -> ShapeSpacer {
        ShapeSpacer {
            entity,
            spacer_options,
        }
    }
}

impl Clone for ShapeSpacer {
    fn clone(&self) -> Self {
        ShapeSpacer {
            entity: self.entity.clone(),
            spacer_options: self.spacer_options.clone(),
        }
    }
}

#[derive(Default, Debug)]
pub struct SpacerOptions {
    pub width: Float,
    pub height: Float,
    pub direction: SpacerDirection, // Horizontal, Vertical, or Both
}

impl Clone for SpacerOptions {
    fn clone(&self) -> Self {
        SpacerOptions {
            width: self.width,
            height: self.height,
            direction: self.direction.clone(),
        }
    }
}

#[derive(Debug)]
pub enum SpacerDirection {
    Horizontal, // Takes up width, minimal height
    Vertical,   // Takes up height, minimal width
    Both,       // Takes up both dimensions
}

impl Default for SpacerDirection {
    fn default() -> Self {
        SpacerDirection::Vertical
    }
}

impl Clone for SpacerDirection {
    fn clone(&self) -> Self {
        match self {
            SpacerDirection::Horizontal => SpacerDirection::Horizontal,
            SpacerDirection::Vertical => SpacerDirection::Vertical,
            SpacerDirection::Both => SpacerDirection::Both,
        }
    }
}

// Point doesn't have any attributes, position is handled with transformations as the rest
// This struct is useful for having points anchored to other elements positions
#[derive(Debug, Clone)]
pub struct PointShape {
    pub entity: EntityID,
}

/**
 * Boxes show a rectangle around the wrapped entity
 */
#[derive(Debug)]
pub struct ShapeBox {
    pub entity: EntityID,
    //Each box wraps another entity
    pub wrapped_entity: EntityID,
    pub box_options: BoxOptions,
}

impl Clone for ShapeBox {
    fn clone(&self) -> Self {
        ShapeBox {
            entity: self.entity.clone(),
            wrapped_entity: self.wrapped_entity.clone(),
            box_options: self.box_options.clone(),
        }
    }
}

impl Entity for ShapeBox {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::BoxShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeBox {
    pub fn new(entity: EntityID, wrapped_entity: EntityID, box_options: BoxOptions) -> ShapeBox {
        ShapeBox {
            entity,
            wrapped_entity,
            box_options,
        }
    }
}

#[derive(Debug)]
pub enum GradientStop {
    ColorStop { offset: Float, color: String },
    OpacityStop { offset: Float, opacity: Float },
}

#[derive(Debug)]
pub struct LinearGradient {
    pub x1: Float,
    pub y1: Float,
    pub x2: Float,
    pub y2: Float,
    pub stops: Vec<GradientStop>,
}

impl LinearGradient {
    pub fn new(x1: Float, y1: Float, x2: Float, y2: Float, stops: Vec<GradientStop>) -> Self {
        LinearGradient {
            x1,
            y1,
            x2,
            y2,
            stops,
        }
    }
}

impl Clone for GradientStop {
    fn clone(&self) -> Self {
        match self {
            GradientStop::ColorStop { offset, color } => GradientStop::ColorStop {
                offset: *offset,
                color: color.clone(),
            },
            GradientStop::OpacityStop { offset, opacity } => GradientStop::OpacityStop {
                offset: *offset,
                opacity: *opacity,
            },
        }
    }
}

#[derive(Debug)]
pub struct RadialGradient {
    pub cx: Float,
    pub cy: Float,
    pub r: Float,
    pub stops: Vec<GradientStop>,
}

impl Clone for RadialGradient {
    fn clone(&self) -> Self {
        RadialGradient {
            cx: self.cx,
            cy: self.cy,
            r: self.r,
            stops: self.stops.clone(),
        }
    }
}

impl Clone for LinearGradient {
    fn clone(&self) -> Self {
        LinearGradient {
            x1: self.x1,
            y1: self.y1,
            x2: self.x2,
            y2: self.y2,
            stops: self.stops.clone(),
        }
    }
}

#[derive(Debug)]
pub enum Fill {
    Color(String),
    LinearGradient(LinearGradient),
    RadialGradient(RadialGradient),
}

impl Clone for Fill {
    fn clone(&self) -> Self {
        match self {
            Fill::Color(color) => Fill::Color(color.clone()),
            Fill::LinearGradient(gradient) => Fill::LinearGradient(gradient.clone()),
            Fill::RadialGradient(gradient) => Fill::RadialGradient(gradient.clone()),
        }
    }
}
//default trait for fill
impl Default for Fill {
    fn default() -> Self {
        Fill::Color(String::from("white"))
    }
}

//display for fill
impl fmt::Display for Fill {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Fill::Color(color) => write!(f, "{}", color),
            Fill::LinearGradient(gradient) => write!(f, "{:?}", gradient),
            Fill::RadialGradient(gradient) => write!(f, "{:?}", gradient),
        }
    }
}

impl PartialEq for Fill {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Fill::Color(a), Fill::Color(b)) => a == b,
            (Fill::LinearGradient(a), Fill::LinearGradient(b)) => a == b,
            (Fill::RadialGradient(a), Fill::RadialGradient(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for Fill {}

impl PartialEq for LinearGradient {
    fn eq(&self, other: &Self) -> bool {
        self.x1 == other.x1
            && self.y1 == other.y1
            && self.x2 == other.x2
            && self.y2 == other.y2
            && self.stops == other.stops
    }
}

impl Eq for LinearGradient {}

impl PartialEq for RadialGradient {
    fn eq(&self, other: &Self) -> bool {
        self.cx == other.cx && self.cy == other.cy && self.r == other.r && self.stops == other.stops
    }
}

impl Eq for RadialGradient {}

impl PartialEq for GradientStop {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                GradientStop::ColorStop {
                    offset: a_offset,
                    color: a_color,
                },
                GradientStop::ColorStop {
                    offset: b_offset,
                    color: b_color,
                },
            ) => a_offset == b_offset && a_color == b_color,
            (
                GradientStop::OpacityStop {
                    offset: a_offset,
                    opacity: a_opacity,
                },
                GradientStop::OpacityStop {
                    offset: b_offset,
                    opacity: b_opacity,
                },
            ) => a_offset == b_offset && a_opacity == b_opacity,
            _ => false,
        }
    }
}

impl Eq for GradientStop {}

#[derive(Debug)]
pub struct BoxOptions {
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub padding: Float,
    pub border_radius: Float,
    // Add size behavior fields
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
    pub horizontal_alignment: HorizontalAlignment,
}

impl Clone for BoxOptions {
    fn clone(&self) -> Self {
        BoxOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            padding: self.padding,
            border_radius: self.border_radius,
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
            horizontal_alignment: self.horizontal_alignment.clone(),
        }
    }
}

impl Default for BoxOptions {
    fn default() -> Self {
        BoxOptions::new()
    }
}

impl BoxOptions {
    pub fn new() -> BoxOptions {
        BoxOptions {
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            padding: 10.0,
            border_radius: 0.0,
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
            horizontal_alignment: HorizontalAlignment::Center,
        }
    }
}

/* A group of entities */

//RectOptions
#[derive(Default, Debug)]
pub struct RectOptions {
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub border_radius: Float,
}

impl Clone for RectOptions {
    fn clone(&self) -> Self {
        RectOptions {
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            border_radius: self.border_radius,
        }
    }
}

impl RectOptions {
    pub fn new() -> RectOptions {
        RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(100.0),
            // Default fill color is white
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            border_radius: 0.0,
        }
    }
}

pub struct ShapeRect {
    pub entity: EntityID,
    pub rect_options: RectOptions,
}

impl ShapeRect {
    pub fn new(entity: EntityID, rect_options: RectOptions) -> ShapeRect {
        ShapeRect {
            entity,
            rect_options,
        }
    }
}

impl Clone for ShapeRect {
    fn clone(&self) -> Self {
        ShapeRect {
            entity: self.entity.clone(),
            rect_options: self.rect_options.clone(),
        }
    }
}

impl Entity for ShapeRect {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::RectShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

/* A group of entities */
pub struct ShapeGroup {
    pub entity: EntityID,
    pub elements: Vec<EntityID>,
}

impl Clone for ShapeGroup {
    fn clone(&self) -> Self {
        ShapeGroup {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
        }
    }
}

impl Entity for ShapeGroup {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::GroupShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

// Represents a line after adding breaks
#[derive(Debug)]
pub struct TextLine {
    pub entity: EntityID,
    pub text: String,
}

impl Clone for TextLine {
    fn clone(&self) -> Self {
        TextLine {
            entity: self.entity.clone(),
            text: self.text.clone(),
        }
    }
}

impl Entity for TextLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
//add copy trait
#[derive(Debug)]
pub struct ShapeText {
    pub entity: EntityID,
    pub text: String,
    pub text_options: TextOptions,
    pub lines: Vec<EntityID>,
}

impl Clone for ShapeText {
    fn clone(&self) -> Self {
        ShapeText {
            entity: self.entity.clone(),
            text: self.text.clone(),
            text_options: self.text_options.clone(),
            lines: self.lines.clone(),
        }
    }
}

impl ShapeText {
    pub fn new(
        entity: EntityID,
        text: &str,
        text_options: TextOptions,
        lines: &[EntityID],
    ) -> ShapeText {
        ShapeText {
            entity,
            text: text.to_string(),
            text_options,
            lines: lines.to_vec(),
        }
    }
}

impl Entity for ShapeText {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

//struct with text options: font family, font size
#[derive(Debug)]
pub struct TextOptions {
    pub font_family: String,
    pub font_size: f32,
    pub text_color: String,
    // (number of max characters per line)used to know when to insert breaks
    pub line_width: usize,
    pub line_spacing: f32, // spacing between lines
    pub font_weight: u32,
}

impl Clone for TextOptions {
    fn clone(&self) -> Self {
        TextOptions {
            font_family: self.font_family.clone(),
            font_size: self.font_size,
            text_color: self.text_color.clone(),
            line_width: self.line_width,
            line_spacing: self.line_spacing,
            font_weight: self.font_weight,
        }
    }
}

impl Default for TextOptions {
    fn default() -> Self {
        TextOptions {
            font_family: "Arial".to_string(),
            font_size: 12.0,
            text_color: "black".to_string(),
            line_width: 200,
            line_spacing: 8.0,
            font_weight: 400,
        }
    }
}
impl TextOptions {
    pub fn new() -> TextOptions {
        TextOptions {
            font_family: String::from("Arial"),
            font_size: 12.0,
            text_color: String::from("black"),
            line_width: 20,
            line_spacing: 0.0,
            font_weight: 400,
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum HorizontalAlignment {
    Left,
    Center,
    Right,
}

impl Clone for HorizontalAlignment {
    fn clone(&self) -> Self {
        match self {
            HorizontalAlignment::Left => HorizontalAlignment::Left,
            HorizontalAlignment::Center => HorizontalAlignment::Center,
            HorizontalAlignment::Right => HorizontalAlignment::Right,
        }
    }
}

pub struct VerticalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub horizontal_alignment: HorizontalAlignment,
}

impl Clone for VerticalStack {
    fn clone(&self) -> Self {
        VerticalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            horizontal_alignment: self.horizontal_alignment.clone(),
        }
    }
}

impl Entity for VerticalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::VerticalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub enum VerticalAlignment {
    Top,
    Center,
    Bottom,
}

impl Clone for VerticalAlignment {
    fn clone(&self) -> Self {
        match self {
            VerticalAlignment::Top => VerticalAlignment::Top,
            VerticalAlignment::Center => VerticalAlignment::Center,
            VerticalAlignment::Bottom => VerticalAlignment::Bottom,
        }
    }
}
impl fmt::Display for VerticalAlignment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerticalAlignment::Top => write!(f, "Top"),
            VerticalAlignment::Center => write!(f, "Center"),
            VerticalAlignment::Bottom => write!(f, "Bottom"),
        }
    }
}
//enum for horizontal stack

pub struct HorizontalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub vertical_alignment: VerticalAlignment, // Optional vertical alignment (e.g., "top", "center", "bottom")
}

impl Clone for HorizontalStack {
    fn clone(&self) -> Self {
        HorizontalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            vertical_alignment: self.vertical_alignment.clone(),
        }
    }
}

impl Entity for HorizontalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::HorizontalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ShapeLine {
    pub entity: EntityID,
    pub start: LinePointReference,
    pub end: LinePointReference,
    pub line_options: LineOptions,
}

impl Clone for ShapeLine {
    fn clone(&self) -> Self {
        ShapeLine {
            entity: self.entity.clone(),
            start: self.start.clone(),
            end: self.end.clone(),
            line_options: self.line_options.clone(),
        }
    }
}

/// A line can set the x,y values directly or through a separate Point entity
/// Referencing through point entity is useful for using with constraint systems
#[derive(Debug, Clone)]
pub enum LinePointReference {
    Value(Float, Float),
    PointID(EntityID),
}
impl ShapeLine {
    pub fn new(
        line_id: EntityID,
        start: LinePointReference,
        end: LinePointReference,
        options: LineOptions,
    ) -> ShapeLine {
        ShapeLine {
            entity: line_id,
            start,
            end,
            line_options: options,
        }
    }
}

impl Entity for ShapeLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::LineShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct LineOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for LineOptions {
    fn clone(&self) -> Self {
        LineOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl LineOptions {
    pub fn new() -> LineOptions {
        LineOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

// TODO: Add LinePointReference  support.
pub struct PolyLine {
    pub entity: EntityID,
    pub points: Vec<(Float, Float)>,
    pub line_options: LineOptions,
}

impl PolyLine {
    pub fn new(
        entity: EntityID,
        points: Vec<(Float, Float)>,
        line_options: LineOptions,
    ) -> PolyLine {
        PolyLine {
            entity,
            points,
            line_options,
        }
    }
}

impl Entity for PolyLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::PolyLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl Clone for PolyLine {
    fn clone(&self) -> Self {
        PolyLine {
            entity: self.entity.clone(),
            points: self.points.clone(),
            line_options: self.line_options.clone(),
        }
    }
}

pub struct ShapeArrow {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub arrow_options: ArrowOptions,
}

impl Clone for ShapeArrow {
    fn clone(&self) -> Self {
        ShapeArrow {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            arrow_options: self.arrow_options.clone(),
        }
    }
}

impl Entity for ShapeArrow {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArrowShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct ArrowOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
    pub arrow_size: Float,
}

impl Clone for ArrowOptions {
    fn clone(&self) -> Self {
        ArrowOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            arrow_size: self.arrow_size,
        }
    }
}

impl ArrowOptions {
    pub fn new() -> ArrowOptions {
        ArrowOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            arrow_size: 8.0,
        }
    }
}

pub struct ShapeEllipse {
    pub entity: EntityID,
    pub radius: (Float, Float),
    pub ellipse_options: EllipseOptions,
}

impl Clone for ShapeEllipse {
    fn clone(&self) -> Self {
        ShapeEllipse {
            entity: self.entity.clone(),
            radius: self.radius,
            ellipse_options: self.ellipse_options.clone(),
        }
    }
}

impl ShapeEllipse {
    pub fn new(
        entity: EntityID,
        radius: (Float, Float),
        ellipse_options: EllipseOptions,
    ) -> ShapeEllipse {
        ShapeEllipse {
            entity,
            radius,
            ellipse_options,
        }
    }
}

impl Entity for ShapeEllipse {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::EllipseShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct EllipseOptions {
    //TODO: convert to Fill
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for EllipseOptions {
    fn clone(&self) -> Self {
        EllipseOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl EllipseOptions {
    pub fn new() -> EllipseOptions {
        EllipseOptions {
            fill_color: String::from("white"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct ShapeImage {
    pub entity: EntityID,
    //base64 encoded image or empty if using file_path
    pub image: String,
    //path to image file on disk (optional)
    pub file_path: Option<String>,
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
}

impl Clone for ShapeImage {
    fn clone(&self) -> Self {
        ShapeImage {
            entity: self.entity.clone(),
            image: self.image.clone(),
            file_path: self.file_path.clone(),
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
        }
    }
}

impl Entity for ShapeImage {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ImageShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeImage {
    pub fn new(entity: EntityID, image: String, size: (SizeBehavior, SizeBehavior)) -> ShapeImage {
        ShapeImage {
            entity,
            image,
            file_path: None,
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }

    pub fn from_file(
        entity: EntityID,
        file_path: String,
        size: (SizeBehavior, SizeBehavior),
    ) -> ShapeImage {
        ShapeImage {
            entity,
            image: String::new(), // Empty as we're using file_path instead
            file_path: Some(file_path),
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }
}

// A container that uses constraints to position its children
pub struct ConstraintLayoutContainer {
    pub entity: EntityID,
    pub children: Vec<EntityID>,
}

impl Clone for ConstraintLayoutContainer {
    fn clone(&self) -> Self {
        ConstraintLayoutContainer {
            entity: self.entity.clone(),
            children: self.children.clone(),
        }
    }
}

impl Entity for ConstraintLayoutContainer {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ConstraintLayoutContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ConstraintLayoutContainer {
    pub fn new(entity: EntityID, children: Vec<String>) -> Self {
        ConstraintLayoutContainer {
            entity: entity,
            children: children,
        }
    }
}

/// A container that allows children to be positioned with absolute coordinates
/// Children's positions are relative to the container's top-left corner
pub struct FreeContainer {
    pub entity: EntityID,
    pub children: Vec<(EntityID, (Float, Float))>, // Each child has a position relative to the container
    pub background_color: Option<String>,          // Optional background color
    pub border_color: Option<String>,              // Optional border color
    pub border_width: Float,                       // Border width (0 for no border)
}

impl Clone for FreeContainer {
    fn clone(&self) -> Self {
        FreeContainer {
            entity: self.entity.clone(),
            children: self.children.clone(),
            background_color: self.background_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
        }
    }
}

impl Entity for FreeContainer {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::FreeContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl FreeContainer {
    /// Create a new empty FreeContainer
    pub fn new(entity: EntityID) -> Self {
        FreeContainer {
            entity,
            children: Vec::new(),
            background_color: None,
            border_color: None,
            border_width: 0.0,
        }
    }

    /// Add a child to the container at the specified position
    pub fn add_child(&mut self, child_id: EntityID, position: (Float, Float)) {
        self.children.push((child_id, position));
    }

    /// Add multiple children at once with their positions
    pub fn with_children(
        mut self,
        children_with_positions: Vec<(EntityID, (Float, Float))>,
    ) -> Self {
        self.children.extend(children_with_positions);
        self
    }

    /// Set background color
    pub fn with_background_color(mut self, color: &str) -> Self {
        self.background_color = Some(color.to_string());
        self
    }

    /// Set border properties
    pub fn with_border(mut self, color: &str, width: Float) -> Self {
        self.border_color = Some(color.to_string());
        self.border_width = width;
        self
    }
}

// Arc options structure
#[derive(Default, Debug)]
pub struct ArcOptions {
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub filled: bool, // Whether to fill the arc sector or just draw the outline
}

impl Clone for ArcOptions {
    fn clone(&self) -> Self {
        ArcOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            filled: self.filled,
        }
    }
}

impl ArcOptions {
    pub fn new() -> ArcOptions {
        ArcOptions {
            fill_color: String::from("none"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            filled: false,
        }
    }
}

// Arc shape structure
pub struct ShapeArc {
    pub entity: EntityID,
    pub radius: Float,      // Radius of the arc
    pub start_angle: Float, // Start angle in degrees
    pub end_angle: Float,   // End angle in degrees
    pub arc_options: ArcOptions,
}

impl Clone for ShapeArc {
    fn clone(&self) -> Self {
        ShapeArc {
            entity: self.entity.clone(),
            radius: self.radius,
            start_angle: self.start_angle,
            end_angle: self.end_angle,
            arc_options: self.arc_options.clone(),
        }
    }
}

impl ShapeArc {
    pub fn new(
        entity: EntityID,
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        arc_options: ArcOptions,
    ) -> ShapeArc {
        ShapeArc {
            entity,
            radius,
            start_angle,
            end_angle,
            arc_options,
        }
    }

    /// Normalize angles to 0-360 degree range
    pub fn normalize_angles(&self) -> (Float, Float) {
        let mut start = self.start_angle % 360.0;
        let mut end = self.end_angle % 360.0;

        if start < 0.0 {
            start += 360.0;
        }
        if end < 0.0 {
            end += 360.0;
        }

        (start, end)
    }

    /// Calculate the angle sweep of the arc
    pub fn angle_sweep(&self) -> Float {
        let (start, end) = self.normalize_angles();
        if end > start {
            end - start
        } else {
            360.0 - start + end
        }
    }

    /// Check if this is a major arc (> 180 degrees)
    pub fn is_major_arc(&self) -> bool {
        self.angle_sweep() > 180.0
    }
}

impl Entity for ShapeArc {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArcShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

/// Type alias for custom component factory functions
/// Takes a map of attributes and a mutable reference to DiagramBuilder
/// Returns a Result with either a DiagramTreeNode or an error message
pub type CustomComponentFactory = Arc<
    dyn Fn(
            &str,
            &Map<String, Value>,
            &mut crate::DiagramBuilder,
            &JsonLinesParser,
        ) -> Result<crate::diagram_builder::DiagramTreeNode>
        + Send
        + Sync,
>;

/// Registry for custom components
pub struct CustomComponentRegistry {
    factories: HashMap<String, CustomComponentFactory>,
}

impl CustomComponentRegistry {
    pub fn new() -> Self {
        Self {
            factories: HashMap::new(),
        }
    }

    /// Register a new custom component with the given identifier and factory function
    pub fn register<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &str,
                &Map<String, Value>,
                &mut crate::DiagramBuilder,
                &JsonLinesParser,
            ) -> Result<crate::diagram_builder::DiagramTreeNode>
            + Send
            + Sync
            + 'static,
    {
        self.factories
            .insert(component_type.to_string(), Arc::new(factory));
    }

    /// Create a component instance using the registered factory
    pub fn create_component(
        &self,
        id: &str,
        component_type: &str,
        attributes: &Map<String, Value>,
        builder: &mut crate::DiagramBuilder,
        parser: &JsonLinesParser,
    ) -> Result<crate::diagram_builder::DiagramTreeNode> {
        match self.factories.get(component_type) {
            Some(factory) => factory(id, attributes, builder, parser),
            None => bail!("Unknown custom component type: {}", component_type),
        }
    }

    /// Check if a component type is registered
    pub fn has_component(&self, component_type: &str) -> bool {
        self.factories.contains_key(component_type)
    }

    /// Get all registered component types
    pub fn get_registered_types(&self) -> Vec<&String> {
        self.factories.keys().collect()
    }

    pub fn get(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &str,
                    &serde_json::Map<String, serde_json::Value>,
                    &mut crate::diagram_builder::DiagramBuilder,
                    &JsonLinesParser,
                ) -> Result<crate::diagram_builder::DiagramTreeNode>
                + Send
                + Sync,
        >,
    > {
        self.factories.get(component_type)
    }
}

impl Default for CustomComponentRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions for extracting common attribute types
impl CustomComponentRegistry {
    /// Helper to extract a string attribute with a default value
    pub fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    /// Helper to extract a float attribute with a default value
    pub fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    /// Helper to extract a boolean attribute with a default value
    pub fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    /// Helper to extract an integer attribute with a default value
    pub fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }
}

#[cfg(test)]
mod custom_component_tests {
    use super::*;
    use crate::*;
    use serde_json::json;

    /// Test custom component: Badge
    /// Creates a rounded box with text and a colored background
    fn create_badge_component(
        id: &str,
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
        parser: &JsonLinesParser,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        // Extract attributes with defaults
        let text = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("Badge")
            .to_string();

        let id = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string();

        let textNode = builder.new_text(id, &text, TextOptions::default());
        Ok(textNode)
    }

    #[test]
    fn test_custom_component_registry() {
        let mut registry = CustomComponentRegistry::new();

        // Register badge component
        registry.register("badge", create_badge_component);

        // Test that components are registered
        assert!(registry.has_component("badge"));
        assert!(!registry.has_component("unknown"));

        // Test getting registered types
        let types = registry.get_registered_types();
        assert_eq!(types.len(), 1);
        assert!(types.contains(&&"badge".to_string()));
    }

    #[test]
    fn test_create_badge_component() {
        let mut registry = CustomComponentRegistry::new();
        registry.register("badge", create_badge_component);

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));

        // Create badge with custom attributes
        let attrs = json!({
            "text": "NEW",
            "background_color": "red",
            "text_color": "white",
            "font_size": 14.0,
            "padding": 6.0,
            "border_radius": 20.0
        });

        let parser = JsonLinesParser::new();
        let attrs_map = attrs.as_object().unwrap();
        let badge = registry.create_component("badge", attrs_map, &mut builder, &parser);

        assert!(badge.is_ok());
        let badge_node = badge.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::TextShape);
    }
}

===/src/components/table.rs===

//use EntityID
use crate::components::*;


pub struct TableOptions {
    pub fill_color: String,
    pub header_fill_color: String,
    pub border_color: String,
    pub border_width: usize,
    pub cell_padding: Float,
    pub with_header: bool, // if true, first row has different background
}

/* A table contains a list of rows, each row has a cell 
* which is a group that contains other elements.

Tables are defined with an array of cells and the number of columns
*/
pub struct Table {
    pub entity: EntityID,
    pub cols: usize, 
    pub cells: Vec<EntityID>,
    pub col_lines: Vec<EntityID>,
    pub row_lines: Vec<EntityID>,
    pub header_rect: Option<EntityID>,
    pub table_options: TableOptions,
}

//new


impl Clone for Table {
    fn clone(&self) -> Self {
        Table {
            entity: self.entity.clone(),
            cols: self.cols,
            cells: self.cells.clone(),
            col_lines: self.col_lines.clone(),
            row_lines: self.row_lines.clone(),
            table_options: self.table_options.clone(),
            header_rect: self.header_rect.clone(),
        }
    }
}

//constructor that receives only the table options
impl Table {
    pub fn new(entity: EntityID,cells: Vec<EntityID>, col_lines: Vec<EntityID>, row_lines: Vec<EntityID>, cols: usize, header_rect: Option<EntityID>, table_options: TableOptions) -> Table {
        Table {
            entity,
            cols,
            cells,
            col_lines,
            row_lines ,
            header_rect, 
            table_options,
        }
    }
}

impl Entity for Table {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TableShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}




//defaults
impl Default for TableOptions {
    fn default() -> Self {
        TableOptions {
            fill_color: String::from("white"),
            border_color: String::from("black"),
            header_fill_color: String::from("lightgray"),
            border_width: 1,
            cell_padding: 20.0,
            with_header: true,
        }
    }
}

impl Clone for TableOptions {
    fn clone(&self) -> Self {
        TableOptions {
            fill_color: self.fill_color.clone(),
            header_fill_color: self.header_fill_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
            cell_padding: self.cell_padding,
            with_header: self.with_header,
        }
    }
}

===/src/renderer_base.rs===
use std::{error::Error, fmt, io::Write};

use crate::{DiagramBuilder, diagram_builder::DiagramTreeNode};

#[derive(Debug)]
pub struct RendererError {
    message: String,
}

impl RendererError {
    pub fn new(message: &str) -> RendererError {
        RendererError {
            message: message.to_string(),
        }
    }
}

impl fmt::Display for RendererError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for RendererError {}

pub trait Renderer<W: Write> {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError>;
}

===/src/transform.rs===
// In src/transform.rs (new file)
use std::f32::consts::PI;

use crate::{BoundingBox, Float};

#[derive(Debug, Clone, PartialEq)]
pub struct Transform {
    // 2D transform matrix [a, b, c, d, e, f]
    // | a  c  e |   | x |   | a*x + c*y + e |
    // | b  d  f | * | y | = | b*x + d*y + f |
    // | 0  0  1 |   | 1 |   |       1       |
    pub matrix: [Float; 6],
}

impl Transform {
    pub fn identity() -> Self {
        Transform {
            matrix: [1.0, 0.0, 0.0, 1.0, 0.0, 0.0], // [a, b, c, d, e, f]
        }
    }
    
    pub fn translation(tx: Float, ty: Float) -> Self {
        Transform {
            matrix: [1.0, 0.0, 0.0, 1.0, tx, ty],
        }
    }
    
    pub fn rotation(angle_degrees: Float) -> Self {
        let angle_rad = angle_degrees * PI / 180.0;
        let cos_a = angle_rad.cos();
        let sin_a = angle_rad.sin();
        Transform {
            matrix: [cos_a, sin_a, -sin_a, cos_a, 0.0, 0.0],
        }
    }
    
    pub fn scale(sx: Float, sy: Float) -> Self {
        Transform {
            matrix: [sx, 0.0, 0.0, sy, 0.0, 0.0],
        }
    }
    
    pub fn combine(&self, other: &Transform) -> Transform {
        // Matrix multiplication: self * other
        let [a1, b1, c1, d1, e1, f1] = self.matrix;
        let [a2, b2, c2, d2, e2, f2] = other.matrix;
        
        Transform {
            matrix: [
                a1 * a2 + c1 * b2,           // a
                b1 * a2 + d1 * b2,           // b
                a1 * c2 + c1 * d2,           // c
                b1 * c2 + d1 * d2,           // d
                a1 * e2 + c1 * f2 + e1,      // e
                b1 * e2 + d1 * f2 + f1,      // f
            ],
        }
    }
    
    pub fn transform_point(&self, x: Float, y: Float) -> (Float, Float) {
        let [a, b, c, d, e, f] = self.matrix;
        (
            a * x + c * y + e,
            b * x + d * y + f,
        )
    }
    
    pub fn transform_rect(&self, x: Float, y: Float, width: Float, height: Float) -> BoundingBox {
        // Transform all four corners and find axis-aligned bounding box
        let corners = [
            (x, y),
            (x + width, y),
            (x + width, y + height),
            (x, y + height),
        ];
        
        let transformed_corners: Vec<(Float, Float)> = corners
            .iter()
            .map(|(px, py)| self.transform_point(*px, *py))
            .collect();
        
        let min_x = transformed_corners.iter().map(|(x, _)| *x).fold(Float::INFINITY, f32::min);
        let max_x = transformed_corners.iter().map(|(x, _)| *x).fold(Float::NEG_INFINITY, f32::max);
        let min_y = transformed_corners.iter().map(|(_, y)| *y).fold(Float::INFINITY, f32::min);
        let max_y = transformed_corners.iter().map(|(_, y)| *y).fold(Float::NEG_INFINITY, f32::max);
        
        BoundingBox {
            x: min_x,
            y: min_y,
            width: max_x - min_x,
            height: max_y - min_y,
        }
    }
    
     pub fn to_svg_string(&self) -> String {
        let [a, b, c, d, e, f] = self.matrix;
        
        // If it's just a translation, use the simpler translate syntax
        if a == 1.0 && b == 0.0 && c == 0.0 && d == 1.0 {
            if e == 0.0 && f == 0.0 {
                String::new() // Identity transform
            } else {
                format!("translate({} {})", e, f)
            }
        } else {
            // Full matrix transform
            format!("matrix({} {} {} {} {} {})", a, b, c, d, e, f)
        }
    }
}
===/src/parser.rs===
use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

use crate::transform::Transform;
use crate::{components::*, diagram_builder::*, DiagramBuilder, SimpleConstraint};
use anyhow::{bail, Context, Error, Result};
use thiserror::Error;

/// Simplified JSON Lines entity with only essential fields
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonEntity {
    pub id: String,
    #[serde(rename = "type")]
    pub entity_type: String,

    // All attributes go into this single map - much cleaner!
    #[serde(flatten)]
    pub attributes: Map<String, Value>,
}

impl Default for JsonEntity {
    fn default() -> Self {
        Self {
            id: String::new(),
            entity_type: String::new(),
            attributes: Map::new(),
        }
    }
}

// Add this enum after JsonEntity struct
#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(tag = "type")]
pub enum ConstraintDeclaration {
    #[serde(rename = "align_left")]
    AlignLeft { entities: Vec<String> },
    #[serde(rename = "align_right")]
    AlignRight { entities: Vec<String> },
    #[serde(rename = "align_top")]
    AlignTop { entities: Vec<String> },
    #[serde(rename = "align_bottom")]
    AlignBottom { entities: Vec<String> },
    #[serde(rename = "align_center_horizontal")]
    AlignCenterHorizontal { entities: Vec<String> },
    #[serde(rename = "align_center_vertical")]
    AlignCenterVertical { entities: Vec<String> },
    #[serde(rename = "right_of")]
    RightOf { entities: Vec<String> },
    #[serde(rename = "left_of")]
    LeftOf { entities: Vec<String> },
    #[serde(rename = "above")]
    Above { entities: Vec<String> },
    #[serde(rename = "below")]
    Below { entities: Vec<String> },
    #[serde(rename = "horizontal_spacing")]
    HorizontalSpacing {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "vertical_spacing")]
    VerticalSpacing {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "stack_horizontal")]
    StackHorizontal {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "stack_vertical")]
    StackVertical {
        entities: Vec<String>,
        spacing: Float,
    },
    #[serde(rename = "fixed_distance")]
    FixedDistance {
        entities: Vec<String>,
        distance: Float,
    },
    #[serde(rename = "same_width")]
    SameWidth { entities: Vec<String> },
    #[serde(rename = "same_height")]
    SameHeight { entities: Vec<String> },
    #[serde(rename = "same_size")]
    SameSize { entities: Vec<String> },
    #[serde(rename = "proportional_width")]
    ProportionalWidth { entities: Vec<String>, ratio: Float },
    #[serde(rename = "proportional_height")]
    ProportionalHeight { entities: Vec<String>, ratio: Float },
    #[serde(rename = "aspect_ratio")]
    AspectRatio { entity: String, ratio: Float },
}

fn convert_constraint_declaration(decl: &ConstraintDeclaration) -> Result<SimpleConstraint> {
    match decl {
        ConstraintDeclaration::AlignLeft { entities } => {
            Ok(SimpleConstraint::AlignLeft(entities.to_vec()))
        }
        ConstraintDeclaration::AlignRight { entities } => {
            Ok(SimpleConstraint::AlignRight(entities.to_vec()))
        }
        ConstraintDeclaration::AlignTop { entities } => {
            Ok(SimpleConstraint::AlignTop(entities.to_vec()))
        }
        ConstraintDeclaration::AlignBottom { entities } => {
            Ok(SimpleConstraint::AlignBottom(entities.to_vec()))
        }
        ConstraintDeclaration::AlignCenterHorizontal { entities } => {
            Ok(SimpleConstraint::AlignCenterHorizontal(entities.to_vec()))
        }
        ConstraintDeclaration::AlignCenterVertical { entities } => {
            Ok(SimpleConstraint::AlignCenterVertical(entities.to_vec()))
        }
        ConstraintDeclaration::RightOf { entities } => {
            if entities.len() != 2 {
                bail!("right_of requires exactly 2 entities");
            }
            Ok(SimpleConstraint::RightOf(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::LeftOf { entities } => {
            if entities.len() != 2 {
                bail!("left_of requires exactly 2 entities");
            }
            Ok(SimpleConstraint::LeftOf(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::Above { entities } => {
            if entities.len() != 2 {
                bail!("above requires exactly 2 entities")
            }
            Ok(SimpleConstraint::Above(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::Below { entities } => {
            if entities.len() != 2 {
                bail!("below requires exactly 2 entities");
            }
            Ok(SimpleConstraint::Below(
                entities[0].clone(),
                entities[1].clone(),
            ))
        }
        ConstraintDeclaration::HorizontalSpacing { entities, spacing } => {
            if entities.len() != 2 {
                bail!("horizontal_spacing requires exactly 2 entities");
            }
            Ok(SimpleConstraint::HorizontalSpacing(
                entities[0].clone(),
                entities[1].clone(),
                *spacing,
            ))
        }
        ConstraintDeclaration::VerticalSpacing { entities, spacing } => {
            if entities.len() != 2 {
                bail!("vertical_spacing requires exactly 2 entities");
            }
            Ok(SimpleConstraint::VerticalSpacing(
                entities[0].clone(),
                entities[1].clone(),
                *spacing,
            ))
        }
        ConstraintDeclaration::StackHorizontal { entities, spacing } => {
            if entities.len() < 2 {
                bail!("stack_horizontal requires at least 2 entities");
            }
            Ok(SimpleConstraint::StackHorizontal(
                entities.clone(),
                Some(*spacing),
            ))
        }
        ConstraintDeclaration::StackVertical { entities, spacing } => {
            if entities.len() < 2 {
                bail!("stack_vertical requires at least 2 entities");
            }
            Ok(SimpleConstraint::StackVertical(
                entities.clone(),
                Some(*spacing),
            ))
        }
        ConstraintDeclaration::FixedDistance { entities, distance } => {
            if entities.len() != 2 {
                bail!("fixed_distance requires exactly 2 entities");
            }
            Ok(SimpleConstraint::FixedDistance(
                entities[0].clone(),
                entities[1].clone(),
                *distance,
            ))
        }
        ConstraintDeclaration::SameWidth { entities } => {
            Ok(SimpleConstraint::SameWidth(entities.to_vec()))
        }
        ConstraintDeclaration::SameHeight { entities } => {
            Ok(SimpleConstraint::SameHeight(entities.to_vec()))
        }
        ConstraintDeclaration::SameSize { entities } => {
            Ok(SimpleConstraint::SameSize(entities.to_vec()))
        }
        ConstraintDeclaration::ProportionalWidth { entities, ratio } => {
            if entities.len() != 2 {
                bail!("proportional_width requires exactly 2 entities");
            }
            Ok(SimpleConstraint::ProportionalWidth(
                entities[0].clone(),
                entities[1].clone(),
                *ratio,
            ))
        }
        ConstraintDeclaration::ProportionalHeight { entities, ratio } => {
            if entities.len() != 2 {
                bail!("proportional_height requires exactly 2 entities");
            }
            Ok(SimpleConstraint::ProportionalHeight(
                entities[0].clone(),
                entities[1].clone(),
                *ratio,
            ))
        }
        ConstraintDeclaration::AspectRatio { entity, ratio } => {
            Ok(SimpleConstraint::AspectRatio(entity.clone(), *ratio))
        }
    }
}

// Helper functions for attribute extraction with multiple attribute name support
pub fn get_string_attr(attrs: &Map<String, Value>, keys: &[&str], default: &str) -> String {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(s) = value.as_str() {
                return if s.is_empty() && !default.is_empty() {
                    default.to_string()
                } else {
                    s.to_string()
                };
            }
        }
    }
    default.to_string()
}

pub fn get_float_attr(attrs: &Map<String, Value>, keys: &[&str], default: f64) -> Float {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(f) = value.as_f64() {
                return f as Float;
            }
        }
    }
    default as Float
}

pub fn get_int_attr(attrs: &Map<String, Value>, keys: &[&str], default: i64) -> i64 {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(i) = value.as_i64() {
                return i;
            }
        }
    }
    default
}

pub fn get_bool_attr(attrs: &Map<String, Value>, keys: &[&str], default: bool) -> bool {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(b) = value.as_bool() {
                return b;
            }
        }
    }
    default
}

pub fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<String>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
    })
}

pub fn get_point_attr(
    attrs: &Map<String, Value>,
    x_keys: &[&str],
    y_keys: &[&str],
    default: (Float, Float),
) -> (Float, Float) {
    let x = get_float_attr(attrs, x_keys, default.0 as f64);
    let y = get_float_attr(attrs, y_keys, default.1 as f64);
    (x, y)
}

pub fn get_points_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<(Float, Float)>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| {
                    item.as_array().and_then(|point_arr| {
                        if point_arr.len() >= 2 {
                            let x = point_arr[0].as_f64().unwrap_or(0.0) as Float;
                            let y = point_arr[1].as_f64().unwrap_or(0.0) as Float;
                            Some((x, y))
                        } else {
                            None
                        }
                    })
                })
                .collect()
        })
    })
}

/// Parse a unified width/height value that can be either a number (fixed) or string (behavior)
pub fn parse_unified_dimension(attrs: &Map<String, Value>, keys: &[&str]) -> SizeBehavior {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            match value {
                Value::Number(num) => {
                    if let Some(float_val) = num.as_f64() {
                        return SizeBehavior::Fixed(float_val as Float);
                    }
                }
                Value::String(behavior) => {
                    return match behavior.to_lowercase().as_str() {
                        "content" | "auto" => SizeBehavior::Content,
                        "grow" => SizeBehavior::Grow,
                        _ => {
                            // Try to parse as number string
                            if let Ok(parsed) = behavior.parse::<Float>() {
                                SizeBehavior::Fixed(parsed)
                            } else {
                                SizeBehavior::Content
                            }
                        }
                    };
                }
                _ => {}
            }
        }
    }
    SizeBehavior::Content // Default
}
fn parse_transform_attributes(
    obj: &Map<String, Value>,
    session: &mut DiagramBuilder,
    entity_id: EntityID,
) {
    println!("🔍 Parsing transforms for entity: {}", entity_id);
    println!(
        "🔍 Available attributes: {:?}",
        obj.keys().collect::<Vec<_>>()
    );

    let mut transform = Transform::identity();

    // Parse individual transform properties
    // Store container-relative position separately
    if let Some(x) = obj.get("x").and_then(|v| v.as_f64()) {
        if let Some(y) = obj.get("y").and_then(|v| v.as_f64()) {
            session.set_container_relative_position(entity_id.clone(), x as Float, y as Float);
        }
    }

    if let Some(rotation) = obj
        .get("rotation")
        .or_else(|| obj.get("rotate"))
        .and_then(|v| v.as_f64())
    {
        println!(
            "🔄 Found rotation: {} degrees for entity {}",
            rotation, entity_id
        );
        transform = transform.combine(&Transform::rotation(rotation as Float));
    } else {
        println!("❌ No rotation found for entity {}", entity_id);
    }

    if let Some(scale) = obj.get("scale") {
        match scale {
            Value::Number(s) => {
                let s = s.as_f64().unwrap_or(1.0) as Float;
                println!("📏 Found uniform scale: {}", s);
                transform = transform.combine(&Transform::scale(s, s));
            }
            Value::Array(arr) if arr.len() >= 2 => {
                let sx = arr[0].as_f64().unwrap_or(1.0) as Float;
                let sy = arr[1].as_f64().unwrap_or(1.0) as Float;
                println!("📏 Found scale: [{}, {}]", sx, sy);
                transform = transform.combine(&Transform::scale(sx, sy));
            }
            _ => {}
        }
    }

    // Parse CSS-style transform string
    if let Some(transform_str) = obj.get("transform").and_then(|v| v.as_str()) {
        if let Ok(parsed_transform) = parse_css_transform(transform_str) {
            transform = transform.combine(&parsed_transform);
        }
    }

    println!("📐 Final transform for {}: {:?}", entity_id, transform);
    session.set_transform(entity_id, transform);
}

// Parse CSS-style transform strings like "rotate(45deg) scale(1.5) translate(10px, 20px)"
fn parse_css_transform(transform_str: &str) -> Result<Transform, String> {
    // Implementation would parse CSS transform functions
    // For now, simplified version:
    let result = Transform::identity();

    // This is a simplified parser - full implementation would be more robust
    if transform_str.contains("rotate(") {
        // Extract rotation value...
    }

    Ok(result)
}

/// Parser for JSON Lines diagram format
pub struct JsonLinesParser {
    pub entities: HashMap<String, JsonEntity>,
}

impl JsonLinesParser {
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
        }
    }

    /// Parse from a string containing JSON Lines
    pub fn parse_string(&mut self, input: &str) -> Result<String, JsonLinesError> {
        let mut root_id = None;

        for (line_num, line) in input.lines().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from a file
    pub fn parse_file(&mut self, file_path: &str) -> Result<String, JsonLinesError> {
        let file = File::open(file_path).map_err(|e| JsonLinesError::IoError(e.to_string()))?;
        let reader = BufReader::new(file);
        let mut root_id = None;

        for (line_num, line_result) in reader.lines().enumerate() {
            let line = line_result.map_err(|e| JsonLinesError::IoError(e.to_string()))?;
            let line = line.trim();

            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(&line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from an iterator of lines (useful for streaming)
    pub fn parse_lines<I>(&mut self, lines: I) -> Result<String, JsonLinesError>
    where
        I: IntoIterator<Item = String>,
    {
        let mut root_id = None;

        for (line_num, line) in lines.into_iter().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Build the diagram tree from parsed entities
    pub fn build(&self, root_id: &str, builder: &mut DiagramBuilder) -> Result<DiagramTreeNode> {
        let mut root_node = self.build_entity(root_id, builder)?;

        let promoted_connectors =
            self.promote_connectors_to_root(root_id, &mut root_node, builder)?;

        // After building the root node, process the elements that need to be children of root (e.g connectors)
        let pending = builder.take_pending_root_nodes();
        if !pending.is_empty() {
            root_node
                .children
                .extend(pending.iter().map(|e| Box::new(e.to_owned())));
        }
        Ok(root_node)
    }

    fn promote_connectors_to_root(
        &self,
        root_id: &str,
        root_node: &mut DiagramTreeNode,
        builder: &mut DiagramBuilder,
    ) -> Result<Vec<String>> {
        let mut promoted = Vec::new();

        // Find all connectors in the tree
        self.find_and_remove_connectors(&mut root_node.children, &mut promoted);

        // Build connector nodes and add to root
        for conn_id in &promoted {
            if let Some(entity) = self.entities.get(conn_id) {
                if entity.entity_type == "connector" {
                    let conn_node = self.build_entity(conn_id, builder)?;
                    root_node.children.push(Box::new(conn_node));
                }
            }
        }

        Ok(promoted)
    }

    fn find_and_remove_connectors(
        &self,
        children: &mut Vec<Box<DiagramTreeNode>>,
        found: &mut Vec<String>,
    ) {
        children.retain(|child| {
            if child.entity_type == EntityType::ConnectorShape {
                found.push(child.entity_id.clone());
                false // Remove from current location
            } else {
                // Recursively check children
                if !child.children.is_empty() {
                    self.find_and_remove_connectors(&mut child.children.clone(), found);
                }
                true // Keep non-connector nodes
            }
        });
    }

    fn build_entity(
        &self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode> {
        println!("*** building entity {} ***", entity_id);
        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        // Clone the entity type to avoid borrow conflicts
        let component_type = entity.entity_type.clone();
        let attributes = entity.attributes.clone();
        println!("Attributes length {}", attributes.len());

        // Check for custom components FIRST - they get the raw attributes map
        if builder.has_custom_component(&component_type) {
            return builder.create_custom_component(
                &entity_id,
                &component_type,
                &attributes,
                &self,
            );
        }

        // Handle built-in components using attribute helpers
        match entity.entity_type.as_str() {
            "spacer" => {
                let width = get_float_attr(&entity.attributes, &["width"], 1.0);
                let height = get_float_attr(&entity.attributes, &["height"], 20.0);
                let direction = get_string_attr(&entity.attributes, &["direction"], "vertical");

                // Determine spacer direction and final dimensions
                let spacer_direction = match direction.as_str() {
                    "horizontal" => SpacerDirection::Horizontal,
                    "both" => SpacerDirection::Both,
                    _ => SpacerDirection::Vertical, // default
                };

                let spacer_options = SpacerOptions {
                    width,
                    height,
                    direction: spacer_direction,
                };

                Ok(builder.new_spacer(entity_id.to_string(), spacer_options))
            }

            "text" => {
                let content = get_string_attr(&entity.attributes, &["content", "text"], "");
                if content.is_empty() {
                    bail!("Missing attribute content or text");
                }

                // Only support "bold", otherwise return the value or "400" by default
                let str_font_weight = &get_string_attr(&entity.attributes, &["font_weight"], "400");
                let f_weight: u32 = if let Ok(val) = str::parse::<u32>(&str_font_weight) {
                    val
                } else if str_font_weight == "bold " {
                    900
                } else {
                    400
                };

                let options = TextOptions {
                    font_size: get_float_attr(&entity.attributes, &["font_size"], 12.0),
                    text_color: get_string_attr(
                        &entity.attributes,
                        &["color", "text_color"],
                        "black",
                    ),
                    font_weight: f_weight,
                    font_family: get_string_attr(&entity.attributes, &["font_family"], "Arial"),
                    line_width: get_int_attr(&entity.attributes, &["line_width"], 200) as usize,
                    line_spacing: get_float_attr(&entity.attributes, &["line_spacing"], 0.0),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_text(entity_id.to_string(), &content, options))
            }

            "box" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                if children.len() != 1 {
                    bail!("Box must have exactly one child");
                }

                let child = self.build_entity(&children[0], builder)?;

                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = BoxOptions {
                    padding: get_float_attr(&entity.attributes, &["padding"], 0.0),
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                    width_behavior,
                    height_behavior,
                    // TODO: leer de atributo
                    horizontal_alignment: HorizontalAlignment::Center,
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_box(entity_id.to_string(), child, options))
            }

            "vstack" => {
                let halign = match get_string_attr(
                    &entity.attributes,
                    &["h_align", "horizontal_alignment"],
                    "center",
                )
                .as_str()
                {
                    "left" => HorizontalAlignment::Left,
                    "center" => HorizontalAlignment::Center,
                    "right" => HorizontalAlignment::Right,
                    _ => HorizontalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Vec<_> = children
                    .iter()
                    .filter_map(|child_id| {
                        match self.build_entity(child_id, builder) {
                            Ok(node) => Some(node),
                            Err(e) => {
                                eprintln!("Warning: Failed to build child '{}': {}", child_id, e);
                                None // Skip this child, continue with others
                            }
                        }
                    })
                    .collect();

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_vstack(entity_id.to_string(), child_nodes, halign))
            }

            "hstack" => {
                let valign = match get_string_attr(
                    &entity.attributes,
                    &["v_align", "vertical_alignment"],
                    "center",
                )
                .as_str()
                {
                    "top" => VerticalAlignment::Top,
                    "center" => VerticalAlignment::Center,
                    "bottom" => VerticalAlignment::Bottom,
                    _ => VerticalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Vec<_> = children
                    .iter()
                    .filter_map(|child_id| {
                        match self.build_entity(child_id, builder) {
                            Ok(node) => Some(node),
                            Err(e) => {
                                eprintln!("Warning: Failed to build child '{}': {}", child_id, e);
                                None // Skip this child, continue with others
                            }
                        }
                    })
                    .collect();

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_hstack(entity_id.to_string(), child_nodes, valign))
            }

            "group" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Vec<_> = children
                    .iter()
                    .filter_map(|child_id| {
                        match self.build_entity(child_id, builder) {
                            Ok(node) => Some(node),
                            Err(e) => {
                                eprintln!("Warning: Failed to build child '{}': {}", child_id, e);
                                None // Skip this child, continue with others
                            }
                        }
                    })
                    .collect();

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_group(entity_id.to_string(), child_nodes))
            }

            "rect" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = RectOptions {
                    width_behavior,
                    height_behavior,
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                };
                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_rectangle(entity_id.to_string(), options))
            }

            "line" => {
                let start_point = get_point_attr(
                    &entity.attributes,
                    &["start_x", "x1"],
                    &["start_y", "y1"],
                    (0.0, 0.0),
                );
                let end_point = get_point_attr(
                    &entity.attributes,
                    &["end_x", "x2"],
                    &["end_y", "y2"],
                    (0.0, 0.0),
                );

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_line(
                    entity_id.to_string(),
                    LinePointReference::Value(start_point.0, start_point.1),
                    LinePointReference::Value(end_point.0, end_point.1),
                    options,
                ))
            }

            "connector" => {
                // Required attributes
                let source_id =
                    get_string_attr(&entity.attributes, &["source", "source_id", "from"], "");

                let target_id =
                    get_string_attr(&entity.attributes, &["target", "target_id", "to"], "");
                
                let label = get_string_attr(&entity.attributes, &["label"], "");

                if source_id.is_empty() || target_id.is_empty() {
                    bail!("Connector requires 'source' and 'target' attributes");
                }

                // Optional styling
                let stroke_color = get_string_attr(
                    &entity.attributes,
                    &["stroke_color", "color", "stroke"],
                    "black",
                );

                let stroke_width = get_float_attr(&entity.attributes, &["stroke_width"], 1.0);

                // Connector type
                let connector_type_str =
                    get_string_attr(&entity.attributes, &["connector_type"], "straight");

                let connector_type = match connector_type_str.as_str() {
                    "curved" => ConnectorType::Curved,
                    "orthogonal" => ConnectorType::Orthogonal,
                    _ => ConnectorType::Straight,
                };

                // Curve offset for curved connectors
                let curve_offset = if connector_type_str == "curved" {
                    let offset =
                        get_float_attr(&entity.attributes, &["curve_offset", "curve_amount"], 0.0);
                    if offset > 0.0 {
                        Some(offset)
                    } else {
                        None
                    }
                } else {
                    None
                };

                // Parse ports
                let source_port = parse_port(&entity.attributes, "source_port");
                let target_port = parse_port(&entity.attributes, "target_port");

                let arrow_start =
                    get_bool_attr(&entity.attributes, &["arrow_start", "arrow_begin"], false);
                let arrow_end = get_bool_attr(&entity.attributes, &["arrow_end"], false);
                let arrow_size = get_float_attr(&entity.attributes, &["arrow_size"], 8.0);

                let options = ConnectorOptions {
                    connector_type,
                    stroke_color,
                    stroke_width,
                    curve_offset,
                    source_port,
                    target_port,
                    arrow_start,
                    arrow_end,
                    arrow_size,
                    // TODO: read from params
                    routing_strategy: OrthogonalRoutingStrategy::Auto,
                };

                // Create connector
                Ok(builder.new_connector_with_label(entity_id.to_string(), source_id, target_id,label,options))
            }

            "ellipse" => {
                let radius = get_point_attr(
                    &entity.attributes,
                    &["rx", "radius_x"],
                    &["ry", "radius_y"],
                    (25.0, 25.0),
                );

                let options = EllipseOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color", "background"],
                        "white",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color", "border_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["stroke_width", "border_width"],
                        1.0,
                    ),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_ellipse(entity_id.to_string(), radius, options))
            }

            "arc" => {
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let start_angle =
                    get_float_attr(&entity.attributes, &["start_angle", "start"], 0.0);
                let end_angle = get_float_attr(&entity.attributes, &["end_angle", "end"], 90.0);

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_arc(
                    entity_id.to_string(),
                    radius,
                    start_angle,
                    end_angle,
                    options,
                ))
            }

            // Complete fixed semicircle section for parser.rs
            "semicircle" => {
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let facing_up = get_bool_attr(&entity.attributes, &["facing_up", "up"], true);

                let (start, end) = if facing_up {
                    (180.0, 360.0) // FIXED: Top semicircle should be 180° to 360°
                } else {
                    (0.0, 180.0) // FIXED: Bottom semicircle should be 0° to 180°
                };

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_arc(entity_id.to_string(), radius, start, end, options))
            }

            "quarter_circle" => {
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let quadrant = get_int_attr(&entity.attributes, &["quadrant"], 1) as u8;

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_quarter_circle(entity_id.to_string(), radius, quadrant, options))
            }

            "image" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let src = get_string_attr(&entity.attributes, &["src"], "");
                let file_path = get_string_attr(&entity.attributes, &["file_path"], "");

                if !src.is_empty() {
                    parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                    Ok(builder.new_image(
                        entity_id.to_string(),
                        &src,
                        (width_behavior, height_behavior),
                    ))
                } else if !file_path.is_empty() {
                    parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());
                    Ok(builder.new_image_from_file(
                        entity_id.to_string(),
                        &file_path,
                        (width_behavior, height_behavior),
                    ))
                } else {
                    Err(JsonLinesError::MissingAttribute("src or file_path".to_string()).into())
                }
            }

            "table" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;
                let cols = get_int_attr(&entity.attributes, &["cols", "columns"], 1) as usize;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                let options = TableOptions {
                    header_fill_color: get_string_attr(
                        &entity.attributes,
                        &["header_fill_color", "header_background"],
                        "lightgray",
                    ),
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill_color", "background"],
                        "white",
                    ),
                    border_color: get_string_attr(&entity.attributes, &["border_color"], "black"),
                    border_width: get_int_attr(&entity.attributes, &["border_width"], 1) as usize,
                    cell_padding: get_int_attr(&entity.attributes, &["cell_padding", "padding"], 20)
                        as Float,
                    with_header: true,
                };

                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_table(entity_id.to_string(), child_nodes?, cols, options))
            }

            "polyline" => {
                let points = get_points_attr(&entity.attributes, "points")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("points".to_string()))?;

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_polyline(entity_id.to_string(), points, options))
            }

            "free_container" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let mut positioned_children = Vec::new();
                for child_id in children {
                    let _child_entity = self
                        .entities
                        .get(&child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;

                    let child_node = self.build_entity(&child_id, builder)?;
                    let pos = builder.get_container_relative_position(&child_id);
                    println!(
                        "📍 Free container adding child: {} at position: ({}, {})",
                        child_id, pos.x, pos.y
                    );

                    positioned_children.push((child_node, (pos.x, pos.y)));
                }
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_free_container(entity_id.to_string(), positioned_children))
            }

            "constraint_container" => {
                let children = get_array_attr(&entity.attributes, "children").unwrap_or_default();

                // Parse inline constraints if present
                let mut constraints = Vec::new();
                if let Some(constraints_attr) = entity.attributes.get("constraints") {
                    if let Some(constraints_array) = constraints_attr.as_array() {
                        for constraint_val in constraints_array {
                            if let Ok(constraint_decl) =
                                serde_json::from_value::<ConstraintDeclaration>(
                                    constraint_val.clone(),
                                )
                            {
                                let simple_constraint =
                                    convert_constraint_declaration(&constraint_decl)?;
                                constraints.push(simple_constraint);
                            }
                        }
                    }
                }

                let mut children_with_pos = Vec::new();

                for child_id in children {
                    let _child_entity = self
                        .entities
                        .get(&child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;

                    if let Ok(child_node) = self.build_entity(&child_id, builder) {
                        let pos = builder.get_container_relative_position(&child_id);

                        // For constraint containers, position is optional (constraints determine positioning)
                        let suggest_pos = if pos.x != 0.0 || pos.y != 0.0 {
                            Some(pos)
                        } else {
                            None
                        };

                        children_with_pos.push((child_node, suggest_pos));
                    }
                }

                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_constraint_layout_container(
                    entity_id.to_string(),
                    children_with_pos,
                    constraints,
                ))
            }
            _ => Err(JsonLinesError::UnknownEntityType(entity.entity_type.clone()).into()),
        }
    }

    /// Validate that all child references exist
    pub fn validate(&self) -> Result<(), JsonLinesError> {
        for (id, entity) in &self.entities {
            if let Some(children) = get_array_attr(&entity.attributes, "children") {
                for child_id in children {
                    if !self.entities.contains_key(&child_id) {
                        return Err(JsonLinesError::MissingChild {
                            parent: id.clone(),
                            child: child_id,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    /// Get all entity IDs
    pub fn get_entity_ids(&self) -> Vec<&String> {
        self.entities.keys().collect()
    }
}

/// Builder for creating JSON Lines diagrams
pub struct JsonLinesBuilder {
    entities: Vec<JsonEntity>,
}

impl JsonLinesBuilder {
    pub fn new() -> Self {
        Self {
            entities: Vec::new(),
        }
    }

    /// Create a text entity
    pub fn text(&mut self, id: String, content: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a styled text entity
    pub fn text_styled(
        &mut self,
        id: String,
        content: &str,
        font_size: f64,
        color: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));
        attrs.insert(
            "font_size".to_string(),
            Value::Number(serde_json::Number::from_f64(font_size).unwrap()),
        );
        attrs.insert("color".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a box entity
    pub fn box_with(
        &mut self,
        id: String,
        child: String,
        padding: f64,
        background: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(vec![Value::String(child)]),
        );
        attrs.insert(
            "padding".to_string(),
            Value::Number(serde_json::Number::from_f64(padding).unwrap()),
        );
        attrs.insert(
            "background".to_string(),
            Value::String(background.to_string()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "box".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a vertical stack
    pub fn vstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "vstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a horizontal stack
    pub fn hstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "hstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a rectangle
    pub fn rect(&mut self, id: String, width: f64, height: f64, color: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "width".to_string(),
            Value::Number(serde_json::Number::from_f64(width).unwrap()),
        );
        attrs.insert(
            "height".to_string(),
            Value::Number(serde_json::Number::from_f64(height).unwrap()),
        );
        attrs.insert("background".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "rect".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a custom component entity
    pub fn custom_component(
        &mut self,
        id: String,
        component_type: &str,
        attributes: Map<String, Value>,
    ) -> String {
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: component_type.to_string(),
            attributes,
        });
        id
    }

    /// Build and return the JSON Lines string
    pub fn build(&self) -> Result<String, serde_json::Error> {
        let mut lines = Vec::new();
        for entity in &self.entities {
            lines.push(serde_json::to_string(entity)?);
        }
        Ok(lines.join("\n"))
    }

    /// Write to a file
    pub fn write_to_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::create(file_path)?;
        for entity in &self.entities {
            writeln!(file, "{}", serde_json::to_string(entity)?)?;
        }
        Ok(())
    }

    /// Get the root entity ID (first entity)
    pub fn root_id(&self) -> Option<String> {
        self.entities.first().map(|e| e.id.clone())
    }
}

#[derive(Debug)]
pub enum JsonLinesError {
    ParseError { line: usize, message: String },
    EntityNotFound(String),
    MissingAttribute(String),
    InvalidStructure(String),
    UnknownEntityType(String),
    MissingChild { parent: String, child: String },
    NoEntities,
    IoError(String),
    ConstraintError(String),
}

impl std::fmt::Display for JsonLinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsonLinesError::ParseError { line, message } => {
                write!(f, "Parse error on line {}: {}", line, message)
            }
            JsonLinesError::EntityNotFound(id) => write!(f, "Entity not found: {}", id),
            JsonLinesError::MissingAttribute(attr) => {
                write!(f, "Missing required attribute: {}", attr)
            }
            JsonLinesError::InvalidStructure(msg) => write!(f, "Invalid structure: {}", msg),
            JsonLinesError::UnknownEntityType(t) => write!(f, "Unknown entity type: {}", t),
            JsonLinesError::MissingChild { parent, child } => {
                write!(f, "Parent {} references missing child {}", parent, child)
            }
            JsonLinesError::NoEntities => write!(f, "No entities found"),
            JsonLinesError::IoError(msg) => write!(f, "IO error: {}", msg),
            JsonLinesError::ConstraintError(msg) => write!(f, "Constraint error: {}", msg),
        }
    }
}

impl std::error::Error for JsonLinesError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::DiagramBuilder;
    use serde_json::json;

    #[test]
    fn test_simplified_json_lines_parsing() {
        let input = r#"
{"id":"root","type":"box","padding":10,"background":"white","children":["text1"]}
{"id":"text1","type":"text","content":"Hello World","font_size":16,"color":"blue"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        assert_eq!(root_id, "root");

        parser.validate().unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let _diagram = parser.build(&root_id, &mut builder).unwrap();
    }

    #[test]
    fn test_attribute_aliases() {
        // Test that multiple attribute names work for the same concept
        let input = r#"
{"id":"box1","type":"box","padding":5,"background_color":"red","children":["text1"]}
{"id":"text1","type":"text","text":"Using text instead of content","text_color":"white"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_custom_component_access() {
        // Test that custom components get all attributes
        fn test_component(
            attrs: &Map<String, Value>,
            _builder: &mut DiagramBuilder,
        ) -> Result<DiagramTreeNode> {
            // Should be able to access any attribute
            assert!(attrs.contains_key("custom_prop"));
            assert!(attrs.contains_key("width"));
            assert!(attrs.contains_key("background"));

            // Return a dummy node for testing
            Ok(DiagramTreeNode::new(
                EntityType::TextShape,
                "test_component".to_string(),
            ))
        }

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("test_comp", test_component);

        let input = r#"{"id":"test1","type":"test_comp","width":200,"background":"blue","custom_prop":"value"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_streaming_parse() {
        let lines = vec![
            r#"{"id":"e1","type":"text","content":"Hello"}"#.to_string(),
            r#"{"id":"e2","type":"text","content":"World"}"#.to_string(),
            r#"{"id":"e3","type":"hstack","children":["e1","e2"]}"#.to_string(),
        ];

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_lines(lines).unwrap();
        assert_eq!(root_id, "e1");
        parser.validate().unwrap();
    }

    #[test]
    fn test_builder_api() {
        let mut builder = JsonLinesBuilder::new();

        let title = builder.text_styled("title".to_string(), "Document Title", 18.0, "blue");
        let left_text = builder.text("left_text".to_string(), "Left Panel");
        let right_text = builder.text("right_text".to_string(), "Right Panel");

        let left_box = builder.box_with("left_box".to_string(), left_text, 10.0, "lightblue");
        let right_box = builder.box_with("right_box".to_string(), right_text, 10.0, "lightgreen");

        let content = builder.hstack("content".to_string(), vec![left_box, right_box]);
        let footer = builder.text_styled("footer".to_string(), "Footer", 12.0, "gray");

        let _root = builder.vstack("root".to_string(), vec![title, content, footer]);

        let jsonl = builder.build().unwrap();
        println!("Generated JSON Lines:\n{}", jsonl);

        // Parse it back to verify
        let mut parser = JsonLinesParser::new();
        parser.parse_string(&jsonl).unwrap();
        parser.validate().unwrap();
    }

    #[test]
    fn test_complex_attributes() {
        // Test points for polyline
        let input = r#"{"id":"poly1","type":"polyline","points":[[0,0],[10,10],[20,0]],"stroke_color":"red"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_size_behaviors() {
        // Test different size behavior specifications
        let input = r#"
{"id":"box1","type":"box","width":"content","height":100,"children":["text1"]}
{"id":"text1","type":"text","content":"Auto-sized"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }
}

// Example of what an LLM might generate with the new simplified format
pub fn example_llm_generated_jsonl() -> &'static str {
    r#"{"id":"document","type":"box","padding":20,"background":"white","border_color":"gray","children":["layout"]}
{"id":"layout","type":"vstack","children":["header","body","footer"]}
{"id":"header","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"body","type":"hstack","children":["sidebar","main"]}
{"id":"sidebar","type":"box","padding":15,"background":"lightgray","children":["nav"]}
{"id":"nav","type":"vstack","children":["link1","link2","link3"]}
{"id":"link1","type":"text","content":"Home","color":"blue"}
{"id":"link2","type":"text","content":"About","color":"blue"}
{"id":"link3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":15,"background":"white","children":["content"]}
{"id":"content","type":"vstack","children":["article_title","article_body"]}
{"id":"article_title","type":"text","content":"Article Title","font_size":18}
{"id":"article_body","type":"text","content":"This is the main content of the article..."}
{"id":"footer","type":"text","content":"Copyright 2024","font_size":10,"color":"gray"}"#
}

#[cfg(test)]
mod transform_debug_tests {
    use super::*;
    use crate::DiagramBuilder;

    #[test]
    fn test_transform_parsing_debug() {
        println!("🧪 Testing transform parsing...");

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));

        // Create a simple JSON object with rotation
        let mut attributes = serde_json::Map::new();
        attributes.insert(
            "rotation".to_string(),
            serde_json::Value::Number(serde_json::Number::from(45)),
        );
        attributes.insert(
            "width".to_string(),
            serde_json::Value::Number(serde_json::Number::from(60)),
        );
        attributes.insert(
            "height".to_string(),
            serde_json::Value::Number(serde_json::Number::from(40)),
        );

        println!("🔍 Attributes: {:?}", attributes);

        // Test the function directly
        parse_transform_attributes(&attributes, &mut builder, "test_entity".to_string());

        // Check if the transform was applied
        let transform = builder.get_transform("test_entity".to_string());
        println!("📐 Result transform: {:?}", transform);

        // Check if it's not just identity
        let is_identity = transform.matrix[0] == 1.0
            && transform.matrix[1] == 0.0
            && transform.matrix[2] == 0.0
            && transform.matrix[3] == 1.0
            && transform.matrix[4] == 0.0
            && transform.matrix[5] == 0.0;

        println!("❓ Is identity transform: {}", is_identity);
        assert!(
            !is_identity,
            "Transform should not be identity - rotation should be applied!"
        );
    }

    #[test]
    fn test_full_parser_with_rotation() {
        println!("🧪 Testing full parser with rotation...");

        let input = r#"{"id":"test_rect","type":"rect","width":60,"height":40,"background":"red","rotation":45}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));

        let diagram = parser.build(&root_id, &mut builder).unwrap();

        // Check the transform
        let transform = builder.get_transform("test_rect".to_string());
        println!("📐 Full parser result transform: {:?}", transform);

        let is_identity = transform.matrix[0] == 1.0
            && transform.matrix[1] == 0.0
            && transform.matrix[2] == 0.0
            && transform.matrix[3] == 1.0
            && transform.matrix[4] == 0.0
            && transform.matrix[5] == 0.0;

        println!("❓ Full parser - Is identity transform: {}", is_identity);
        assert!(!is_identity, "Full parser should apply rotation!");
    }
}

// Also add this debug function to see what's happening during build_entity calls:
impl JsonLinesParser {
    // Add this method to your existing JsonLinesParser impl
    pub fn debug_build_entity(
        &mut self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode> {
        println!("🏗️ Building entity: {}", entity_id);

        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        println!("🏗️ Entity type: {}", entity.entity_type);
        println!(
            "🏗️ Entity attributes: {:?}",
            entity.attributes.keys().collect::<Vec<_>>()
        );

        // Check if rotation attribute exists
        if let Some(rotation_value) = entity.attributes.get("rotation") {
            println!("🔄 Found rotation attribute: {:?}", rotation_value);
        } else {
            println!("❌ No rotation attribute found");
        }

        // Call the original build_entity
        self.build_entity(entity_id, builder)
    }
}

fn parse_port(attributes: &Map<String, Value>, key: &str) -> Port {
    let port_str = get_string_attr(attributes, &[key], "center");
    match port_str.as_str() {
        "top" => Port::Top,
        "bottom" => Port::Bottom,
        "left" => Port::Left,
        "right" => Port::Right,
        "top_left" | "topleft" => Port::TopLeft,
        "top_right" | "topright" => Port::TopRight,
        "bottom_left" | "bottomleft" => Port::BottomLeft,
        "bottom_right" | "bottomright" => Port::BottomRight,
        _ => Port::Center,
    }
}

===/src/utils.rs===
use crate::components::*;

===/src/diagram_builder.rs===
use std::{collections::HashMap, hash::Hash, rc::Rc, sync::Arc};

/**
 * This object encapsulates diagram creation logic.
 * Usage:
 *```rust
 * let builder = DiagramBuilder::new();
 * let group = builder.new_group(
 *   builder.new_box(builder.new_text("Hello World!"), BoxOptions{fill_color: "white".to_string(), stroke_color: "black".to_string(), stroke_width: 1.0, padding: 10.0, round_corners: false, border_radius: 0.0}),
 * );
 *
 *
 *
 */
//use TextOptions
use crate::{
    components::*, parser::JsonLinesParser, transform::Transform, BoundingBox, ConstraintSystem,
    SimpleConstraint,
};

use anyhow::{bail, Context, Result};

pub struct DiagramBuilder {
    pub measure_text: Option<fn(&str, &TextOptions) -> (Float, Float)>,
    pub entities: Vec<EntityID>,
    // Maps entity IDs to their positions in the container (used in free containers)
    pub container_relative_positions: HashMap<EntityID, Point>,
    pub sizes: HashMap<EntityID, Size>,
    // Maps entity IDS to their transforms for positioning, rotation, scaling, etc.
    pub transforms: HashMap<EntityID, Transform>,
    pub entityTypes: HashMap<EntityID, EntityType>,
    pub absolute_positions: HashMap<EntityID, (Float, Float)>,

    // Components
    points: HashMap<EntityID, PointShape>,
    boxes: HashMap<EntityID, ShapeBox>,
    rectangles: HashMap<EntityID, ShapeRect>,
    groups: HashMap<EntityID, ShapeGroup>,
    texts: HashMap<EntityID, ShapeText>,
    textlines: HashMap<EntityID, TextLine>,
    horizontal_stacks: HashMap<EntityID, HorizontalStack>,
    vertical_stacks: HashMap<EntityID, VerticalStack>,
    ellipses: HashMap<EntityID, ShapeEllipse>,
    lines: HashMap<EntityID, ShapeLine>,
    connectors: HashMap<EntityID, ShapeConnector>,
    arrows: HashMap<EntityID, ShapeArrow>,
    tables: HashMap<EntityID, Table>,
    images: HashMap<EntityID, ShapeImage>,
    polylines: HashMap<EntityID, PolyLine>,
    free_containers: HashMap<EntityID, FreeContainer>,
    constraint_layout_containers: HashMap<EntityID, ConstraintLayoutContainer>,
    constraint_systems: HashMap<EntityID, ConstraintSystem>,
    arcs: HashMap<EntityID, ShapeArc>,
    spacers: HashMap<EntityID, ShapeSpacer>,

    // Items that need to be at root level (e.g connectors)
    pending_root_nodes: Vec<DiagramTreeNode>,
    pub custom_components: CustomComponentRegistry,
}

// Stores the type of entity and the index of the entity in the corresponding vector
// Used when building the diagram tree.
#[derive(Debug, Clone)]
pub struct DiagramTreeNode {
    pub entity_type: EntityType,
    // Index of the entity in the corresponding vector
    pub entity_id: EntityID,
    pub children: Vec<Box<DiagramTreeNode>>,
}

impl DiagramTreeNode {
    pub fn new(entity_type: EntityType, id: EntityID) -> DiagramTreeNode {
        DiagramTreeNode {
            entity_type,
            entity_id: id,
            children: Vec::new(),
        }
    }

    fn add_child(&mut self, child: DiagramTreeNode) {
        self.children.push(Box::new(child));
    }
}

/* New architecture (data driven)
 * We have an array of entities, each entity is an id
 * The id has 64 bits, we can use 32 bits for the type and 32 bits for the index
 * To get the type: id >> 32
 * To get the index: id & 0xFFFFFFFF
 * We have a type enum with all the types
*/

impl DiagramBuilder {
    pub fn new() -> DiagramBuilder {
        DiagramBuilder {
            entityTypes: HashMap::<EntityID, EntityType>::new(),
            measure_text: Some(|_text, _text_options| (0.0, 0.0)),
            entities: Vec::new(),
            // store desired positions relative to the container
            container_relative_positions: HashMap::new(),
            sizes: HashMap::new(),
            transforms: HashMap::new(),
            points: HashMap::new(),
            boxes: HashMap::new(),
            rectangles: HashMap::new(),
            groups: HashMap::new(),
            texts: HashMap::new(),
            textlines: HashMap::new(),
            horizontal_stacks: HashMap::new(),
            vertical_stacks: HashMap::new(),
            ellipses: HashMap::new(),
            lines: HashMap::new(),
            connectors: HashMap::new(),
            arrows: HashMap::new(),
            tables: HashMap::new(),
            images: HashMap::new(),
            polylines: HashMap::new(),
            free_containers: HashMap::new(),
            constraint_layout_containers: HashMap::new(),
            constraint_systems: HashMap::new(),
            arcs: HashMap::new(),
            spacers: HashMap::new(),

            pending_root_nodes: Vec::new(),
            custom_components: CustomComponentRegistry::new(),
            absolute_positions: HashMap::new(),
        }
    }

    /// Register a node to be added at root level (e.g., connectors)
    pub fn register_root_level_node(&mut self, node: DiagramTreeNode) {
        self.pending_root_nodes.push(node);
    }

    /// Take all pending root nodes (clears the list)
    pub fn take_pending_root_nodes(&mut self) -> Vec<DiagramTreeNode> {
        std::mem::take(&mut self.pending_root_nodes)
    }

    pub fn clear_cache(&mut self) {
        // Clear core entity data
        self.entities.clear();
        self.container_relative_positions.clear();
        self.sizes.clear();
        self.entityTypes.clear();

        // Clear all component hashmaps
        self.boxes.clear();
        self.rectangles.clear();
        self.groups.clear();
        self.texts.clear();
        self.textlines.clear();
        self.horizontal_stacks.clear();
        self.vertical_stacks.clear();
        self.ellipses.clear();
        self.lines.clear();
        self.connectors.clear();
        self.arrows.clear();
        self.tables.clear();
        self.images.clear();
        self.polylines.clear();
        self.free_containers.clear();
        self.constraint_layout_containers.clear();
        self.arcs.clear();
        self.constraint_systems.clear();
        self.images.clear();
        self.transforms.clear();
        self.points.clear();
        self.absolute_positions.clear();

        // Note: We don't clear custom_components as those are reusable function definitions
        // Note: We don't clear measure_text function as it should persist across diagrams

        println!("DiagramBuilder cache cleared - all entities and components removed");
    }

    pub fn clear_entities_only(&mut self) {
        self.entities.clear();
        self.sizes.clear();
        self.entityTypes.clear();
        self.container_relative_positions.clear();
        println!("DiagramBuilder entities cleared (components preserved)");
    }

    /// Register a custom component with the builder
    pub fn register_custom_component<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &str,
                &serde_json::Map<String, serde_json::Value>,
                &mut DiagramBuilder,
                &JsonLinesParser,
            ) -> Result<crate::diagram_builder::DiagramTreeNode>
            + Send
            + Sync
            + 'static,
    {
        self.custom_components.register(component_type, factory);
    }

    /// Check if a custom component is registered
    pub fn has_custom_component(&self, component_type: &str) -> bool {
        self.custom_components.has_component(component_type)
    }

    pub fn get_custom_component_types(&self) -> Vec<&String> {
        self.custom_components.get_registered_types()
    }

    pub fn create_custom_component(
        &mut self,
        entity_id: &str,
        component_type: &str,
        attrs: &serde_json::Map<String, serde_json::Value>,
        lines_parser: &JsonLinesParser,
    ) -> Result<DiagramTreeNode> {
        if !self.custom_components.has_component(component_type) {
            bail!("Custom component '{}' not registered", component_type);
        }

        let factory = { self.custom_components.get(component_type).unwrap().clone() };

        factory(entity_id, attrs, self, lines_parser)
    }

    /* Create a new entity of a given type
     * Returns the id of the new entity
     * We have another array with the positions of the entities
     * in the same index. So they are fast to access
     */
    pub fn new_entity(&mut self, id: EntityID, entity_type: EntityType) -> EntityID {
        println!("Creating new entity with id {}", id);
        self.entities.push(id.clone());
        self.sizes.insert(id.clone(), Size::new(0.0, 0.0));
        self.entityTypes.insert(id.clone(), entity_type.clone());
        if !self.transforms.contains_key(&id) {
            self.transforms.insert(id.clone(), Transform::identity());
        }
        id
    }

    //set the measure_text function
    pub fn set_measure_text_fn(&mut self, measure_text: fn(&str, &TextOptions) -> (Float, Float)) {
        println!("Setting measure text function");
        self.measure_text = Option::Some(measure_text);
    }

    // Replace position methods with transform methods
    pub fn get_transform(&self, entity_id: EntityID) -> Transform {
        self.transforms
            .get(&entity_id)
            .cloned()
            .unwrap_or_else(Transform::identity)
    }

    pub fn set_transform(&mut self, entity_id: EntityID, transform: Transform) {
        self.transforms.insert(entity_id, transform);
    }

    // Convenience methods for common operations
    // Get the local position
    pub fn get_local_position(&self, entity_id: EntityID) -> (Float, Float) {
        let transform = self.get_transform(entity_id);
        (transform.matrix[4], transform.matrix[5]) // e, f components
    }

    // pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
    //     let current = self.get_transform(entity_id.clone()).clone();
    //     let translation = Transform::translation(x, y);
    //     // Preserve existing transform but update translation
    //     let mut new_transform = current;
    //     new_transform.matrix[4] = x; // e
    //     new_transform.matrix[5] = y; // f
    //     self.set_transform(entity_id, new_transform);
    // }

    pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        let current = self.get_transform(entity_id.clone());
        // println!(
        //     "📍 set_position called for {} - pos: ({}, {}) - before: {:?}",
        //     entity_id, x, y, current
        // );

        // Preserve existing rotation/scale, just update translation
        let mut new_transform = current;
        new_transform.matrix[4] = x; // e - translation X
        new_transform.matrix[5] = y; // f - translation Y

        // println!(
        //     "📍 set_position result for {} - after: {:?}",
        //     entity_id, new_transform
        // );
        self.set_transform(entity_id, new_transform);
    }

    // Set the position relative to the container  (used in free containers)
    pub fn set_container_relative_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        self.container_relative_positions
            .insert(entity_id, Point::new(x, y));
    }

    pub fn get_container_relative_position(&self, entity_id: &EntityID) -> Point {
        self.container_relative_positions
            .get(entity_id)
            .cloned()
            .unwrap_or(Point::new(0.0, 0.0))
    }

    pub fn set_rotation(&mut self, entity_id: EntityID, angle_degrees: Float) {
        let pos = self.get_local_position(entity_id.clone());
        let size = self.get_size(entity_id.clone());

        // Rotate around center of element
        let center_x = size.0 / 2.0;
        let center_y = size.1 / 2.0;

        let translate_to_origin = Transform::translation(-center_x, -center_y);
        let rotation = Transform::rotation(angle_degrees);
        let translate_back = Transform::translation(center_x, center_y);
        let position = Transform::translation(pos.0, pos.1);

        // FIXED: Correct order - center operations first, then position
        let transform = translate_to_origin
            .combine(&rotation)
            .combine(&translate_back)
            .combine(&position);

        self.set_transform(entity_id, transform);
    }

    pub fn set_scale(&mut self, entity_id: EntityID, sx: Float, sy: Float) {
        let current = self.get_transform(entity_id.clone()).clone();
        let scale = Transform::scale(sx, sy);
        self.set_transform(entity_id, current.combine(&scale));
    }

    // Get effective bounding box considering transform
    pub fn get_effective_bounds(&self, entity_id: EntityID) -> BoundingBox {
        let transform = self.get_transform(entity_id.clone());
        let size = self.get_size(entity_id);
        transform.transform_rect(0.0, 0.0, size.0, size.1)
    }

    //get the size of an entity
    pub fn get_size(&self, entity_id: EntityID) -> (Float, Float) {
        let size = self.sizes.get(&entity_id).unwrap();
        (size.w, size.h)
    }

    pub fn set_size(&mut self, entity_id: EntityID, width: Float, height: Float) {
        println!("getting size {}", entity_id);
        let size = self.sizes.get_mut(&entity_id).unwrap();
        size.w = width;
        size.h = height;
    }

    pub fn new_spacer(&mut self, id: EntityID, options: SpacerOptions) -> DiagramTreeNode {
        let spacer_id = self.new_entity(id, EntityType::SpacerShape);
        let spacer = ShapeSpacer::new(spacer_id.clone(), options);
        self.spacers.insert(spacer_id.clone(), spacer);
        DiagramTreeNode::new(EntityType::SpacerShape, spacer_id)
    }

    /**
     * Architecture note:
     * the new_element methods should only create the necessary elements
     * without calculating the position and size.
     * That will be done in the layout layer.
     */

    // Wraps an element in a box
    pub fn new_box(
        &mut self,
        id: EntityID,
        child: DiagramTreeNode,
        options: BoxOptions,
    ) -> DiagramTreeNode {
        let box_id = self.new_entity(id.clone(), EntityType::BoxShape);

        let sbox = ShapeBox::new(box_id.clone(), child.entity_id.clone(), options);
        self.boxes.insert(box_id.clone(), sbox);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::BoxShape,
            entity_id: box_id.clone(),
            children: Vec::new(),
        };
        node.children.push(Box::new(child.clone()));
        node
    }

    /// Points are useful to create lines when the start or end point is used in a constraint
    pub fn new_point(&mut self, id: EntityID) -> DiagramTreeNode {
        let _ = self.new_entity(id.clone(), EntityType::PointShape);
        let point = PointShape { entity: id.clone() };
        self.points.insert(id.clone(), point);
        let node = DiagramTreeNode {
            entity_type: EntityType::PointShape,
            entity_id: id.clone(),
            children: Vec::new(),
        };
        node
    }

    // Add the new_arc method
    pub fn new_arc(
        &mut self,
        id: EntityID,
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let arc_id = self.new_entity(id, EntityType::ArcShape);
        let arc = ShapeArc::new(arc_id.clone(), radius, start_angle, end_angle, options);
        self.arcs.insert(arc_id.clone(), arc);
        DiagramTreeNode::new(EntityType::ArcShape, arc_id)
    }

    // Add convenience methods for common arc types
    pub fn new_arc_degrees(
        &mut self,
        id: EntityID,
        radius: Float,
        start_degrees: Float,
        end_degrees: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        self.new_arc(id, radius, start_degrees, end_degrees, options)
    }

    pub fn new_semicircle(
        &mut self,
        id: EntityID,
        radius: Float,
        facing_up: bool,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = if facing_up {
            (0.0, 180.0) // Top semicircle
        } else {
            (180.0, 360.0) // Bottom semicircle
        };
        self.new_arc(id, radius, start, end, options)
    }

    pub fn new_quarter_circle(
        &mut self,
        id: EntityID,
        radius: Float,
        quadrant: u8, // 1=top-right, 2=top-left, 3=bottom-left, 4=bottom-right
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = match quadrant {
            1 => (0.0, 90.0),    // Top-right
            2 => (90.0, 180.0),  // Top-left
            3 => (180.0, 270.0), // Bottom-left
            4 => (270.0, 360.0), // Bottom-right
            _ => (0.0, 90.0),    // Default to top-right
        };
        self.new_arc(id, radius, start, end, options)
    }

    // Creates a new Vertical stack.
    pub fn new_vstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        horizontal_alignment: HorizontalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::VerticalStackShape);
        let mut vstack = VerticalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            horizontal_alignment,
        };
        println!("new_vstack id {}", vstack.entity.clone());

        let mut node = DiagramTreeNode {
            entity_type: EntityType::VerticalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            vstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.vertical_stacks.insert(stack_id.clone(), vstack);

        node
    }

    // Creates a new Vertical stack.
    pub fn new_hstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        vertical_alignment: VerticalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::HorizontalStackShape);
        let mut hstack = HorizontalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            vertical_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::HorizontalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            hstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.horizontal_stacks.insert(stack_id, hstack);

        node
    }

    pub fn new_rectangle(&mut self, id: EntityID, options: RectOptions) -> DiagramTreeNode {
        let rect_id = self.new_entity(id.clone(), EntityType::RectShape);
        let rect = ShapeRect::new(rect_id.clone(), options);
        self.rectangles.insert(rect_id.clone(), rect);
        DiagramTreeNode::new(EntityType::RectShape, rect_id.clone())
    }

    // Creates a new Text element
    // text: the text to display
    // options: the options for the text
    // ```rust
    // let text = session.new_text("Hello World", TextOptions::new());
    // ```
    pub fn new_text(&mut self, id: EntityID, text: &str, options: TextOptions) -> DiagramTreeNode {
        let text_id = self.new_entity(id, EntityType::TextShape);
        //create the lines
        let text_lines = textwrap::wrap(&text, options.line_width);
        let lines: Vec<EntityID> = text_lines
            .iter()
            .enumerate()
            .map(|(i, line)| {
                let line_id = format!("text-{}-line-{}", text_id.clone(), i); // Generate a new ID for each line using the index
                self.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line.to_string(),
                };
                self.textlines.insert(line_id.clone(), text_line.clone());
                line_id
            })
            .collect();

        let text = ShapeText::new(text_id.clone(), text, options, &lines);
        self.texts.insert(text_id.clone(), text);
        DiagramTreeNode::new(EntityType::TextShape, text_id)
    }

    pub fn new_line(
        &mut self,
        id: EntityID,
        start: LinePointReference,
        end: LinePointReference,
        options: LineOptions,
    ) -> DiagramTreeNode {
        let line_id = self.new_entity(id, EntityType::LineShape);
        let line = ShapeLine::new(line_id.clone(), start, end, options);
        self.lines.insert(line_id.clone(), line);
        println!("Creating new line with id {}", line_id.clone());
        DiagramTreeNode::new(EntityType::LineShape, line_id)
    }

    

     pub fn new_connector(
        &mut self,
        id: EntityID,
        source_id: EntityID,
        target_id: EntityID,
        options: ConnectorOptions,
    ) -> DiagramTreeNode {
        self.new_entity(id.clone(), EntityType::ConnectorShape);

        // Create start and end points
        let start_point = self.new_point(format!("{}_start", id.clone()));
        let end_point = self.new_point(format!("{}_end", id.clone()));

        let connector = ShapeConnector {
            entity: id.clone(),
            source_id: source_id,
            target_id: target_id,
            start_point_id: start_point.entity_id.clone(),
            end_point_id: end_point.entity_id.clone(),
            label: None,
            options: options,
        };

        self.connectors.insert(id.clone(), connector);

        let mut children = Vec::new();
        children.push(Box::new(start_point.clone()));
        children.push(Box::new(end_point.clone()));

        DiagramTreeNode {
            entity_type: EntityType::ConnectorShape,
            entity_id: id.clone(),
            children: children,
        }
    }

    pub fn new_connector_with_label(
        &mut self,
        id: EntityID,
        source_id: EntityID,
        target_id: EntityID,
        label: String,
        options: ConnectorOptions,
    ) -> DiagramTreeNode {
        self.new_entity(id.clone(), EntityType::ConnectorShape);

        let label_text = self.new_text(format!("{}_label_elem", id), &label, TextOptions::default());
        

        // Create start and end points
        let start_point = self.new_point(format!("{}_start", id.clone()));
        let end_point = self.new_point(format!("{}_end", id.clone()));

        let connector = ShapeConnector {
            entity: id.clone(),
            source_id: source_id,
            target_id: target_id,
            start_point_id: start_point.entity_id.clone(),
            end_point_id: end_point.entity_id.clone(),
            label: Some(label.to_string()),
            options: options,
        };

        self.connectors.insert(id.clone(), connector);

        let mut children = Vec::new();
        children.push(Box::new(start_point.clone()));
        children.push(Box::new(end_point.clone()));

        let con_node = DiagramTreeNode {
            entity_type: EntityType::ConnectorShape,
            entity_id: id.clone(),
            children: children,
        };

        self.new_group(format!("{}_wrapper", id), vec![con_node, label_text])
    }

    pub fn new_ellipse(
        &mut self,
        id: EntityID,
        radius: (Float, Float),
        options: EllipseOptions,
    ) -> DiagramTreeNode {
        let ellipse_id = self.new_entity(id, EntityType::EllipseShape);
        let ellipse = ShapeEllipse::new(ellipse_id.clone(), radius, options);
        self.ellipses.insert(ellipse_id.clone(), ellipse);
        DiagramTreeNode::new(EntityType::EllipseShape, ellipse_id.clone())
    }

    pub fn new_image(
        &mut self,
        id: EntityID,
        image_data: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::new(image_id.clone(), image_data.to_string(), size);
        self.images.insert(image_id.clone(), image);
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    pub fn new_image_from_file(
        &mut self,
        id: EntityID,
        file_path: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::from_file(image_id.clone(), file_path.to_string(), size);
        self.images.insert(image_id.clone(), image.clone());
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    // Creates a new Group.
    pub fn new_group(&mut self, id: EntityID, children: Vec<DiagramTreeNode>) -> DiagramTreeNode {
        let group_id = self.new_entity(id, EntityType::GroupShape);
        let mut sgroup = ShapeGroup {
            entity: group_id.clone(),
            elements: Vec::new(),
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::GroupShape,
            entity_id: group_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            sgroup.elements.push(child.entity_id.clone());
            node.add_child(child.clone())
        }

        self.groups.insert(group_id, sgroup);

        node
    }

    pub fn new_table(
        &mut self,
        id: EntityID,
        cells: Vec<DiagramTreeNode>,
        cols: usize,
        options: TableOptions,
    ) -> DiagramTreeNode {
        let mut cell_ids = Vec::new();
        for cell in &cells {
            cell_ids.push(cell.entity_id.clone());
        }
        //create entities for the col and row lines
        let mut col_lines = Vec::new();
        for i in 0..cols {
            let line_id = format!("{}-col-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(
                line_id.clone(),
                LinePointReference::Value(0.0, 0.0),
                LinePointReference::Value(0.0, 0.0),
                LineOptions {
                    stroke_color: options.border_color.clone(),
                    stroke_width: 1.0,
                },
            );
            self.lines.insert(line_id.clone(), line);
            col_lines.push(line_id.clone());
        }
        let num_rows = cells.len() / cols;
        let mut row_lines = Vec::new();
        for i in 0..num_rows + 1 {
            let line_id = format!("{}-row-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(
                line_id.clone(),
                LinePointReference::Value(0.0, 0.0),
                LinePointReference::Value(0.0, 0.0),
                LineOptions {
                    stroke_color: options.border_color.clone(),
                    stroke_width: 1.0,
                },
            );
            self.lines.insert(line_id.clone(), line);
            row_lines.push(line_id.clone());
        }

        //Add a rectangle for the header row
        let header_id = format!("{}-header", id);
        self.new_entity(header_id.clone(), EntityType::RectShape);
        // Create the rectangle for the header row
        let header = self.new_rectangle(
            header_id.clone(),
            RectOptions {
                fill_color: Fill::Color(options.header_fill_color.clone()),
                stroke_color: options.border_color.clone(),
                stroke_width: 1.0,
                ..Default::default()
            },
        );

        let table_id = format!("{}-table", id.clone());
        self.new_entity(table_id.clone(), EntityType::TableShape);
        let table = Table::new(
            table_id.clone(),
            cell_ids,
            col_lines.clone(),
            row_lines.clone(),
            cols,
            if options.with_header {
                Some(header_id.clone())
            } else {
                None
            },
            options.clone(),
        );

        self.tables.insert(table_id.clone(), table);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::TableShape,
            entity_id: table_id.clone(),
            children: Vec::new(),
        };

        // Add the header before the cells, otherwise it can cover the cells
        if options.with_header {
            node.add_child(DiagramTreeNode::new(
                EntityType::RectShape,
                header_id.clone(),
            ));
        }

        for child in cells {
            node.add_child(child)
        }

        //add the lines
        for line in col_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }
        for line in row_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }

        node
    }

    pub fn new_polyline(
        &mut self,
        id: EntityID,
        points: Vec<(Float, Float)>,
        options: LineOptions,
    ) -> DiagramTreeNode {
        self.new_entity(id.clone(), EntityType::PolyLine);
        let polyline = PolyLine::new(id.clone(), points, options);
        self.polylines.insert(id.clone(), polyline);
        DiagramTreeNode::new(EntityType::PolyLine, id.clone())
    }

    /// Creates a new FreeContainer with all children at once
    pub fn new_free_container(
        &mut self,
        id: EntityID,
        children_with_positions: Vec<(DiagramTreeNode, (Float, Float))>,
    ) -> DiagramTreeNode {
        let container_id = self.new_entity(id.clone(), EntityType::FreeContainer);

        // Create the free container
        let mut container = FreeContainer::new(container_id.clone());

        // Create the node for the tree
        let mut node = DiagramTreeNode {
            entity_type: EntityType::FreeContainer,
            entity_id: container_id.clone(),
            children: Vec::new(),
        };

        // Add all children with their positions
        for (child, position) in children_with_positions {
            container.add_child(child.entity_id.clone(), position);
            node.add_child(child);
        }

        // Store the container
        self.free_containers.insert(container_id.clone(), container);

        node
    }

    /**
     * A constraint layout uses cassowary constraints to calculate some
     * of the positions and sizes of elements.
     * Some elements may contain initial coordinates while others
     * will get their positions from the constrain system solution
     */
    pub fn new_constraint_layout_container(
        &mut self,
        id: EntityID,
        // The children may have relative coordinates set, but may not (when calculated by constraints)
        children: Vec<(DiagramTreeNode, Option<Point>)>,
        constraints: Vec<crate::SimpleConstraint>,
    ) -> DiagramTreeNode {
        // Create container elem
        let id = self.new_entity(id.clone(), EntityType::ConstraintLayoutContainer);
        let children = Rc::new(children);

        let children_ids = children
            .clone()
            .iter()
            .map(|(node, _)| node.entity_id.clone())
            .collect::<Vec<String>>();

        let children_nodes = children
            .clone()
            .iter()
            .map(|(node, _)| Box::new(node.clone()))
            .collect::<Vec<Box<DiagramTreeNode>>>();

        let container = ConstraintLayoutContainer::new(id.clone(), children_ids.clone().to_vec());

        // Setup constraint system

        // register entities in the constrain system and suggest positions
        let mut cs = ConstraintSystem::new();
        for (node, pos) in children.clone().to_vec() {
            if let Err(e) = cs.add_entity(node.entity_id.clone()) {
                eprintln!(
                    "Failed to add entity to constrain system: {}",
                    node.entity_id.clone()
                );
            }
            // suggest position if there's one
            if let Some(p) = pos {
                let _ = cs.suggest_position(&node.entity_id.clone(), p.x, p.y);
            }
        }

        // register constraints
        for constraint in constraints {
            let _ = cs.add_constraint(constraint);
        }

        // Store the constraint system
        self.constraint_systems.insert(id.clone(), cs);
        self.constraint_layout_containers
            .insert(id.clone(), container);

        // Add children to system
        DiagramTreeNode {
            entity_type: EntityType::ConstraintLayoutContainer,
            entity_id: id.clone(),
            children: children_nodes,
        }
    }
}

// element list accessors
impl DiagramBuilder {
    pub fn get_text(&self, id: EntityID) -> &ShapeText {
        &self.texts[&id]
    }

    pub fn add_text(&mut self, id: EntityID, text: ShapeText) {
        self.texts.insert(id, text);
    }

    pub fn get_group(&self, id: EntityID) -> &ShapeGroup {
        &self.groups[&id]
    }

    pub fn get_horizontal_stack(&self, id: EntityID) -> &HorizontalStack {
        &self.horizontal_stacks[&id]
    }

    pub fn get_vertical_stack(&self, id: EntityID) -> &VerticalStack {
        &self.vertical_stacks[&id]
    }

    pub fn get_ellipse(&self, id: EntityID) -> &ShapeEllipse {
        &self.ellipses[&id]
    }

    pub fn get_line(&self, id: EntityID) -> &ShapeLine {
        &self.lines[&id]
    }

    pub fn get_connector(&self, id: EntityID) -> &ShapeConnector {
        &self.connectors[&id]
    }

    pub fn get_line_mut(&mut self, id: EntityID) -> Option<&mut ShapeLine> {
        self.lines.get_mut(&id)
    }

    pub fn get_rectangle(&self, id: EntityID) -> &ShapeRect {
        &self.rectangles[&id]
    }

    pub fn get_text_line(&self, id: EntityID) -> &TextLine {
        &self.textlines[&id]
    }
    pub fn add_text_line(&mut self, id: EntityID, text_line: TextLine) {
        self.textlines.insert(id, text_line);
    }
    pub fn get_text_line_mut(&mut self, id: EntityID) -> Option<&mut TextLine> {
        self.textlines.get_mut(&id)
    }

    pub fn get_arrow(&self, id: EntityID) -> &ShapeArrow {
        &self.arrows[&id]
    }

    pub fn get_table(&self, id: EntityID) -> &Table {
        &self.tables[&id]
    }

    pub fn get_image(&self, id: EntityID) -> &ShapeImage {
        &self.images[&id]
    }

    pub fn get_box(&self, id: EntityID) -> &ShapeBox {
        &self.boxes[&id]
    }

    pub fn get_polyline(&self, id: EntityID) -> &PolyLine {
        &self.polylines[&id]
    }

    pub fn get_free_container(&self, id: EntityID) -> &FreeContainer {
        &self.free_containers[&id]
    }

    pub fn get_free_container_mut(&mut self, id: EntityID) -> &mut FreeContainer {
        self.free_containers.get_mut(&id).unwrap()
    }

    pub fn get_constraint_layout(&self, id: EntityID) -> &ConstraintLayoutContainer {
        &self.constraint_layout_containers[&id]
    }

    pub fn get_constraint_layout_mut(&mut self, id: EntityID) -> &mut ConstraintLayoutContainer {
        self.constraint_layout_containers.get_mut(&id).unwrap()
    }

    pub fn get_constraint_system(&mut self, id: EntityID) -> &ConstraintSystem {
        self.constraint_systems.get(&id).unwrap()
    }

    pub fn get_constraint_system_mut(&mut self, id: EntityID) -> &mut ConstraintSystem {
        self.constraint_systems.get_mut(&id).unwrap()
    }

    pub fn get_arc(&self, id: EntityID) -> &ShapeArc {
        &self.arcs[&id]
    }

    pub fn get_spacer(&self, id: EntityID) -> &ShapeSpacer {
        &self.spacers[&id]
    }

    /// Get the position of a specific port on an element
    pub fn get_port_position(&self, entity_id: &EntityID, port: &Port) -> (Float, Float) {
    let size = self.get_size(entity_id.clone());

    // Get absolute position (for elements with rotation, this includes the transform)
    let absolute_pos = self
        .absolute_positions
        .get(entity_id)
        .copied()
        .unwrap_or_else(|| {
            println!("⚠️  WARNING: No absolute position cached for {}", entity_id);
            self.get_local_position(entity_id.clone())
        });

    // Calculate port offset based on size
    let (offset_x, offset_y) = match port {
        Port::Center => (size.0 / 2.0, size.1 / 2.0),
        Port::Top => (size.0 / 2.0, 0.0),
        Port::Bottom => (size.0 / 2.0, size.1),
        Port::Left => (0.0, size.1 / 2.0),
        Port::Right => (size.0, size.1 / 2.0),
        Port::TopLeft => (0.0, 0.0),
        Port::TopRight => (size.0, 0.0),
        Port::BottomLeft => (0.0, size.1),
        Port::BottomRight => (size.0, size.1),
    };

    // ADD THIS DEBUG LINE:
    println!("  🔌 Port {:?} on {} (size {:.1}x{:.1}): absolute_pos=({:.1},{:.1}), offset=({:.1},{:.1})", 
             port, entity_id, size.0, size.1, absolute_pos.0, absolute_pos.1, offset_x, offset_y);

    // For rotated elements, we'd need to transform the port offset
    // through the element's rotation transform here
    let transform = self.get_transform(entity_id.clone());
    let rotation_scale_transform = Transform {
        matrix: [
            transform.matrix[0], // a (scale/rotation)
            transform.matrix[1], // b (rotation)
            transform.matrix[2], // c (rotation)
            transform.matrix[3], // d (scale/rotation)
            0.0,                 // no translation
            0.0,
        ],
    };

    let transformed_offset = rotation_scale_transform.transform_point(offset_x, offset_y);

    println!("     After transform: offset=({:.1},{:.1}), final=({:.1},{:.1})",
             transformed_offset.0, transformed_offset.1,
             absolute_pos.0 + transformed_offset.0,
             absolute_pos.1 + transformed_offset.1);

    (
        absolute_pos.0 + transformed_offset.0,
        absolute_pos.1 + transformed_offset.1,
    )
}

    pub fn get_absolute_center(&self, entity_id: &EntityID) -> (Float, Float) {
        let size = self.get_size(entity_id.clone());

        // Local center point (relative to element's origin)
        let local_center = (size.0 / 2.0, size.1 / 2.0);

        // Get the transform for this element
        let transform = self.get_transform(entity_id.clone());

        // Use cached absolute position
        let absolute_pos = self
            .absolute_positions
            .get(entity_id)
            .copied()
            .unwrap_or_else(|| {
                println!(
                    "⚠️  WARNING: No absolute position cached for {}, using local position",
                    entity_id
                );
                // Fallback to local position (won't be correct for nested elements)
                self.get_local_position(entity_id.clone())
            });

        // For elements with rotation/scale, we need to transform the center point
        // Extract just rotation/scale (no translation) from the transform
        let rotation_scale_transform = Transform {
            matrix: [
                transform.matrix[0], // a (scale/rotation)
                transform.matrix[1], // b (rotation)
                transform.matrix[2], // c (rotation)
                transform.matrix[3], // d (scale/rotation)
                0.0,                 // e (no translation)
                0.0,                 // f (no translation)
            ],
        };

        // Transform the local center through rotation/scale
        let transformed_center =
            rotation_scale_transform.transform_point(local_center.0, local_center.1);

        // Add to absolute position
        (
            absolute_pos.0 + transformed_center.0,
            absolute_pos.1 + transformed_center.1,
        )
    }

    pub fn add_to_pending_nodes(&mut self, elem: DiagramTreeNode) {
        self.pending_root_nodes.push(elem);
    }

    pub fn get_custom_component(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &str,
                    &serde_json::Map<String, serde_json::Value>,
                    &mut DiagramBuilder,
                    &JsonLinesParser,
                ) -> Result<DiagramTreeNode>
                + Send
                + Sync,
        >,
    > {
        self.custom_components.get(component_type)
    }
}

//test
#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_session() {
        let mut session = DiagramBuilder::new();

        session.set_measure_text_fn(|text, text_options| {
            let textW: Float = text.len() as Float * text_options.font_size as Float;

            (textW, text_options.font_size.into())
        });
        let (w, h) = session.measure_text.unwrap()(
            "hello",
            &TextOptions {
                font_size: 12.0,
                ..Default::default()
            },
        );
        assert_eq!(w, 60.0);
        assert_eq!(h, 12.0);
    }
}

//Component registration tests
#[cfg(test)]
mod component_registration_tests {
    use serde_json::{json, Map, Value};

    use super::*;

    /// Custom Component 1: Badge
    /// Creates a rounded pill-shaped element with text
    fn create_badge_component(
        id: &str,
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
        parser: &JsonLinesParser,
    ) -> Result<DiagramTreeNode> {
        println!("🏷️  Creating badge component with attrs: {:?}", attrs);

        // Extract attributes
        let text = get_string_attr(attrs, "text", "Badge");
        let background = get_string_attr(attrs, "background", "blue");
        let color = get_string_attr(attrs, "color", "white");
        let font_size = get_float_attr(attrs, "font_size", 12.0);
        let padding = get_float_attr(attrs, "padding", 8.0);

        // Create text element
        let text_options = TextOptions {
            font_family: "Arial".to_string(),
            font_size,
            text_color: color,
            line_width: 200,
            line_spacing: 0.0,
            ..Default::default()
        };
        let text_node = builder.new_text("text".to_string(), &text, text_options);

        // Wrap in rounded box
        let box_options = BoxOptions {
            fill_color: Fill::Color(background),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            padding,
            border_radius: font_size,               // Make it pill-shaped
            width_behavior: SizeBehavior::Content,  // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
            ..Default::default()
        };
        let badge = builder.new_box("container".to_string(), text_node, box_options);

        println!("✅ Badge '{}' created successfully", text);
        Ok(badge)
    }

    // Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
    fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let parser = JsonLinesParser::new();

        let result = builder.create_custom_component("b1", "badge", &attrs, &parser);
        assert!(result.is_ok());
        let badge_node = result.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::BoxShape);
        assert!(builder.has_custom_component("badge"));
        let badge = builder.get_box(badge_node.entity_id);
        assert_eq!(
            badge.box_options.fill_color,
            Fill::Color("blue".to_string())
        );
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 1);
        assert!(builder.has_custom_component("badge"));
    }
}

