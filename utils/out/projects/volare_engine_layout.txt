===/Cargo.toml===
[package]
name = "volare_engine_layout"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.2"

===/Cargo.lock===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "layout-base"
version = "0.1.0"

===/docs/JSONL Diagram Specification.md===
# JSONL Diagram Specification
v1.0

This specification describes the JSON Lines format for creating diagrams using the Volare Layout Engine. Each line in a JSONL file represents a single entity with its properties.

## Basic Structure

Each entity follows this format:
```json
{"id": "unique_id", "type": "entity_type", "attribute1": "value1", "attribute2": "value2"}
```

## Core Entity Types

### Text (`"type": "text"`)
Renders text content with styling options.

**Required Attributes:**
- `content` or `text` - The text to display

**Optional Attributes:**
- `font_size` (number) - Font size in pixels (default: 12)
- `color` or `text_color` (string) - Text color (default: "black")
- `font_family` (string) - Font family name (default: "Arial")
- `line_width` (number) - Maximum characters per line for wrapping (default: 200)
- `line_spacing` (number) - Space between lines (default: 0)

**Example:**
```json
{"id":"title","type":"text","content":"Hello World","font_size":24,"color":"blue"}
```

### Box (`"type": "box"`)
Wraps another element with padding, background, and border.

**Required Attributes:**
- `children` (array) - Array with exactly one child element ID

**Optional Attributes:**
- `padding` (number) - Inner padding (default: 0)
- `background`, `background_color`, or `fill` (string) - Background color (default: "white")
- `border_color` or `stroke_color` (string) - Border color (default: "black")
- `border_width` or `stroke_width` (number) - Border thickness (default: 1)
- `border_radius` (number) - Corner radius for rounded corners (default: 0)
- `width` (number or string) - Width behavior: number for fixed, "content" for auto, "grow" for fill
- `height` (number or string) - Height behavior: number for fixed, "content" for auto, "grow" for fill

**Example:**
```json
{"id":"container","type":"box","padding":10,"background":"lightblue","children":["text1"]}
```


**Automatic Text Wrapping:**
When a box has a fixed width and contains text, the text will automatically wrap to fit within the available space (box width minus padding). This ensures text never overflows the box boundaries.

## Best Practices

### Text Layout
- **Use fixed-width boxes** for consistent layouts - text will automatically wrap to fit
- **Let height be content-based** for boxes containing text to accommodate wrapped content
- **Use padding** to ensure proper text spacing from box edges
- **Disable auto-wrapping** only when you need precise control over line breaks

### Responsive Design
- Fixed-width boxes with auto-wrapping text create predictable, responsive layouts
- Combine with different padding values for various spacing needs
- Stack multiple auto-wrapping boxes for article-like layouts
**Example:**
```json
{"id":"container","type":"box","width":400,"padding":20,"children":["long_text"]}
{"id":"long_text","type":"text","content":"This long text will automatically wrap to fit within the 400px box width"}

### Rectangle (`"type": "rect"`)
A standalone rectangle shape.

**Optional Attributes:**
- `width` (number or string) - Width (default: 100)
- `height` (number or string) - Height (default: 100)
- `background`, `background_color`, or `fill` (string) - Fill color (default: "white")
- `border_color` or `stroke_color` (string) - Border color (default: "black")
- `border_width` or `stroke_width` (number) - Border thickness (default: 1)
- `border_radius` (number) - Corner radius (default: 0)

**Example:**
```json
{"id":"rect1","type":"rect","width":150,"height":100,"background":"red"}
```

### Vertical Stack (`"type": "vstack"`)
Arranges children vertically.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Optional Attributes:**
- `h_align` or `horizontal_alignment` (string) - Horizontal alignment: "left", "center", "right" (default: "center")

**Example:**
```json
{"id":"stack","type":"vstack","children":["item1","item2","item3"],"h_align":"left"}
```

### Horizontal Stack (`"type": "hstack"`)
Arranges children horizontally.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Optional Attributes:**
- `v_align` or `vertical_alignment` (string) - Vertical alignment: "top", "center", "bottom" (default: "center")

**Example:**
```json
{"id":"row","type":"hstack","children":["col1","col2","col3"],"v_align":"top"}
```

### Group (`"type": "group"`)
Groups elements together without layout constraints.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Example:**
```json
{"id":"group1","type":"group","children":["elem1","elem2"]}
```

## Shape Types

### Line (`"type": "line"`)
Draws a straight line between two points.

**Required Attributes:**
- `start_x` or `x1` (number) - Starting X coordinate
- `start_y` or `y1` (number) - Starting Y coordinate
- `end_x` or `x2` (number) - Ending X coordinate
- `end_y` or `y2` (number) - Ending Y coordinate

**Optional Attributes:**
- `stroke_color` or `color` (string) - Line color (default: "black")
- `stroke_width` (number) - Line thickness (default: 1)

**Example:**
```json
{"id":"line1","type":"line","start_x":0,"start_y":0,"end_x":100,"end_y":50,"stroke_color":"blue"}
```

### Ellipse (`"type": "ellipse"`)
Draws an ellipse or circle.

**Required Attributes:**
- `cx` or `center_x` (number) - Center X coordinate
- `cy` or `center_y` (number) - Center Y coordinate
- `rx` or `radius_x` (number) - Horizontal radius
- `ry` or `radius_y` (number) - Vertical radius

**Optional Attributes:**
- `fill`, `fill_color`, or `background` (string) - Fill color (default: "white")
- `stroke`, `stroke_color`, or `border_color` (string) - Border color (default: "black")
- `stroke_width` or `border_width` (number) - Border thickness (default: 1)

**Example:**
```json
{"id":"circle","type":"ellipse","cx":50,"cy":50,"rx":25,"ry":25,"fill":"yellow"}
```

### Arc (`"type": "arc"`)
Draws an arc segment.

**Required Attributes:**
- `cx` or `center_x` (number) - Center X coordinate
- `cy` or `center_y` (number) - Center Y coordinate
- `radius` or `r` (number) - Arc radius
- `start_angle` or `start` (number) - Start angle in degrees
- `end_angle` or `end` (number) - End angle in degrees

**Optional Attributes:**
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the arc sector (default: false)

**Example:**
```json
{"id":"arc1","type":"arc","cx":100,"cy":100,"radius":50,"start_angle":0,"end_angle":90,"stroke_color":"red","filled":true}
```

### Semicircle (`"type": "semicircle"`)
Draws a semicircle (180Â° arc).

**Required Attributes:**
- `cx` or `center_x` (number) - Center X coordinate
- `cy` or `center_y` (number) - Center Y coordinate
- `radius` or `r` (number) - Semicircle radius

**Optional Attributes:**
- `facing_up` or `up` (boolean) - True for top semicircle, false for bottom (default: true)
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the semicircle (default: false)

**Example:**
```json
{"id":"semi1","type":"semicircle","cx":100,"cy":100,"radius":40,"facing_up":false,"fill":"green"}
```

### Quarter Circle (`"type": "quarter_circle"`)
Draws a quarter circle (90Â° arc).

**Required Attributes:**
- `cx` or `center_x` (number) - Center X coordinate
- `cy` or `center_y` (number) - Center Y coordinate
- `radius` or `r` (number) - Quarter circle radius
- `quadrant` (number) - Quadrant: 1=top-right, 2=top-left, 3=bottom-left, 4=bottom-right

**Optional Attributes:**
- `fill` or `fill_color` (string) - Fill color (default: "none")
- `stroke` or `stroke_color` (string) - Stroke color (default: "black")
- `stroke_width` (number) - Stroke thickness (default: 1)
- `filled` (boolean) - Whether to fill the quarter circle (default: false)

**Example:**
```json
{"id":"quarter1","type":"quarter_circle","cx":50,"cy":50,"radius":30,"quadrant":1,"fill":"orange"}
```

### Polyline (`"type": "polyline"`)
Draws connected line segments.

**Required Attributes:**
- `points` (array) - Array of [x, y] coordinate pairs

**Optional Attributes:**
- `stroke_color` or `color` (string) - Line color (default: "black")
- `stroke_width` (number) - Line thickness (default: 1)

**Example:**
```json
{"id":"poly1","type":"polyline","points":[[0,0],[50,25],[100,0],[150,50]],"stroke_color":"purple"}
```

## Container Types

### Table (`"type": "table"`)
Arranges children in a grid layout.

**Required Attributes:**
- `children` (array) - Array of cell element IDs
- `cols` or `columns` (number) - Number of columns

**Optional Attributes:**
- `header_fill_color` or `header_background` (string) - Header row background (default: "lightgray")
- `fill_color` or `background` (string) - Table background (default: "white")
- `border_color` (string) - Border color (default: "black")
- `border_width` (number) - Border thickness (default: 1)
- `cell_padding` or `padding` (number) - Cell padding (default: 20)

**Example:**
```json
{"id":"table1","type":"table","children":["cell1","cell2","cell3","cell4"],"cols":2,"cell_padding":15}
```

### Free Container (`"type": "free_container"`)
Allows absolute positioning of children.

**Required Attributes:**
- `children` (array) - Array of child element IDs

**Child Positioning:**
Each child element should have `x` and `y` attributes for positioning within the container.

**Optional Container Attributes:**
- `width` (number) - Container width
- `height` (number) - Container height
- `background` or `background_color` (string) - Background color
- `border_color` (string) - Border color
- `border_width` (number) - Border thickness

**Example:**
```json
{"id":"container","type":"free_container","width":400,"height":300,"children":["item1","item2"]}
{"id":"item1","type":"text","content":"Positioned Text","x":50,"y":100}
{"id":"item2","type":"rect","width":60,"height":40,"background":"blue","x":200,"y":150}
```

## Media Types

### Image (`"type": "image"`)
Displays an image from file or base64 data.

**Required Attributes:**
- `src` (string) - Base64 image data, OR
- `file_path` (string) - Path to image file

**Optional Attributes:**
- `width` (number or string) - Image width
- `height` (number or string) - Image height

**Example:**
```json
{"id":"img1","type":"image","file_path":"assets/logo.png","width":200,"height":150}
```

## Size Behaviors

For `width` and `height` attributes, you can use:

- **Number** - Fixed size in pixels: `"width": 200`
- **"content"** or **"auto"** - Size based on content: `"width": "content"`
- **"grow"** - Take all available space: `"width": "grow"` (TODO: Not currently supported)

**Note:** When using fixed width with text content, automatic text wrapping ensures optimal text layout within the specified constraints.

## Color Values

Colors can be specified as:
- Named colors: `"red"`, `"blue"`, `"lightgray"`
- Hex colors: `"#FF0000"`, `"#0066CC"`
- RGB colors: `"rgb(255,0,0)"`

## Custom Components

The system supports custom components registered by the application. These components can accept any attributes defined by their implementation.

## Complete Example

```json
{"id":"root","type":"vstack","children":["header","content","footer"],"h_align":"center"}
{"id":"header","type":"box","padding":15,"background":"#f0f0f0","children":["title"]}
{"id":"title","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"content","type":"hstack","children":["sidebar","main"],"v_align":"top"}
{"id":"sidebar","type":"vstack","children":["nav1","nav2","nav3"],"h_align":"left"}
{"id":"nav1","type":"text","content":"Home","color":"blue"}
{"id":"nav2","type":"text","content":"About","color":"blue"}
{"id":"nav3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":20,"background":"white","children":["article"]}
{"id":"article","type":"text","content":"This is the main content area with longer text that will wrap to multiple lines.","line_width":300}
{"id":"footer","type":"text","content":"Â© 2024 My Company","font_size":10,"color":"gray"}
```

This creates a document layout with header, sidebar navigation, main content area, and footer.

## Best Practices

### Text Layout
- **Use fixed-width boxes** for consistent layouts - text will automatically wrap to fit
- **Let height be content-based** for boxes containing text to accommodate wrapped content
- **Use padding** to ensure proper text spacing from box edges
- **Disable auto-wrapping** only when you need precise control over line breaks

### Responsive Design
- Fixed-width boxes with auto-wrapping text create predictable, responsive layouts
- Combine with different padding values for various spacing needs
- Stack multiple auto-wrapping boxes for article-like layouts
===/.gitignore===
/target
/Cargo.lock

===/.github/workflows/test-and-build.yml===
# test rust project and build

name: Test and Build

on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test
      - name: Build
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release





===/src/layout.rs===
/* Layout calculation for each type of entity */

use crate::components::Float;
use crate::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, FreeContainer,
    HorizontalStack, PolyLine, ShapeArrow, ShapeBox, ShapeEllipse, ShapeGroup, ShapeImage,
    ShapeLine, ShapeText, Table, VerticalStack,
};
use crate::{
    HorizontalAlignment, ShapeArc, ShapeRect, ShapeSpacer, SizeBehavior, SpacerDirection, TextLine,
    VerticalAlignment,
};

use crate::transform::Transform;

/* The box layout includes the padding and the dimensions
of the wrapped element
The wrapped element position and size should be updated before calling this function
(except for grow behavior).
The wrapped element position is relative to the box position.
*/
pub fn layout_box(session: &mut DiagramBuilder, shape_box: &ShapeBox) {
    println!("Box: {:?}", shape_box);

    // Get the wrapped element dimensions
    let mut wrapped_elem_bounds = session.get_effective_bounds(shape_box.wrapped_entity.clone());

    // Calculate the box dimensions based on size behavior
    let box_width = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(width) => {
            // For fixed width, use the specified width
            width
        }
        SizeBehavior::Content => {
            // Content sizing - size based on wrapped element + padding
            wrapped_elem_bounds.width + shape_box.box_options.padding * 2.0
        }
        SizeBehavior::Grow => {
            // TODO: Implement grow behavior in future iterations
            // For now, fall back to content behavior
            wrapped_elem_bounds.width + shape_box.box_options.padding * 2.0
        }
    };

    // Auto-wrap text if box has fixed width (do this BEFORE positioning)
    if let SizeBehavior::Fixed(fixed_width) = shape_box.box_options.width_behavior {
        let wrapped_entity_type = session.entityTypes.get(&shape_box.wrapped_entity);
        if let Some(EntityType::TextShape) = wrapped_entity_type {
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            auto_wrap_text_in_box(session, &shape_box.wrapped_entity, available_width);
            // Re-get bounds after text wrapping
            wrapped_elem_bounds = session.get_effective_bounds(shape_box.wrapped_entity.clone());
        }
    }

    // Calculate the box height (after potential text wrapping)
    let box_height = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(height) => height,
        SizeBehavior::Content => {
            wrapped_elem_bounds.height + shape_box.box_options.padding * 2.0
        }
        SizeBehavior::Grow => {
            wrapped_elem_bounds.height + shape_box.box_options.padding * 2.0
        }
    };

    // Calculate where we want the wrapped element's bounding box to be positioned
    let desired_content_x = match shape_box.box_options.width_behavior {
        SizeBehavior::Fixed(fixed_width) => {
            let available_width = fixed_width - shape_box.box_options.padding * 2.0;
            if wrapped_elem_bounds.width <= available_width {
                // Center the content bounding box
                shape_box.box_options.padding + (available_width - wrapped_elem_bounds.width) / 2.0
            } else {
                // Content is larger than available space, align bounding box to left edge
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, position bounding box at padding
            shape_box.box_options.padding
        }
    };

    let desired_content_y = match shape_box.box_options.height_behavior {
        SizeBehavior::Fixed(fixed_height) => {
            let available_height = fixed_height - shape_box.box_options.padding * 2.0;
            if wrapped_elem_bounds.height <= available_height {
                // Center the content bounding box
                shape_box.box_options.padding + (available_height - wrapped_elem_bounds.height) / 2.0
            } else {
                // Content is larger than available space, align bounding box to top edge
                shape_box.box_options.padding
            }
        }
        _ => {
            // For content and grow behaviors, position bounding box at padding
            shape_box.box_options.padding
        }
    };

    // FIXED: Apply bounding box compensation when positioning the wrapped element
    let transform_x = desired_content_x - wrapped_elem_bounds.x;
    let transform_y = desired_content_y - wrapped_elem_bounds.y;
    
    session.set_position(shape_box.wrapped_entity.clone(), transform_x, transform_y);

    println!(
        "Box: {}, width: {}, height: {}, padding: {}, content positioned at: ({}, {})",
        shape_box.entity, box_width, box_height, shape_box.box_options.padding, transform_x, transform_y
    );

    // Set the box dimensions
    session.set_size(shape_box.entity.clone(), box_width, box_height);
}


fn calculate_optimal_line_width(
    session: &DiagramBuilder,
    text: &str,
    text_options: &TextOptions,
    available_width: Float,
) -> usize {
    // Binary search for optimal line_width
    let mut min_width = 10;
    let mut max_width = text.len();
    let mut best_width = min_width;

    while min_width <= max_width {
        let mid_width = (min_width + max_width) / 2;

        // Test this line_width
        let mut test_options = text_options.clone();
        test_options.line_width = mid_width;

        let wrapped_lines = textwrap::wrap(text, mid_width);
        if wrapped_lines.is_empty() {
            break;
        }

        // Measure the widest line
        let max_line_width = wrapped_lines
            .iter()
            .map(|line| session.measure_text.unwrap()(line, &test_options).0)
            .fold(0.0f32, |a, b| a.max(b));

        if max_line_width <= available_width {
            best_width = mid_width;
            min_width = mid_width + 1; // Try wider
        } else {
            max_width = mid_width - 1; // Try narrower
        }
    }

    best_width
}

// Add this function to layout.rs
fn auto_wrap_text_in_box(
    session: &mut DiagramBuilder,
    text_entity_id: &EntityID,
    available_width: Float,
) {
    // Get the current text shape
    let text_shape = session.get_text(text_entity_id.clone()).clone();

    // Calculate optimal line_width using actual text measurement
    let new_line_width = calculate_optimal_line_width(
        session,
        &text_shape.text,
        &text_shape.text_options,
        available_width,
    );
    // Only re-layout if line_width changed significantly
    if (new_line_width as i32 - text_shape.text_options.line_width as i32).abs() > 5 {
        // Create new text options with updated line_width
        let mut new_text_options = text_shape.text_options.clone();
        new_text_options.line_width = new_line_width;

        // Re-create text lines with new wrapping
        let text_lines = textwrap::wrap(&text_shape.text, new_line_width);
        let mut new_lines = Vec::new();

        // Update existing lines or create new ones
        for (i, line_text) in text_lines.iter().enumerate() {
            let line_id = if i < text_shape.lines.len() {
                // Reuse existing line
                let existing_line_id = text_shape.lines[i].clone();
                let existing_line = session.get_text_line_mut(existing_line_id.clone());
                if let Some(existing_line) = existing_line {
                    existing_line.text = line_text.to_string();
                } else {
                    println!(
                        "Warning: Text line ID {} not found in session",
                        existing_line_id
                    );
                    continue;
                }
                existing_line_id
            } else {
                // Create new line
                // Note: here we are creating new elements on layout
                let line_id = format!("{}-autowrap-line-{}", text_entity_id, i);
                session.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line_text.to_string(),
                };
                session.add_text_line(line_id.clone(), text_line);
                line_id
            };
            new_lines.push(line_id);
        }

        // Update the text shape with new options and lines
        let updated_text_shape = ShapeText {
            entity: text_shape.entity.clone(),
            text: text_shape.text.clone(),
            text_options: new_text_options,
            lines: new_lines,
        };

        // Update the session with the new text shape
        session.add_text(text_entity_id.clone(), updated_text_shape.clone());

        // Re-layout the text with new dimensions
        layout_text(session, &updated_text_shape);
    }
}

// Helper function to estimate character width based on font
fn estimate_char_width(text_options: &TextOptions) -> Float {
    // Rough estimation: font_size * 0.6 for typical fonts
    // You could make this more sophisticated based on font_family
    text_options.font_size * 0.6
}

/**
 * Update the group size based on the size of the elements.
 * Group elements must be positioned before calling this function.
 * (Doesn't update the position of the elements)
 */

pub fn layout_group(session: &mut DiagramBuilder, shape_group: &ShapeGroup) {
    // Calculate actual bounding box using positions, not just max dimensions
    let mut min_x = Float::INFINITY;
    let mut min_y = Float::INFINITY;
    let mut max_x = Float::NEG_INFINITY;
    let mut max_y = Float::NEG_INFINITY;

    for elem in shape_group.elements.iter() {
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let elem_pos = session.get_position(elem.clone()); // Uses transforms behind the scenes

        min_x = min_x.min(elem_pos.0);
        min_y = min_y.min(elem_pos.1);
        max_x = max_x.max(elem_pos.0 + elem_bounds.width);
        max_y = max_y.max(elem_pos.1 + elem_bounds.height);
    }

    if min_x != Float::INFINITY {
        let width = max_x - min_x;
        let height = max_y - min_y;
        session.set_size(shape_group.entity.clone(), width, height);

        // use bounding box compensation since set_position works with transform origins
        let group_bounds = session.get_effective_bounds(shape_group.entity.clone());
        let transform_x = min_x - group_bounds.x;
        let transform_y = min_y - group_bounds.y;
        session.set_position(shape_group.entity.clone(), transform_x, transform_y);
    } else {
        session.set_size(shape_group.entity.clone(), 0.0, 0.0);
        session.set_position(shape_group.entity.clone(), 0.0, 0.0);
    }
}

// WHY this function doesn't need the bounding box compensation:
// 
// 1. Text lines don't have individual rotations - they're just positioned within the text entity
// 2. The rotation transform is applied to the parent text entity as a whole
// 3. Individual lines are positioned relative to (0,0) within the text entity
// 4. When the text entity is rotated, all lines rotate together as one unit
//
// Transform hierarchy:
// Text Entity (has rotation transform)
//   â””â”€â”€ Line 1 (positioned at 0, 0 relative to text entity)
//   â””â”€â”€ Line 2 (positioned at 0, 16 relative to text entity)  
//   â””â”€â”€ Line 3 (positioned at 0, 32 relative to text entity)
pub fn layout_text(session: &mut DiagramBuilder, shape_text: &ShapeText) {
    let mut y = 0.0;
    let mut max_line_width = 0.0;

    for (i, line) in shape_text.lines.iter().enumerate() {
        let textLine = session.get_text_line(line.clone());
        let line_size = session.measure_text.unwrap()(&textLine.text, &shape_text.text_options);

        if line_size.0 > max_line_width {
            max_line_width = line_size.0;
        }

        session.set_position(line.clone(), 0.0, y);
        session.set_size(line.clone(), line_size.0, line_size.1);

        // Add line height
        y += line_size.1;

        // Add line spacing ONLY between lines (not after the last line)
        if i < shape_text.lines.len() - 1 {
            y += shape_text.text_options.line_spacing;
        }
    }

    // No need to subtract line spacing at the end
    session.set_size(shape_text.entity.clone(), max_line_width, y);
}

pub fn layout_spacer(session: &mut DiagramBuilder, spacer: &ShapeSpacer) {
    let (width, height) = match spacer.spacer_options.direction {
        SpacerDirection::Horizontal => (spacer.spacer_options.width, 1.0),
        SpacerDirection::Vertical => (1.0, spacer.spacer_options.height),
        SpacerDirection::Both => (spacer.spacer_options.width, spacer.spacer_options.height),
    };

    session.set_size(spacer.entity.clone(), width, height);
}

/**
 * Updates the size of the line entity based on the start and end points
 */
pub fn layout_line(session: &mut DiagramBuilder, shape_line: &ShapeLine) {
    let start = shape_line.start;
    let end = shape_line.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_line.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_line.entity.clone(), x, y);
}

/**
 * Updates the size of the arrow entity based on the start and end points
 */
pub fn layout_arrow(session: &mut DiagramBuilder, shape_arrow: &ShapeArrow) {
    let start = shape_arrow.start;
    let end = shape_arrow.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_arrow.entity.clone(),
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_arrow.entity.clone(), x, y);
}

/**
 * Updates the size of the ellipse entity based on the horizontal and vertical radius
 * radius.0 is the horizontal radius and radius.1 is the vertical radius
 * The position of the ellipse is the top left corner of the bounding box
 */
pub fn layout_ellipse(session: &mut DiagramBuilder, shape_ellipse: &ShapeEllipse) {
    // Only set the size based on radius
    let width = shape_ellipse.radius.0 * 2.0;
    let height = shape_ellipse.radius.1 * 2.0;
    session.set_size(shape_ellipse.entity.clone(), width, height);
}

pub fn layout_rect(session: &mut DiagramBuilder, rect: &ShapeRect) {
    // If the rect has a fixed size, use that
    let width = match rect.rect_options.width_behavior {
        SizeBehavior::Fixed(w) => w,
        _ => 0.0,
    };
    let height = match rect.rect_options.height_behavior {
        SizeBehavior::Fixed(h) => h,
        _ => 0.0,
    };

    session.set_size(rect.entity.clone(), width, height);
}

/**
 * Sets the image entity size to the preferred size
 */
pub fn layout_image(session: &mut DiagramBuilder, shape_image: &ShapeImage) {
    let width = match shape_image.width_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0,
    };

    let height = match shape_image.height_behavior {
        SizeBehavior::Fixed(val) => val,
        SizeBehavior::Content => 100.0, // TODO: Obtener size de la data de la imagen
        _ => 100.0,
    };

    session.set_size(shape_image.entity.clone(), width, height);
}
/**
 * Updates the position of the elements in the vertical stack
 * and the size of the vertical stack
 */
pub fn layout_vertical_stack(session: &mut DiagramBuilder, vertical_stack: &VerticalStack) {
    let mut logical_y = 0.0; // Where we want each element's bounding box to start
    let mut width = 0.0;
    
    for elem in vertical_stack.elements.iter() {
        println!("DEBUG:::y: {}", logical_y);
        let elem_bounds = session.get_effective_bounds(elem.clone());

        // FIXED: Position the element so its bounding box starts at logical_y
        let transform_y = logical_y - elem_bounds.y;
        session.set_position(elem.clone(), 0.0, transform_y);
        
        // FIXED: Add the effective height to logical_y for next element
        logical_y += elem_bounds.height;
        
        if elem_bounds.width > width {
            width = elem_bounds.width;
        }
    }
    
    // Set the stack size to the total logical height
    session.set_size(vertical_stack.entity.clone(), width, logical_y);

    // Second pass: adjust x positions for horizontal alignment
    for elem in vertical_stack.elements.iter() {
        // FIXED: Use effective bounds consistently for alignment calculations
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let current_pos = session.get_position(elem.clone());
        
        let x = match vertical_stack.horizontal_alignment {
            HorizontalAlignment::Left => -elem_bounds.x, // Compensate for bounding box offset
            HorizontalAlignment::Center => (width - elem_bounds.width) / 2.0 - elem_bounds.x,
            HorizontalAlignment::Right => width - elem_bounds.width - elem_bounds.x,
        };
        
        session.set_position(elem.clone(), x, current_pos.1); // Update x, keep y
    }
}


pub fn layout_horizontal_stack(session: &mut DiagramBuilder, horizontal_stack: &HorizontalStack) {
    let mut logical_x = 0.0; // Where we want each element's bounding box to start
    let mut height = 0.0;
    
    for elem in horizontal_stack.elements.iter() {
        let elem_bounds = session.get_effective_bounds(elem.clone());
        
        // FIXED: Position the element so its bounding box starts at logical_x
        let transform_x = logical_x - elem_bounds.x;
        session.set_position(elem.clone(), transform_x, 0.0);
        
        // FIXED: Add the effective width to logical_x for next element
        logical_x += elem_bounds.width;
        
        if elem_bounds.height > height {
            height = elem_bounds.height;
        }
    }
    
    // Set the stack size to the total logical width
    session.set_size(horizontal_stack.entity.clone(), logical_x, height);

    // Second pass: adjust y positions for vertical alignment
    for elem in horizontal_stack.elements.iter() {
        // FIXED: Use effective bounds consistently for alignment calculations
        let elem_bounds = session.get_effective_bounds(elem.clone());
        let current_pos = session.get_position(elem.clone());
        
        let y = match horizontal_stack.vertical_alignment {
            VerticalAlignment::Top => -elem_bounds.y, // Compensate for bounding box offset
            VerticalAlignment::Center => (height - elem_bounds.height) / 2.0 - elem_bounds.y,
            VerticalAlignment::Bottom => height - elem_bounds.height - elem_bounds.y,
        };
        
        session.set_position(elem.clone(), current_pos.0, y);
    }
}
/**
 * Calculates the layout for each of the cells according to table rules:
 * - Cells in the same column have the same width (eq to the max of widths)
 * - Cells in the same row have the same height (eq to the max of heights)
 * - Rows on top of each other
 * - Cols to the right of each other
 * - The sizes of the internal elements should be previously computed for this to work
 */
pub fn layout_table(session: &mut DiagramBuilder, table: &Table) {
    //we need to group elements by row and column, calculate their
    //natural sizes and then update their rows and columns
    let mut rows: Vec<Vec<EntityID>> = Vec::new();
    let mut cols: Vec<Vec<EntityID>> = Vec::new();
    let mut row_heights: Vec<Float> = Vec::new();
    let mut col_widths: Vec<Float> = Vec::new();

    // Add variables to store line positions
    let mut horizontal_line_positions: Vec<Float> = Vec::new();
    let mut vertical_line_positions: Vec<Float> = Vec::new();

    //initialize rows and cols
    for (i, elem) in table.cells.iter().enumerate() {
        let row = i / table.cols;
        let col = i % table.cols;
        //add the element to the row and col
        if row >= rows.len() {
            rows.push(Vec::new());
            row_heights.push(0.0);
        }
        if col >= cols.len() {
            cols.push(Vec::new());
            col_widths.push(0.0);
        }
        rows[row].push(elem.clone());
        cols[col].push(elem.clone());

        //update the row and col sizes
        let elem_bounds = session.get_effective_bounds(elem.clone());

        // âœ… ALREADY FIXED: Use .width and .height properties
        if elem_bounds.width > col_widths[col] {
            col_widths[col] = elem_bounds.width + table.table_options.cell_padding as Float * 2.0;
        }
        if elem_bounds.height > row_heights[row] {
            row_heights[row] = elem_bounds.height + table.table_options.cell_padding as Float * 2.0;
        }
    }

    //print row heights and col widths
    println!("row heights: {:?}", row_heights);
    println!("col widths: {:?}", col_widths);

    //we already have each row and col and their sizes.
    //Now we have to update the position of each element
    //and the size of the table

    //iterate through rows and cols and update the position of each element
    let mut logical_x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        let mut logical_y = 0.0;
        for (j, elem) in col.iter().enumerate() {
            // FIXED: Apply bounding box compensation for cell positioning
            let elem_bounds = session.get_effective_bounds(elem.clone());
            
            // Calculate where we want the element's bounding box to be (with padding)
            let desired_x = logical_x + table.table_options.cell_padding as Float;
            let desired_y = logical_y + table.table_options.cell_padding as Float;
            
            // Compensate for the element's bounding box offset
            let transform_x = desired_x - elem_bounds.x;
            let transform_y = desired_y - elem_bounds.y;
            
            session.set_position(elem.clone(), transform_x, transform_y);
            logical_y += row_heights[j];
        }

        logical_x += col_widths[i];
    }

    //Update the position of the horizontal lines
    let mut y = 0.0;
    for (i, row) in rows.iter().enumerate() {
        horizontal_line_positions.push(y);
        y += row_heights[i];
    }

    //Update the position of the vertical lines
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        vertical_line_positions.push(x);
        x += col_widths[i];
    }

    //update the size of the table
    let width: Float = col_widths.iter().sum();
    let height: Float = row_heights.iter().sum();

    //Update the size of the table header rect
    session.set_size(table.header_rect.clone(), width, row_heights[0]);

    //print the size of the table
    println!("Table size: {:?}", (width, height));

    session.set_size(table.entity.clone(), width, height);

    //We need to update the position of the horizontal lines and their size
    for (i, line) in table.row_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line.clone());
        if i < horizontal_line_positions.len() {
            //set the y position of the horizontal line, x will be 0
            session.set_position(line.clone(), 0.0, horizontal_line_positions[i]);
            //update the size, we only need to update the height and leave the width as it is (0 by default)
            session.set_size(line.clone(), width, line_size.1);
        }
    }

    for (i, line) in table.col_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(line.clone());
        if i < vertical_line_positions.len() {
            //set the x position of the vertical line, y will be 0
            session.set_position(line.clone(), vertical_line_positions[i], 0.0);
            //update the size, we only need to update the width and leave the height as it is (0 by default)
            session.set_size(line.clone(), line_size.0, height);
        }
    }
}


pub fn layout_polyline(session: &mut DiagramBuilder, polyline: &PolyLine) {
    if polyline.points.is_empty() {
        session.set_size(polyline.entity.clone(), 0.0, 0.0);
        return;
    }

    // Find the actual bounding box of all points
    let mut min_x = Float::INFINITY;
    let mut min_y = Float::INFINITY;
    let mut max_x = Float::NEG_INFINITY;
    let mut max_y = Float::NEG_INFINITY;

    for point in polyline.points.iter() {
        min_x = min_x.min(point.0);
        min_y = min_y.min(point.1);
        max_x = max_x.max(point.0);
        max_y = max_y.max(point.1);
    }

    let width = max_x - min_x;
    let height = max_y - min_y;

    // Set the polyline size to its actual bounding box
    session.set_size(polyline.entity.clone(), width, height);
}

/**
 * Layout for the FreeContainer
 * Children have absolute positions relative to the container
 * The container size is determined by the maximum extent of its children
*/
pub fn layout_free_container(session: &mut DiagramBuilder, container: &FreeContainer) {
    let mut max_width = 0.0;
    let mut max_height = 0.0;

    for (child_id, desired_position) in &container.children {
        println!("ðŸ”§ Positioning {} at ({}, {})", child_id, desired_position.0, desired_position.1);
        
        // Simply position the element at the desired location
        // No bounding box compensation needed with the new system
        session.set_position(child_id.clone(), desired_position.0, desired_position.1);
        
        // Get the size to calculate container bounds
        let child_size = session.get_size(child_id.clone());
        
        // Calculate the extent based on position + size
        let right = desired_position.0 + child_size.0;
        let bottom = desired_position.1 + child_size.1;

        if right > max_width {
            max_width = right;
        }
        if bottom > max_height {
            max_height = bottom;
        }
    }

    // Set the container's size
    session.set_size(container.entity.clone(), max_width, max_height);
}

// BETTER FIX: Adjust the arc layout to work with existing renderer expectations

/**
 * Updates the size of the arc entity based on the radius and angle sweep
 * Sets position to (0,0) since arcs use their cx,cy for center positioning
 * The size represents the full space needed for the arc
 */
pub fn layout_arc(session: &mut DiagramBuilder, shape_arc: &ShapeArc) {
    use std::f32::consts::PI;

    let radius = shape_arc.radius;
    let (start_angle, end_angle) = shape_arc.normalize_angles();

    // Convert degrees to radians
    let start_rad = start_angle * PI / 180.0;
    let end_rad = end_angle * PI / 180.0;

    // Calculate the points at start and end angles relative to center
    let start_x = shape_arc.center.0 + radius * start_rad.cos();
    let start_y = shape_arc.center.1 + radius * start_rad.sin();
    let end_x = shape_arc.center.0 + radius * end_rad.cos();
    let end_y = shape_arc.center.1 + radius * end_rad.sin();

    // For a more accurate bounding box, we need to consider if the arc crosses
    // the cardinal directions (0Â°, 90Â°, 180Â°, 270Â°)
    let mut min_x = start_x.min(end_x);
    let mut max_x = start_x.max(end_x);
    let mut min_y = start_y.min(end_y);
    let mut max_y = start_y.max(end_y);

    // Check if arc crosses cardinal directions and expand bounding box accordingly
    let sweep = shape_arc.angle_sweep();
    let angles_to_check = if end_angle > start_angle {
        vec![0.0, 90.0, 180.0, 270.0]
    } else {
        // Arc crosses 0Â° (wraps around)
        vec![0.0, 90.0, 180.0, 270.0, 360.0]
    };

    for angle in angles_to_check {
        let normalized_angle = angle % 360.0;

        // Check if this cardinal angle is within our arc
        let angle_in_arc = if end_angle > start_angle {
            normalized_angle >= start_angle && normalized_angle <= end_angle
        } else {
            normalized_angle >= start_angle || normalized_angle <= end_angle
        };

        if angle_in_arc {
            let rad = normalized_angle * PI / 180.0;
            let x = shape_arc.center.0 + radius * rad.cos();
            let y = shape_arc.center.1 + radius * rad.sin();

            min_x = min_x.min(x);
            max_x = max_x.max(x);
            min_y = min_y.min(y);
            max_y = max_y.max(y);
        }
    }

    // Calculate width and height from bounding box
    let width = max_x - min_x;
    let height = max_y - min_y;

    // FIXED: Set position to (0,0) and let the arc use its cx,cy for positioning
    // This matches how other shapes work - they render relative to their position
    session.set_position(shape_arc.entity.clone(), 0.0, 0.0);

    // The size should be large enough to contain the entire arc
    // Add padding to ensure the arc fits regardless of center position
    let total_width = (shape_arc.center.0 + radius).max(width);
    let total_height = (shape_arc.center.1 + radius).max(height);

    session.set_size(shape_arc.entity.clone(), total_width, total_height);
}
// Add this to your BoundingBox definition in src/transform.rs or wherever it's defined:

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct BoundingBox {
    pub x: Float,
    pub y: Float,
    pub width: Float,
    pub height: Float,
}



//Calculate the layout for a tree of elements
pub fn layout_tree_node(session: &mut DiagramBuilder, root: &DiagramTreeNode) -> BoundingBox {
    //start with the bottom elements
    for child in &root.children {
        println!("Layout child: {:?}", child);
        layout_tree_node(session, child);
        //print size and position of the child

        let child_size = session.get_size(child.entity_id.clone());
        let child_pos = session.get_position(child.entity_id.clone());
        println!("Child size: {:?}", child_size);
        println!("Child pos: {:?}", child_pos);
    }

    //Once the children are laid out, we can layout the current element
    //use methods in the layout module
    match root.entity_type {
        EntityType::SpacerShape => {
            let spacer = session.get_spacer(root.entity_id.clone()).clone();
            layout_spacer(session, &spacer);
        }
        EntityType::TextShape => {
            {
                //get the Shape text entity
                let text = session.get_text(root.entity_id.clone()).clone();
                layout_text(session, &text);
            }
        }
        EntityType::BoxShape => {
            //get the Shape box entity
            let box_shape = session.get_box(root.entity_id.clone()).clone();
            layout_box(session, &box_shape);
        }

        EntityType::RectShape => {
            //get the Rect entity
            let rect = session.get_rectangle(root.entity_id.clone()).clone();
            layout_rect(session, &rect);
        }

        EntityType::LineShape => {
            //get the Shape line entity
            let line = session.get_line(root.entity_id.clone()).clone();
            layout_line(session, &line);
        }
        EntityType::ArrowShape => {
            //get the Shape arrow entity
            let arrow = session.get_arrow(root.entity_id.clone()).clone();
            layout_arrow(session, &arrow);
        }
        EntityType::EllipseShape => {
            //get the Shape ellipse entity
            let ellipse = session.get_ellipse(root.entity_id.clone()).clone();
            layout_ellipse(session, &ellipse);
        }
        EntityType::ImageShape => {
            //get the Shape image entity
            let image = session.get_image(root.entity_id.clone()).clone();
            layout_image(session, &image);
        }
        EntityType::VerticalStackShape => {
            //get the VerticalStack entity
            let vertical_stack = session.get_vertical_stack(root.entity_id.clone()).clone();
            layout_vertical_stack(session, &vertical_stack);
        }

        EntityType::HorizontalStackShape => {
            //get the HorizontalStack entity
            let horizontal_stack = session.get_horizontal_stack(root.entity_id.clone()).clone();
            layout_horizontal_stack(session, &horizontal_stack);
        }

        EntityType::TableShape => {
            //get the Table entity
            let table = session.get_table(root.entity_id.clone()).clone();
            layout_table(session, &table);
        }

        EntityType::GroupShape => {
            //get the Group entity
            let group = session.get_group(root.entity_id.clone()).clone();
            layout_group(session, &group);
        }

        EntityType::PolyLine => {
            let polyline = session.get_polyline(root.entity_id.clone()).clone();
            layout_polyline(session, &polyline);
        }
        EntityType::FreeContainer => {
            let container = session.get_free_container(root.entity_id.clone()).clone();
            layout_free_container(session, &container);
        }

        EntityType::ArcShape => {
            let arc = session.get_arc(root.entity_id.clone()).clone();
            layout_arc(session, &arc);
        }

        //if not recognized, show the name of it in the panic
        _ => panic!("Unknown entity type: {:?}", root.entity_type),
    }

    session.get_effective_bounds(root.entity_id.clone())
}

//import textoptions defined in src/components/mod.rs
use crate::components::{BoxOptions, TextOptions};
//Test that a box with a text inside is correctly laid out
#[test]
fn test_layout_box_with_text() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //print box options
    println!("--box options: {:?}", box_options);

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());
    //assert equal positions

    // assert the box size is greater than the text size
    println!("box size: {:?}", box_size);
    println!("text size: {:?}", text_size);
    // and the text size should not be zero
    assert!(text_size.0 > 0.0);
    assert_eq!(box_size.0, 30.0);
    assert!(box_size.1 > text_size.1);
}

#[test]
fn test_box_fixed_size() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "testid".to_string(),
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        width_behavior: SizeBehavior::Fixed(100.0),
        height_behavior: SizeBehavior::Fixed(50.0),
        ..Default::default()
    };
    let box_shape = session.new_box("testbox".to_string(), text.clone(), box_options.clone());

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id.clone());
    let text_size = session.get_size(text.entity_id.clone());

    let box_position = session.get_position(box_shape.entity_id.clone());
    let box_size = session.get_size(box_shape.entity_id.clone());

    //assert equal positions
    // Assert that the text is centered within the box
    assert_eq!(
        text_position.0,
        box_options.padding
            + (box_options.width_behavior.unwrap_fixed().unwrap()
                - box_options.padding * 2.0
                - text_size.0)
                / 2.0
    );
    assert_eq!(
        text_position.1,
        box_options.padding
            + (box_options.height_behavior.unwrap_fixed().unwrap()
                - box_options.padding * 2.0
                - text_size.1)
                / 2.0
    );
    assert_eq!(box_position, (0.0, 0.0));

    // assert the box size is equal to the fixed size
    assert_eq!(box_size.0, 100.0);
    assert_eq!(box_size.1, 50.0);
}

===/src/lib.rs===

pub use crate::diagram_builder::{DiagramBuilder};
pub use crate::components::*;
pub use crate::layout::*;
pub use crate::utils::*;
pub use crate::renderer_base::*;

pub mod diagram_builder;
pub mod utils;
pub mod components;
pub mod layout;
pub mod renderer_base;
pub mod parser;
pub mod transform;

#[cfg(test)]
mod tests;

===/src/tests/rotation_tests.rs===
#[cfg(test)]
mod simple_rotation_test {
    use crate::transform::Transform;
    use crate::{Fill, RectOptions, SizeBehavior};
    use crate::{DiagramBuilder, layout::layout_tree_node};

    #[test]
    fn test_90_degree_rotation_bounding_box() {
        println!("ðŸ§ª Testing 90Â° rotation bounding box...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create a 100x50 rectangle (wide rectangle)
        let rect_opts = RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(50.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "darkblue".to_string(),
            stroke_width: 1.0,
            border_radius: 0.0,
        };
        
        let rect = builder.new_rectangle("test_rect".to_string(), rect_opts);
        
        // Apply 90Â° rotation
        let rotation_transform = Transform::rotation(90.0);
        builder.set_transform("test_rect".to_string(), rotation_transform);
        
        // Layout the rectangle
        layout_tree_node(&mut builder, &rect);
        
        // Get the effective bounds
        let bounds = builder.get_effective_bounds("test_rect".to_string());
        
        println!("ðŸ“ Original size: 100x50 (wide rectangle)");
        println!("ðŸ“ Rotation: 90Â°");
        println!("ðŸ“¦ Effective bounds: w={:.1}, h={:.1}", bounds.width, bounds.height);
        
        // After 90Â° rotation: width and height should swap
        // Original: 100 wide, 50 tall â†’ Rotated: 50 wide, 100 tall
        assert_eq!(bounds.width as i32, 50, "90Â° rotated width should be 50, got {:.1}", bounds.width);
        assert_eq!(bounds.height as i32, 100, "90Â° rotated height should be 100, got {:.1}", bounds.height);
        
        println!("âœ… 90Â° rotation test passed! Dimensions swapped correctly.");
    }
}


#[cfg(test)]
mod debug_rotation_positioning {
    use super::*;
    use crate::transform::Transform;
    use crate::{Fill, HorizontalAlignment, RectOptions, SizeBehavior, VerticalAlignment};
    use crate::{DiagramBuilder, layout::layout_tree_node};

    #[test]
    fn test_debug_rotation_positioning() {
        println!("ðŸ§ª Debugging rotation positioning...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create the same setup as your JSONL test
        let normal_rect = builder.new_rectangle("normal_rect".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("red".to_string()),
            stroke_color: "darkred".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        let rotated_rect = builder.new_rectangle("rotated_rect".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("blue".to_string()),
            stroke_color: "darkblue".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        let normal_rect2 = builder.new_rectangle("normal_rect2".to_string(), RectOptions {
            width_behavior: SizeBehavior::Fixed(60.0),
            height_behavior: SizeBehavior::Fixed(40.0),
            fill_color: Fill::Color("green".to_string()),
            stroke_color: "darkgreen".to_string(),
            stroke_width: 2.0,
            border_radius: 0.0,
        });
        
        // Apply rotation to middle rectangle
        let rotation_transform = Transform::rotation(45.0);
        builder.set_transform("rotated_rect".to_string(), rotation_transform);
        
        println!("ðŸ” BEFORE LAYOUT:");
        println!("  Normal rect bounds: {:?}", builder.get_effective_bounds("normal_rect".to_string()));
        println!("  Rotated rect bounds: {:?}", builder.get_effective_bounds("rotated_rect".to_string()));
        println!("  Normal rect2 bounds: {:?}", builder.get_effective_bounds("normal_rect2".to_string()));
        
        // Create horizontal stack
        let hstack = builder.new_hstack("root".to_string(), 
                                       vec![normal_rect, rotated_rect, normal_rect2], 
                                       VerticalAlignment::Center);
        
        // Layout the stack
        layout_tree_node(&mut builder, &hstack);
        
        println!("ðŸ” AFTER LAYOUT:");
        println!("  Normal rect position: {:?}", builder.get_position("normal_rect".to_string()));
        println!("  Normal rect bounds: {:?}", builder.get_effective_bounds("normal_rect".to_string()));
        
        println!("  Rotated rect position: {:?}", builder.get_position("rotated_rect".to_string()));
        println!("  Rotated rect bounds: {:?}", builder.get_effective_bounds("rotated_rect".to_string()));
        println!("  Rotated rect transform: {:?}", builder.get_transform("rotated_rect".to_string()));
        
        println!("  Normal rect2 position: {:?}", builder.get_position("normal_rect2".to_string()));
        println!("  Normal rect2 bounds: {:?}", builder.get_effective_bounds("normal_rect2".to_string()));
        
        println!("  Stack total size: {:?}", builder.get_size("root".to_string()));
        
        // Check if there's overlap
        let rect1_bounds = builder.get_effective_bounds("normal_rect".to_string());
        let rect2_bounds = builder.get_effective_bounds("rotated_rect".to_string());
        let rect3_bounds = builder.get_effective_bounds("normal_rect2".to_string());
        
        println!("ðŸ” OVERLAP CHECK:");
        println!("  Rect1 occupies: x={:.1} to x={:.1}", rect1_bounds.x, rect1_bounds.x + rect1_bounds.width);
        println!("  Rect2 occupies: x={:.1} to x={:.1}", rect2_bounds.x, rect2_bounds.x + rect2_bounds.width);
        println!("  Rect3 occupies: x={:.1} to x={:.1}", rect3_bounds.x, rect3_bounds.x + rect3_bounds.width);
        
        // Check for actual overlap
        let rect1_end = rect1_bounds.x + rect1_bounds.width;
        let rect2_start = rect2_bounds.x;
        let rect2_end = rect2_bounds.x + rect2_bounds.width;
        let rect3_start = rect3_bounds.x;
        
        if rect2_start < rect1_end {
            println!("âŒ OVERLAP DETECTED: Rect2 starts at {:.1} but Rect1 ends at {:.1}", rect2_start, rect1_end);
        } else {
            println!("âœ… No overlap between Rect1 and Rect2");
        }
        
        if rect3_start < rect2_end {
            println!("âŒ OVERLAP DETECTED: Rect3 starts at {:.1} but Rect2 ends at {:.1}", rect3_start, rect2_end);
        } else {
            println!("âœ… No overlap between Rect2 and Rect3");
        }
    }
}
===/src/tests/mod.rs===
pub mod rotation_tests;
===/src/components/mod.rs===
pub mod table;

use core::fmt;
use std::{any::Any, collections::HashMap, sync::Arc};

use serde_json::{Map, Value};

pub use crate::components::table::*;
//new type EntityID that is a u64
pub type EntityID = String;
pub type Float = f32;

//Export table and table options

pub trait Entity {
    fn get_id(&self) -> EntityID;
    fn get_type(&self) -> EntityType;
    //as_any
    fn as_any(&self) -> &dyn Any;
}

pub struct Point {
    pub x: Float,
    pub y: Float,
}

//impl clone
impl Clone for Point {
    fn clone(&self) -> Self {
        Point {
            x: self.x,
            y: self.y,
        }
    }
}

//impl new
impl Point {
    pub fn new(x: Float, y: Float) -> Self {
        Point { x, y }
    }
}

pub struct Size {
    pub w: Float,
    pub h: Float,
}

//impl clone
impl Clone for Size {
    fn clone(&self) -> Self {
        Size {
            w: self.w,
            h: self.h,
        }
    }
}

//impl new
impl Size {
    pub fn new(w: Float, h: Float) -> Self {
        Size { w, h }
    }
}

//Note: add new items to the end of the enum to avoid breaking the serialization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EntityType {
    BoxShape,
    RectShape,
    TextShape,
    LineShape,
    ArrowShape,
    EllipseShape,
    ImageShape,
    GroupShape,
    VerticalStackShape,
    HorizontalStackShape,
    TableShape,
    TextLine,
    PolyLine,
    FreeContainer,
    ArcShape,
    SpacerShape,
}

#[derive(Debug, Copy, PartialEq)]
pub enum SizeBehavior {
    /// Fixed size - element has a predetermined size that doesn't change
    Fixed(Float),
    /// Content size - element sizes itself based on its content (current default behavior)
    Content,
    /// Grow size - element takes all available space from its parent
    Grow,
}

impl Default for SizeBehavior {
    fn default() -> Self {
        SizeBehavior::Content
    }
}

impl Eq for SizeBehavior {}

impl Clone for SizeBehavior {
    fn clone(&self) -> Self {
        match self {
            SizeBehavior::Fixed(v) => SizeBehavior::Fixed(*v),
            SizeBehavior::Content => SizeBehavior::Content,
            SizeBehavior::Grow => SizeBehavior::Grow,
        }
    }
}

impl SizeBehavior {
    pub fn unwrap_fixed(&self) -> Result<f32, &'static str> {
        match self {
            SizeBehavior::Fixed(val) => Ok(*val),
            _ => Err("Called unwrap_fixed on non-Fixed SizeBehavior"),
        }
    }
}

// Add spacer component
pub struct ShapeSpacer {
    pub entity: EntityID,
    pub spacer_options: SpacerOptions,
}

impl ShapeSpacer {
    pub fn new(entity: EntityID, spacer_options: SpacerOptions) -> ShapeSpacer {
        ShapeSpacer {
            entity,
            spacer_options,
        }
    }
}

impl Clone for ShapeSpacer {
    fn clone(&self) -> Self {
        ShapeSpacer {
            entity: self.entity.clone(),
            spacer_options: self.spacer_options.clone(),
        }
    }
}

#[derive(Default, Debug)]
pub struct SpacerOptions {
    pub width: Float,
    pub height: Float,
    pub direction: SpacerDirection, // Horizontal, Vertical, or Both
}

impl Clone for SpacerOptions {
    fn clone(&self) -> Self {
        SpacerOptions {
            width: self.width,
            height: self.height,
            direction: self.direction.clone(),
        }
    }
}

#[derive(Debug)]
pub enum SpacerDirection {
    Horizontal, // Takes up width, minimal height
    Vertical,   // Takes up height, minimal width
    Both,       // Takes up both dimensions
}

impl Default for SpacerDirection {
    fn default() -> Self {
        SpacerDirection::Vertical
    }
}

impl Clone for SpacerDirection {
    fn clone(&self) -> Self {
        match self {
            SpacerDirection::Horizontal => SpacerDirection::Horizontal,
            SpacerDirection::Vertical => SpacerDirection::Vertical,
            SpacerDirection::Both => SpacerDirection::Both,
        }
    }
}

/**
 * Boxes show a rectangle around the wrapped entity
 */
#[derive(Debug)]
pub struct ShapeBox {
    pub entity: EntityID,
    //Each box wraps another entity
    pub wrapped_entity: EntityID,
    pub box_options: BoxOptions,
}

impl Clone for ShapeBox {
    fn clone(&self) -> Self {
        ShapeBox {
            entity: self.entity.clone(),
            wrapped_entity: self.wrapped_entity.clone(),
            box_options: self.box_options.clone(),
        }
    }
}

impl Entity for ShapeBox {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::BoxShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeBox {
    pub fn new(entity: EntityID, wrapped_entity: EntityID, box_options: BoxOptions) -> ShapeBox {
        ShapeBox {
            entity,
            wrapped_entity,
            box_options,
        }
    }
}

#[derive(Debug)]
pub enum GradientStop {
    ColorStop { offset: Float, color: String },
    OpacityStop { offset: Float, opacity: Float },
}

#[derive(Debug)]
pub struct LinearGradient {
    pub x1: Float,
    pub y1: Float,
    pub x2: Float,
    pub y2: Float,
    pub stops: Vec<GradientStop>,
}

impl LinearGradient {
    pub fn new(x1: Float, y1: Float, x2: Float, y2: Float, stops: Vec<GradientStop>) -> Self {
        LinearGradient {
            x1,
            y1,
            x2,
            y2,
            stops,
        }
    }
}

impl Clone for GradientStop {
    fn clone(&self) -> Self {
        match self {
            GradientStop::ColorStop { offset, color } => GradientStop::ColorStop {
                offset: *offset,
                color: color.clone(),
            },
            GradientStop::OpacityStop { offset, opacity } => GradientStop::OpacityStop {
                offset: *offset,
                opacity: *opacity,
            },
        }
    }
}

#[derive(Debug)]
pub struct RadialGradient {
    pub cx: Float,
    pub cy: Float,
    pub r: Float,
    pub stops: Vec<GradientStop>,
}

impl Clone for RadialGradient {
    fn clone(&self) -> Self {
        RadialGradient {
            cx: self.cx,
            cy: self.cy,
            r: self.r,
            stops: self.stops.clone(),
        }
    }
}

impl Clone for LinearGradient {
    fn clone(&self) -> Self {
        LinearGradient {
            x1: self.x1,
            y1: self.y1,
            x2: self.x2,
            y2: self.y2,
            stops: self.stops.clone(),
        }
    }
}

#[derive(Debug)]
pub enum Fill {
    Color(String),
    LinearGradient(LinearGradient),
    RadialGradient(RadialGradient),
}

impl Clone for Fill {
    fn clone(&self) -> Self {
        match self {
            Fill::Color(color) => Fill::Color(color.clone()),
            Fill::LinearGradient(gradient) => Fill::LinearGradient(gradient.clone()),
            Fill::RadialGradient(gradient) => Fill::RadialGradient(gradient.clone()),
        }
    }
}
//default trait for fill
impl Default for Fill {
    fn default() -> Self {
        Fill::Color(String::from("white"))
    }
}

//display for fill
impl fmt::Display for Fill {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Fill::Color(color) => write!(f, "{}", color),
            Fill::LinearGradient(gradient) => write!(f, "{:?}", gradient),
            Fill::RadialGradient(gradient) => write!(f, "{:?}", gradient),
        }
    }
}

impl PartialEq for Fill {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Fill::Color(a), Fill::Color(b)) => a == b,
            (Fill::LinearGradient(a), Fill::LinearGradient(b)) => a == b,
            (Fill::RadialGradient(a), Fill::RadialGradient(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for Fill {}

impl PartialEq for LinearGradient {
    fn eq(&self, other: &Self) -> bool {
        self.x1 == other.x1
            && self.y1 == other.y1
            && self.x2 == other.x2
            && self.y2 == other.y2
            && self.stops == other.stops
    }
}

impl Eq for LinearGradient {}

impl PartialEq for RadialGradient {
    fn eq(&self, other: &Self) -> bool {
        self.cx == other.cx && self.cy == other.cy && self.r == other.r && self.stops == other.stops
    }
}

impl Eq for RadialGradient {}

impl PartialEq for GradientStop {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                GradientStop::ColorStop {
                    offset: a_offset,
                    color: a_color,
                },
                GradientStop::ColorStop {
                    offset: b_offset,
                    color: b_color,
                },
            ) => a_offset == b_offset && a_color == b_color,
            (
                GradientStop::OpacityStop {
                    offset: a_offset,
                    opacity: a_opacity,
                },
                GradientStop::OpacityStop {
                    offset: b_offset,
                    opacity: b_opacity,
                },
            ) => a_offset == b_offset && a_opacity == b_opacity,
            _ => false,
        }
    }
}

impl Eq for GradientStop {}

#[derive(Debug)]
pub struct BoxOptions {
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub padding: Float,
    pub border_radius: Float,
    // Add size behavior fields
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
}

impl Clone for BoxOptions {
    fn clone(&self) -> Self {
        BoxOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            padding: self.padding,
            border_radius: self.border_radius,
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
        }
    }
}

impl Default for BoxOptions {
    fn default() -> Self {
        BoxOptions::new()
    }
}

impl BoxOptions {
    pub fn new() -> BoxOptions {
        BoxOptions {
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            padding: 10.0,
            border_radius: 0.0,
            width_behavior: SizeBehavior::Content,
            height_behavior: SizeBehavior::Content,
        }
    }
}

/* A group of entities */

//RectOptions
#[derive(Default, Debug)]
pub struct RectOptions {
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub border_radius: Float,
}

impl Clone for RectOptions {
    fn clone(&self) -> Self {
        RectOptions {
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            border_radius: self.border_radius,
        }
    }
}

impl RectOptions {
    pub fn new() -> RectOptions {
        RectOptions {
            width_behavior: SizeBehavior::Fixed(100.0),
            height_behavior: SizeBehavior::Fixed(100.0),
            // Default fill color is white
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            border_radius: 0.0,
        }
    }
}

pub struct ShapeRect {
    pub entity: EntityID,
    pub rect_options: RectOptions,
}

impl ShapeRect {
    pub fn new(entity: EntityID, rect_options: RectOptions) -> ShapeRect {
        ShapeRect {
            entity,
            rect_options,
        }
    }
}

impl Clone for ShapeRect {
    fn clone(&self) -> Self {
        ShapeRect {
            entity: self.entity.clone(),
            rect_options: self.rect_options.clone(),
        }
    }
}

impl Entity for ShapeRect {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::RectShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

/* A group of entities */
pub struct ShapeGroup {
    pub entity: EntityID,
    pub elements: Vec<EntityID>,
}

impl Clone for ShapeGroup {
    fn clone(&self) -> Self {
        ShapeGroup {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
        }
    }
}

impl Entity for ShapeGroup {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::GroupShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

// Represents a line after adding breaks
#[derive(Debug)]
pub struct TextLine {
    pub entity: EntityID,
    pub text: String,
}

impl Clone for TextLine {
    fn clone(&self) -> Self {
        TextLine {
            entity: self.entity.clone(),
            text: self.text.clone(),
        }
    }
}

impl Entity for TextLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
//add copy trait
#[derive(Debug)]
pub struct ShapeText {
    pub entity: EntityID,
    pub text: String,
    pub text_options: TextOptions,
    pub lines: Vec<EntityID>,
}

impl Clone for ShapeText {
    fn clone(&self) -> Self {
        ShapeText {
            entity: self.entity.clone(),
            text: self.text.clone(),
            text_options: self.text_options.clone(),
            lines: self.lines.clone(),
        }
    }
}

impl ShapeText {
    pub fn new(
        entity: EntityID,
        text: &str,
        text_options: TextOptions,
        lines: &[EntityID],
    ) -> ShapeText {
        ShapeText {
            entity,
            text: text.to_string(),
            text_options,
            lines: lines.to_vec(),
        }
    }
}

impl Entity for ShapeText {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

//struct with text options: font family, font size
#[derive(Default, Debug)]
pub struct TextOptions {
    pub font_family: String,
    pub font_size: f32,
    pub text_color: String,
    // (number of max characters per line)used to know when to insert breaks
    pub line_width: usize,
    pub line_spacing: f32, // spacing between lines
}

impl Clone for TextOptions {
    fn clone(&self) -> Self {
        TextOptions {
            font_family: self.font_family.clone(),
            font_size: self.font_size,
            text_color: self.text_color.clone(),
            line_width: self.line_width,
            line_spacing: self.line_spacing,
        }
    }
}

impl TextOptions {
    pub fn new() -> TextOptions {
        TextOptions {
            font_family: String::from("Roboto"),
            font_size: 12.0,
            text_color: String::from("black"),
            line_width: 20,
            line_spacing: 0.0,
        }
    }
}

pub enum HorizontalAlignment {
    Left,
    Center,
    Right,
}

impl Clone for HorizontalAlignment {
    fn clone(&self) -> Self {
        match self {
            HorizontalAlignment::Left => HorizontalAlignment::Left,
            HorizontalAlignment::Center => HorizontalAlignment::Center,
            HorizontalAlignment::Right => HorizontalAlignment::Right,
        }
    }
}

pub struct VerticalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub horizontal_alignment: HorizontalAlignment,
}

impl Clone for VerticalStack {
    fn clone(&self) -> Self {
        VerticalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            horizontal_alignment: self.horizontal_alignment.clone(),
        }
    }
}

impl Entity for VerticalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::VerticalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub enum VerticalAlignment {
    Top,
    Center,
    Bottom,
}

impl Clone for VerticalAlignment {
    fn clone(&self) -> Self {
        match self {
            VerticalAlignment::Top => VerticalAlignment::Top,
            VerticalAlignment::Center => VerticalAlignment::Center,
            VerticalAlignment::Bottom => VerticalAlignment::Bottom,
        }
    }
}
impl fmt::Display for VerticalAlignment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerticalAlignment::Top => write!(f, "Top"),
            VerticalAlignment::Center => write!(f, "Center"),
            VerticalAlignment::Bottom => write!(f, "Bottom"),
        }
    }
}
//enum for horizontal stack

pub struct HorizontalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub vertical_alignment: VerticalAlignment, // Optional vertical alignment (e.g., "top", "center", "bottom")
}

impl Clone for HorizontalStack {
    fn clone(&self) -> Self {
        HorizontalStack {
            entity: self.entity.clone(),
            elements: self.elements.clone(),
            vertical_alignment: self.vertical_alignment.clone(),
        }
    }
}

impl Entity for HorizontalStack {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::HorizontalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ShapeLine {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub line_options: LineOptions,
}

impl Clone for ShapeLine {
    fn clone(&self) -> Self {
        ShapeLine {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            line_options: self.line_options.clone(),
        }
    }
}

impl ShapeLine {
    pub fn new(
        line_id: EntityID,
        start: (Float, Float),
        end: (Float, Float),
        options: LineOptions,
    ) -> ShapeLine {
        ShapeLine {
            entity: line_id,
            start,
            end,
            line_options: options,
        }
    }
}

impl Entity for ShapeLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::LineShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct LineOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for LineOptions {
    fn clone(&self) -> Self {
        LineOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl LineOptions {
    pub fn new() -> LineOptions {
        LineOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct PolyLine {
    pub entity: EntityID,
    pub points: Vec<(Float, Float)>,
    pub line_options: LineOptions,
}

impl PolyLine {
    pub fn new(
        entity: EntityID,
        points: Vec<(Float, Float)>,
        line_options: LineOptions,
    ) -> PolyLine {
        PolyLine {
            entity,
            points,
            line_options,
        }
    }
}

impl Entity for PolyLine {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::PolyLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl Clone for PolyLine {
    fn clone(&self) -> Self {
        PolyLine {
            entity: self.entity.clone(),
            points: self.points.clone(),
            line_options: self.line_options.clone(),
        }
    }
}

pub struct ShapeArrow {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub arrow_options: ArrowOptions,
}

impl Clone for ShapeArrow {
    fn clone(&self) -> Self {
        ShapeArrow {
            entity: self.entity.clone(),
            start: self.start,
            end: self.end,
            arrow_options: self.arrow_options.clone(),
        }
    }
}

impl Entity for ShapeArrow {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArrowShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct ArrowOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
    pub arrow_size: Float,
}

impl Clone for ArrowOptions {
    fn clone(&self) -> Self {
        ArrowOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            arrow_size: self.arrow_size,
        }
    }
}

impl ArrowOptions {
    pub fn new() -> ArrowOptions {
        ArrowOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            arrow_size: 10.0,
        }
    }
}

pub struct ShapeEllipse {
    pub entity: EntityID,
    pub radius: (Float, Float),
    pub ellipse_options: EllipseOptions,
}

impl Clone for ShapeEllipse {
    fn clone(&self) -> Self {
        ShapeEllipse {
            entity: self.entity.clone(),
            radius: self.radius,
            ellipse_options: self.ellipse_options.clone(),
        }
    }
}

impl ShapeEllipse {
    pub fn new(
        entity: EntityID,
        radius: (Float, Float),
        ellipse_options: EllipseOptions,
    ) -> ShapeEllipse {
        ShapeEllipse {
            entity,
            radius,
            ellipse_options,
        }
    }
}

impl Entity for ShapeEllipse {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::EllipseShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct EllipseOptions {
    //TODO: convert to Fill
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for EllipseOptions {
    fn clone(&self) -> Self {
        EllipseOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl EllipseOptions {
    pub fn new() -> EllipseOptions {
        EllipseOptions {
            fill_color: String::from("white"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct ShapeImage {
    pub entity: EntityID,
    //base64 encoded image or empty if using file_path
    pub image: String,
    //path to image file on disk (optional)
    pub file_path: Option<String>,
    pub width_behavior: SizeBehavior,
    pub height_behavior: SizeBehavior,
}

impl Clone for ShapeImage {
    fn clone(&self) -> Self {
        ShapeImage {
            entity: self.entity.clone(),
            image: self.image.clone(),
            file_path: self.file_path.clone(),
            width_behavior: self.width_behavior.clone(),
            height_behavior: self.height_behavior.clone(),
        }
    }
}

impl Entity for ShapeImage {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ImageShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeImage {
    pub fn new(entity: EntityID, image: String, size: (SizeBehavior, SizeBehavior)) -> ShapeImage {
        ShapeImage {
            entity,
            image,
            file_path: None,
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }

    pub fn from_file(
        entity: EntityID,
        file_path: String,
        size: (SizeBehavior, SizeBehavior),
    ) -> ShapeImage {
        ShapeImage {
            entity,
            image: String::new(), // Empty as we're using file_path instead
            file_path: Some(file_path),
            width_behavior: size.0,
            height_behavior: size.1,
        }
    }
}

/// A container that allows children to be positioned with absolute coordinates
/// Children's positions are relative to the container's top-left corner
pub struct FreeContainer {
    pub entity: EntityID,
    pub children: Vec<(EntityID, (Float, Float))>, // Each child has a position relative to the container
    pub background_color: Option<String>,          // Optional background color
    pub border_color: Option<String>,              // Optional border color
    pub border_width: Float,                       // Border width (0 for no border)
}

impl Clone for FreeContainer {
    fn clone(&self) -> Self {
        FreeContainer {
            entity: self.entity.clone(),
            children: self.children.clone(),
            background_color: self.background_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
        }
    }
}

impl Entity for FreeContainer {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::FreeContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl FreeContainer {
    /// Create a new empty FreeContainer
    pub fn new(entity: EntityID) -> Self {
        FreeContainer {
            entity,
            children: Vec::new(),
            background_color: None,
            border_color: None,
            border_width: 0.0,
        }
    }

    /// Add a child to the container at the specified position
    pub fn add_child(&mut self, child_id: EntityID, position: (Float, Float)) {
        self.children.push((child_id, position));
    }

    /// Add multiple children at once with their positions
    pub fn with_children(
        mut self,
        children_with_positions: Vec<(EntityID, (Float, Float))>,
    ) -> Self {
        self.children.extend(children_with_positions);
        self
    }

    /// Set background color
    pub fn with_background_color(mut self, color: &str) -> Self {
        self.background_color = Some(color.to_string());
        self
    }

    /// Set border properties
    pub fn with_border(mut self, color: &str, width: Float) -> Self {
        self.border_color = Some(color.to_string());
        self.border_width = width;
        self
    }
}

// Arc options structure
#[derive(Default, Debug)]
pub struct ArcOptions {
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub filled: bool, // Whether to fill the arc sector or just draw the outline
}

impl Clone for ArcOptions {
    fn clone(&self) -> Self {
        ArcOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            filled: self.filled,
        }
    }
}

impl ArcOptions {
    pub fn new() -> ArcOptions {
        ArcOptions {
            fill_color: String::from("none"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            filled: false,
        }
    }
}

// Arc shape structure
pub struct ShapeArc {
    pub entity: EntityID,
    pub center: (Float, Float), // Center point of the arc
    pub radius: Float,          // Radius of the arc
    pub start_angle: Float,     // Start angle in degrees
    pub end_angle: Float,       // End angle in degrees
    pub arc_options: ArcOptions,
}

impl Clone for ShapeArc {
    fn clone(&self) -> Self {
        ShapeArc {
            entity: self.entity.clone(),
            center: self.center,
            radius: self.radius,
            start_angle: self.start_angle,
            end_angle: self.end_angle,
            arc_options: self.arc_options.clone(),
        }
    }
}

impl ShapeArc {
    pub fn new(
        entity: EntityID,
        center: (Float, Float),
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        arc_options: ArcOptions,
    ) -> ShapeArc {
        ShapeArc {
            entity,
            center,
            radius,
            start_angle,
            end_angle,
            arc_options,
        }
    }

    /// Normalize angles to 0-360 degree range
    pub fn normalize_angles(&self) -> (Float, Float) {
        let mut start = self.start_angle % 360.0;
        let mut end = self.end_angle % 360.0;

        if start < 0.0 {
            start += 360.0;
        }
        if end < 0.0 {
            end += 360.0;
        }

        (start, end)
    }

    /// Calculate the angle sweep of the arc
    pub fn angle_sweep(&self) -> Float {
        let (start, end) = self.normalize_angles();
        if end > start {
            end - start
        } else {
            360.0 - start + end
        }
    }

    /// Check if this is a major arc (> 180 degrees)
    pub fn is_major_arc(&self) -> bool {
        self.angle_sweep() > 180.0
    }
}

impl Entity for ShapeArc {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArcShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

/// Type alias for custom component factory functions
/// Takes a map of attributes and a mutable reference to DiagramBuilder
/// Returns a Result with either a DiagramTreeNode or an error message
pub type CustomComponentFactory = Arc<
    dyn Fn(
            &Map<String, Value>,
            &mut crate::DiagramBuilder,
        ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
        + Send
        + Sync,
>;

/// Registry for custom components
pub struct CustomComponentRegistry {
    factories: HashMap<String, CustomComponentFactory>,
}

impl CustomComponentRegistry {
    pub fn new() -> Self {
        Self {
            factories: HashMap::new(),
        }
    }

    /// Register a new custom component with the given identifier and factory function
    pub fn register<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &Map<String, Value>,
                &mut crate::DiagramBuilder,
            ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
            + Send
            + Sync
            + 'static,
    {
        self.factories
            .insert(component_type.to_string(), Arc::new(factory));
    }

    /// Create a component instance using the registered factory
    pub fn create_component(
        &self,
        component_type: &str,
        attributes: &Map<String, Value>,
        builder: &mut crate::DiagramBuilder,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        match self.factories.get(component_type) {
            Some(factory) => factory(attributes, builder),
            None => Err(format!("Unknown custom component type: {}", component_type)),
        }
    }

    /// Check if a component type is registered
    pub fn has_component(&self, component_type: &str) -> bool {
        self.factories.contains_key(component_type)
    }

    /// Get all registered component types
    pub fn get_registered_types(&self) -> Vec<&String> {
        self.factories.keys().collect()
    }

    pub fn get(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &serde_json::Map<String, serde_json::Value>,
                    &mut crate::diagram_builder::DiagramBuilder,
                ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
                + Send
                + Sync,
        >,
    > {
        self.factories.get(component_type)
    }
}

impl Default for CustomComponentRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions for extracting common attribute types
impl CustomComponentRegistry {
    /// Helper to extract a string attribute with a default value
    pub fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    /// Helper to extract a float attribute with a default value
    pub fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    /// Helper to extract a boolean attribute with a default value
    pub fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    /// Helper to extract an integer attribute with a default value
    pub fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }
}

#[cfg(test)]
mod custom_component_tests {
    use super::*;
    use crate::*;
    use serde_json::json;

    /// Test custom component: Badge
    /// Creates a rounded box with text and a colored background
    fn create_badge_component(
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
    ) -> Result<crate::diagram_builder::DiagramTreeNode, String> {
        // Extract attributes with defaults
        let text = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("Badge")
            .to_string();

        let id = attrs
            .get("text")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string();

        let textNode = builder.new_text(id, &text, TextOptions::default());
        Ok(textNode)
    }

    #[test]
    fn test_custom_component_registry() {
        let mut registry = CustomComponentRegistry::new();

        // Register badge component
        registry.register("badge", create_badge_component);

        // Test that components are registered
        assert!(registry.has_component("badge"));
        assert!(!registry.has_component("unknown"));

        // Test getting registered types
        let types = registry.get_registered_types();
        assert_eq!(types.len(), 1);
        assert!(types.contains(&&"badge".to_string()));
    }

    #[test]
    fn test_create_badge_component() {
        let mut registry = CustomComponentRegistry::new();
        registry.register("badge", create_badge_component);

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));

        // Create badge with custom attributes
        let attrs = json!({
            "text": "NEW",
            "background_color": "red",
            "text_color": "white",
            "font_size": 14.0,
            "padding": 6.0,
            "border_radius": 20.0
        });

        let attrs_map = attrs.as_object().unwrap();
        let badge = registry.create_component("badge", attrs_map, &mut builder);

        assert!(badge.is_ok());
        let badge_node = badge.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::TextShape);
    }
}

===/src/components/table.rs===

//use EntityID
use crate::components::*;


pub struct TableOptions {
    pub fill_color: String,
    pub header_fill_color: String,
    pub border_color: String,
    pub border_width: usize,
    pub cell_padding: usize,
}

/* A table contains a list of rows, each row has a cell 
* which is a group that contains other elements.

Tables are defined with an array of cells and the number of columns
*/
pub struct Table {
    pub entity: EntityID,
    pub cols: usize, 
    pub cells: Vec<EntityID>,
    pub col_lines: Vec<EntityID>,
    pub row_lines: Vec<EntityID>,
    pub header_rect: EntityID,
    pub table_options: TableOptions,
}

//new


impl Clone for Table {
    fn clone(&self) -> Self {
        Table {
            entity: self.entity.clone(),
            cols: self.cols,
            cells: self.cells.clone(),
            col_lines: self.col_lines.clone(),
            row_lines: self.row_lines.clone(),
            table_options: self.table_options.clone(),
            header_rect: self.header_rect.clone(),
        }
    }
}

//constructor that receives only the table options
impl Table {
    pub fn new(entity: EntityID,cells: Vec<EntityID>, col_lines: Vec<EntityID>, row_lines: Vec<EntityID>, cols: usize, header_rect: EntityID, table_options: TableOptions) -> Table {
        Table {
            entity,
            cols,
            cells,
            col_lines,
            row_lines ,
            header_rect, 
            table_options,
        }
    }
}

impl Entity for Table {
    fn get_id(&self) -> EntityID {
        self.entity.clone()
    }

    fn get_type(&self) -> EntityType {
        EntityType::TableShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}




//defaults
impl Default for TableOptions {
    fn default() -> Self {
        TableOptions {
            fill_color: String::from("white"),
            border_color: String::from("black"),
            header_fill_color: String::from("lightgray"),
            border_width: 1,
            cell_padding: 20,
        }
    }
}

impl Clone for TableOptions {
    fn clone(&self) -> Self {
        TableOptions {
            fill_color: self.fill_color.clone(),
            header_fill_color: self.header_fill_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
            cell_padding: self.cell_padding,
        }
    }
}

===/src/renderer_base.rs===
use std::{error::Error, fmt, io::Write};

use crate::{DiagramBuilder, diagram_builder::DiagramTreeNode};

#[derive(Debug)]
pub struct RendererError {
    message: String,
}

impl RendererError {
    pub fn new(message: &str) -> RendererError {
        RendererError {
            message: message.to_string(),
        }
    }
}

impl fmt::Display for RendererError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for RendererError {}

pub trait Renderer<W: Write> {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError>;
}

===/src/transform.rs===
// In src/transform.rs (new file)
use std::f32::consts::PI;

use crate::{BoundingBox, Float};

#[derive(Debug, Clone, PartialEq)]
pub struct Transform {
    // 2D transform matrix [a, b, c, d, e, f]
    // | a  c  e |   | x |   | a*x + c*y + e |
    // | b  d  f | * | y | = | b*x + d*y + f |
    // | 0  0  1 |   | 1 |   |       1       |
    pub matrix: [Float; 6],
}

impl Transform {
    pub fn identity() -> Self {
        Transform {
            matrix: [1.0, 0.0, 0.0, 1.0, 0.0, 0.0], // [a, b, c, d, e, f]
        }
    }
    
    pub fn translation(tx: Float, ty: Float) -> Self {
        Transform {
            matrix: [1.0, 0.0, 0.0, 1.0, tx, ty],
        }
    }
    
    pub fn rotation(angle_degrees: Float) -> Self {
        let angle_rad = angle_degrees * PI / 180.0;
        let cos_a = angle_rad.cos();
        let sin_a = angle_rad.sin();
        Transform {
            matrix: [cos_a, sin_a, -sin_a, cos_a, 0.0, 0.0],
        }
    }
    
    pub fn scale(sx: Float, sy: Float) -> Self {
        Transform {
            matrix: [sx, 0.0, 0.0, sy, 0.0, 0.0],
        }
    }
    
    pub fn combine(&self, other: &Transform) -> Transform {
        // Matrix multiplication: self * other
        let [a1, b1, c1, d1, e1, f1] = self.matrix;
        let [a2, b2, c2, d2, e2, f2] = other.matrix;
        
        Transform {
            matrix: [
                a1 * a2 + c1 * b2,           // a
                b1 * a2 + d1 * b2,           // b
                a1 * c2 + c1 * d2,           // c
                b1 * c2 + d1 * d2,           // d
                a1 * e2 + c1 * f2 + e1,      // e
                b1 * e2 + d1 * f2 + f1,      // f
            ],
        }
    }
    
    pub fn transform_point(&self, x: Float, y: Float) -> (Float, Float) {
        let [a, b, c, d, e, f] = self.matrix;
        (
            a * x + c * y + e,
            b * x + d * y + f,
        )
    }
    
    pub fn transform_rect(&self, x: Float, y: Float, width: Float, height: Float) -> BoundingBox {
        // Transform all four corners and find axis-aligned bounding box
        let corners = [
            (x, y),
            (x + width, y),
            (x + width, y + height),
            (x, y + height),
        ];
        
        let transformed_corners: Vec<(Float, Float)> = corners
            .iter()
            .map(|(px, py)| self.transform_point(*px, *py))
            .collect();
        
        let min_x = transformed_corners.iter().map(|(x, _)| *x).fold(Float::INFINITY, f32::min);
        let max_x = transformed_corners.iter().map(|(x, _)| *x).fold(Float::NEG_INFINITY, f32::max);
        let min_y = transformed_corners.iter().map(|(_, y)| *y).fold(Float::INFINITY, f32::min);
        let max_y = transformed_corners.iter().map(|(_, y)| *y).fold(Float::NEG_INFINITY, f32::max);
        
        BoundingBox {
            x: min_x,
            y: min_y,
            width: max_x - min_x,
            height: max_y - min_y,
        }
    }
    
     pub fn to_svg_string(&self) -> String {
        let [a, b, c, d, e, f] = self.matrix;
        
        // If it's just a translation, use the simpler translate syntax
        if a == 1.0 && b == 0.0 && c == 0.0 && d == 1.0 {
            if e == 0.0 && f == 0.0 {
                String::new() // Identity transform
            } else {
                format!("translate({} {})", e, f)
            }
        } else {
            // Full matrix transform
            format!("matrix({} {} {} {} {} {})", a, b, c, d, e, f)
        }
    }
}
===/src/parser.rs===
use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

use crate::transform::Transform;
use crate::{components::*, diagram_builder::*, DiagramBuilder};

/// Simplified JSON Lines entity with only essential fields
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonEntity {
    pub id: String,
    #[serde(rename = "type")]
    pub entity_type: String,

    // All attributes go into this single map - much cleaner!
    #[serde(flatten)]
    pub attributes: Map<String, Value>,
}

impl Default for JsonEntity {
    fn default() -> Self {
        Self {
            id: String::new(),
            entity_type: String::new(),
            attributes: Map::new(),
        }
    }
}

// Helper functions for attribute extraction with multiple attribute name support
fn get_string_attr(attrs: &Map<String, Value>, keys: &[&str], default: &str) -> String {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(s) = value.as_str() {
                return if s.is_empty() && !default.is_empty() {
                    default.to_string()
                } else {
                    s.to_string()
                };
            }
        }
    }
    default.to_string()
}

fn get_float_attr(attrs: &Map<String, Value>, keys: &[&str], default: f64) -> Float {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(f) = value.as_f64() {
                return f as Float;
            }
        }
    }
    default as Float
}

fn get_int_attr(attrs: &Map<String, Value>, keys: &[&str], default: i64) -> i64 {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(i) = value.as_i64() {
                return i;
            }
        }
    }
    default
}

fn get_bool_attr(attrs: &Map<String, Value>, keys: &[&str], default: bool) -> bool {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(b) = value.as_bool() {
                return b;
            }
        }
    }
    default
}

fn get_array_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<String>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| item.as_str().map(|s| s.to_string()))
                .collect()
        })
    })
}

fn get_point_attr(
    attrs: &Map<String, Value>,
    x_keys: &[&str],
    y_keys: &[&str],
    default: (Float, Float),
) -> (Float, Float) {
    let x = get_float_attr(attrs, x_keys, default.0 as f64);
    let y = get_float_attr(attrs, y_keys, default.1 as f64);
    (x, y)
}

fn get_points_attr(attrs: &Map<String, Value>, key: &str) -> Option<Vec<(Float, Float)>> {
    attrs.get(key).and_then(|v| {
        v.as_array().map(|arr| {
            arr.iter()
                .filter_map(|item| {
                    item.as_array().and_then(|point_arr| {
                        if point_arr.len() >= 2 {
                            let x = point_arr[0].as_f64().unwrap_or(0.0) as Float;
                            let y = point_arr[1].as_f64().unwrap_or(0.0) as Float;
                            Some((x, y))
                        } else {
                            None
                        }
                    })
                })
                .collect()
        })
    })
}

/// Parse a unified width/height value that can be either a number (fixed) or string (behavior)
fn parse_unified_dimension(attrs: &Map<String, Value>, keys: &[&str]) -> SizeBehavior {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            match value {
                Value::Number(num) => {
                    if let Some(float_val) = num.as_f64() {
                        return SizeBehavior::Fixed(float_val as Float);
                    }
                }
                Value::String(behavior) => {
                    return match behavior.to_lowercase().as_str() {
                        "content" | "auto" => SizeBehavior::Content,
                        "grow" => SizeBehavior::Grow,
                        _ => {
                            // Try to parse as number string
                            if let Ok(parsed) = behavior.parse::<Float>() {
                                SizeBehavior::Fixed(parsed)
                            } else {
                                SizeBehavior::Content
                            }
                        }
                    };
                }
                _ => {}
            }
        }
    }
    SizeBehavior::Content // Default
}
fn parse_transform_attributes(
    obj: &Map<String, Value>,
    session: &mut DiagramBuilder,
    entity_id: EntityID,
) {
    println!("ðŸ” Parsing transforms for entity: {}", entity_id);
    println!("ðŸ” Available attributes: {:?}", obj.keys().collect::<Vec<_>>());
    
    let mut transform = Transform::identity();

    // Parse individual transform properties
     // Store container-relative position separately
    if let Some(x) = obj.get("x").and_then(|v| v.as_f64()) {
        if let Some(y) = obj.get("y").and_then(|v| v.as_f64()) {
            session.set_container_relative_position(entity_id.clone(), x as Float, y as Float);
        }
    }

    if let Some(rotation) = obj
        .get("rotation")
        .or_else(|| obj.get("rotate"))
        .and_then(|v| v.as_f64())
    {
        println!("ðŸ”„ Found rotation: {} degrees for entity {}", rotation, entity_id);
        transform = transform.combine(&Transform::rotation(rotation as Float));
    } else {
        println!("âŒ No rotation found for entity {}", entity_id);
    }

    if let Some(scale) = obj.get("scale") {
        match scale {
            Value::Number(s) => {
                let s = s.as_f64().unwrap_or(1.0) as Float;
                println!("ðŸ“ Found uniform scale: {}", s);
                transform = transform.combine(&Transform::scale(s, s));
            }
            Value::Array(arr) if arr.len() >= 2 => {
                let sx = arr[0].as_f64().unwrap_or(1.0) as Float;
                let sy = arr[1].as_f64().unwrap_or(1.0) as Float;
                println!("ðŸ“ Found scale: [{}, {}]", sx, sy);
                transform = transform.combine(&Transform::scale(sx, sy));
            }
            _ => {}
        }
    }

    // Parse CSS-style transform string
    if let Some(transform_str) = obj.get("transform").and_then(|v| v.as_str()) {
        if let Ok(parsed_transform) = parse_css_transform(transform_str) {
            transform = transform.combine(&parsed_transform);
        }
    }

    println!("ðŸ“ Final transform for {}: {:?}", entity_id, transform);
    session.set_transform(entity_id, transform);
}

// Parse CSS-style transform strings like "rotate(45deg) scale(1.5) translate(10px, 20px)"
fn parse_css_transform(transform_str: &str) -> Result<Transform, String> {
    // Implementation would parse CSS transform functions
    // For now, simplified version:
    let result = Transform::identity();

    // This is a simplified parser - full implementation would be more robust
    if transform_str.contains("rotate(") {
        // Extract rotation value...
    }

    Ok(result)
}

/// Parser for JSON Lines diagram format
pub struct JsonLinesParser {
    entities: HashMap<String, JsonEntity>,
}

impl JsonLinesParser {
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
        }
    }

    /// Parse from a string containing JSON Lines
    pub fn parse_string(&mut self, input: &str) -> Result<String, JsonLinesError> {
        let mut root_id = None;

        for (line_num, line) in input.lines().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from a file
    pub fn parse_file(&mut self, file_path: &str) -> Result<String, JsonLinesError> {
        let file = File::open(file_path).map_err(|e| JsonLinesError::IoError(e.to_string()))?;
        let reader = BufReader::new(file);
        let mut root_id = None;

        for (line_num, line_result) in reader.lines().enumerate() {
            let line = line_result.map_err(|e| JsonLinesError::IoError(e.to_string()))?;
            let line = line.trim();

            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(&line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from an iterator of lines (useful for streaming)
    pub fn parse_lines<I>(&mut self, lines: I) -> Result<String, JsonLinesError>
    where
        I: IntoIterator<Item = String>,
    {
        let mut root_id = None;

        for (line_num, line) in lines.into_iter().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Build the diagram tree from parsed entities
    pub fn build(
        &self,
        root_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        self.build_entity(root_id, builder)
    }

    fn build_entity(
        &self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        // Clone the entity type to avoid borrow conflicts
        let component_type = entity.entity_type.clone();
        let attributes = entity.attributes.clone();

        // Check for custom components FIRST - they get the raw attributes map
        if builder.has_custom_component(&component_type) {
            return builder
                .create_custom_component(&component_type, &attributes)
                .map_err(|e| JsonLinesError::InvalidStructure(e));
        }

        // Handle built-in components using attribute helpers
        match entity.entity_type.as_str() {
            "spacer" => {
                let width = get_float_attr(&entity.attributes, &["width"], 1.0);
                let height = get_float_attr(&entity.attributes, &["height"], 20.0);
                let direction = get_string_attr(&entity.attributes, &["direction"], "vertical");

                // Determine spacer direction and final dimensions
                let spacer_direction = match direction.as_str() {
                    "horizontal" => SpacerDirection::Horizontal,
                    "both" => SpacerDirection::Both,
                    _ => SpacerDirection::Vertical, // default
                };

                let spacer_options = SpacerOptions {
                    width,
                    height,
                    direction: spacer_direction,
                };

                Ok(builder.new_spacer(entity_id.to_string(), spacer_options))
            }

            "text" => {
                let content = get_string_attr(&entity.attributes, &["content", "text"], "");
                if content.is_empty() {
                    return Err(JsonLinesError::MissingAttribute(
                        "content or text".to_string(),
                    ));
                }

                let options = TextOptions {
                    font_size: get_float_attr(&entity.attributes, &["font_size"], 12.0),
                    text_color: get_string_attr(
                        &entity.attributes,
                        &["color", "text_color"],
                        "black",
                    ),
                    font_family: get_string_attr(&entity.attributes, &["font_family"], "Arial"),
                    line_width: get_int_attr(&entity.attributes, &["line_width"], 200) as usize,
                    line_spacing: get_float_attr(&entity.attributes, &["line_spacing"], 0.0),
                };

                // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_text(entity_id.to_string(), &content, options))
            }

            "box" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                if children.len() != 1 {
                    return Err(JsonLinesError::InvalidStructure(
                        "Box must have exactly one child".to_string(),
                    ));
                }

                let child = self.build_entity(&children[0], builder)?;

                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = BoxOptions {
                    padding: get_float_attr(&entity.attributes, &["padding"], 0.0),
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                    width_behavior,
                    height_behavior,
                };

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_box(entity_id.to_string(), child, options))
            }

            "vstack" => {
                let halign = match get_string_attr(
                    &entity.attributes,
                    &["h_align", "horizontal_alignment"],
                    "center",
                )
                .as_str()
                {
                    "left" => HorizontalAlignment::Left,
                    "center" => HorizontalAlignment::Center,
                    "right" => HorizontalAlignment::Right,
                    _ => HorizontalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_vstack(entity_id.to_string(), child_nodes?, halign))
            }

            "hstack" => {
                let valign = match get_string_attr(
                    &entity.attributes,
                    &["v_align", "vertical_alignment"],
                    "center",
                )
                .as_str()
                {
                    "top" => VerticalAlignment::Top,
                    "center" => VerticalAlignment::Center,
                    "bottom" => VerticalAlignment::Bottom,
                    _ => VerticalAlignment::Center,
                };

                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_hstack(entity_id.to_string(), child_nodes?, valign))
            }

            "group" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();
                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_group(entity_id.to_string(), child_nodes?))
            }

            "rect" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let options = RectOptions {
                    width_behavior,
                    height_behavior,
                    fill_color: {
                        let color = get_string_attr(
                            &entity.attributes,
                            &["background", "background_color", "fill"],
                            "white",
                        );
                        Fill::Color(color)
                    },
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["border_color", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["border_width", "stroke_width"],
                        1.0,
                    ),
                    border_radius: get_float_attr(&entity.attributes, &["border_radius"], 0.0),
                };
                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_rectangle(entity_id.to_string(), options))
            }

            "line" => {
                let start_point = get_point_attr(
                    &entity.attributes,
                    &["start_x", "x1"],
                    &["start_y", "y1"],
                    (0.0, 0.0),
                );
                let end_point = get_point_attr(
                    &entity.attributes,
                    &["end_x", "x2"],
                    &["end_y", "y2"],
                    (0.0, 0.0),
                );

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_line(entity_id.to_string(), start_point, end_point, options))
            }

            "ellipse" => {

                let radius = get_point_attr(
                    &entity.attributes,
                    &["rx", "radius_x"],
                    &["ry", "radius_y"],
                    (25.0, 25.0),
                );

                let options = EllipseOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color", "background"],
                        "white",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color", "border_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(
                        &entity.attributes,
                        &["stroke_width", "border_width"],
                        1.0,
                    ),
                };

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_elipse(entity_id.to_string(),radius, options))
            }

            "arc" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (0.0, 0.0),
                );
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let start_angle =
                    get_float_attr(&entity.attributes, &["start_angle", "start"], 0.0);
                let end_angle = get_float_attr(&entity.attributes, &["end_angle", "end"], 90.0);

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_arc(
                    entity_id.to_string(),
                    center,
                    radius,
                    start_angle,
                    end_angle,
                    options,
                ))
            }

            // Complete fixed semicircle section for parser.rs
            "semicircle" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (0.0, 0.0),
                );
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let facing_up = get_bool_attr(&entity.attributes, &["facing_up", "up"], true);

                let (start, end) = if facing_up {
                    (180.0, 360.0) // FIXED: Top semicircle should be 180Â° to 360Â°
                } else {
                    (0.0, 180.0) // FIXED: Bottom semicircle should be 0Â° to 180Â°
                };

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_arc(entity_id.to_string(), center, radius, start, end, options))
            }

            "quarter_circle" => {
                let center = get_point_attr(
                    &entity.attributes,
                    &["cx", "center_x"],
                    &["cy", "center_y"],
                    (0.0, 0.0),
                );
                let radius = get_float_attr(&entity.attributes, &["radius", "r"], 50.0);
                let quadrant = get_int_attr(&entity.attributes, &["quadrant"], 1) as u8;

                let options = ArcOptions {
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill", "fill_color"],
                        "none",
                    ),
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke", "stroke_color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                    filled: get_bool_attr(&entity.attributes, &["filled"], false),
                };

                  // Parse and apply transforms
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_quarter_circle(
                    entity_id.to_string(),
                    center,
                    radius,
                    quadrant,
                    options,
                ))
            }

            "image" => {
                let width_behavior = parse_unified_dimension(&entity.attributes, &["width"]);
                let height_behavior = parse_unified_dimension(&entity.attributes, &["height"]);

                let src = get_string_attr(&entity.attributes, &["src"], "");
                let file_path = get_string_attr(&entity.attributes, &["file_path"], "");

                if !src.is_empty() {
                    parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                    Ok(builder.new_image(
                        entity_id.to_string(),
                        &src,
                        (width_behavior, height_behavior),
                    ))
                } else if !file_path.is_empty() {
                     parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());
                    Ok(builder.new_image_from_file(
                        entity_id.to_string(),
                        &file_path,
                        (width_behavior, height_behavior),
                    ))
                } else {
                    Err(JsonLinesError::MissingAttribute(
                        "src or file_path".to_string(),
                    ))
                }
            }

            "table" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;
                let cols = get_int_attr(&entity.attributes, &["cols", "columns"], 1) as usize;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                let options = TableOptions {
                    header_fill_color: get_string_attr(
                        &entity.attributes,
                        &["header_fill_color", "header_background"],
                        "lightgray",
                    ),
                    fill_color: get_string_attr(
                        &entity.attributes,
                        &["fill_color", "background"],
                        "white",
                    ),
                    border_color: get_string_attr(&entity.attributes, &["border_color"], "black"),
                    border_width: get_int_attr(&entity.attributes, &["border_width"], 1) as usize,
                    cell_padding: get_int_attr(&entity.attributes, &["cell_padding", "padding"], 20)
                        as usize,
                };

                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());
                
                Ok(builder.new_table(entity_id.to_string(), child_nodes?, cols, options))
            }

            "polyline" => {
                let points = get_points_attr(&entity.attributes, "points")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("points".to_string()))?;

                let options = LineOptions {
                    stroke_color: get_string_attr(
                        &entity.attributes,
                        &["stroke_color", "color"],
                        "black",
                    ),
                    stroke_width: get_float_attr(&entity.attributes, &["stroke_width"], 1.0),
                };
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_polyline(entity_id.to_string(), points, options))
            }

            "free_container" => {
                let children = get_array_attr(&entity.attributes, "children")
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let mut positioned_children = Vec::new();
                for child_id in children {
                    let _child_entity = self
                        .entities
                        .get(&child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;
                    
                    let child_node = self.build_entity(&child_id, builder)?;
                    let pos = builder.get_container_relative_position(&child_id);
                    println!("ðŸ“ Free container adding child: {} at position: ({}, {})", child_id, pos.x, pos.y);

                    positioned_children.push((child_node, (pos.x, pos.y)));
                }
                parse_transform_attributes(&entity.attributes, builder, entity_id.to_string());

                Ok(builder.new_free_container(entity_id.to_string(), positioned_children))
            }

            _ => Err(JsonLinesError::UnknownEntityType(
                entity.entity_type.clone(),
            )),
        }
    }

    /// Validate that all child references exist
    pub fn validate(&self) -> Result<(), JsonLinesError> {
        for (id, entity) in &self.entities {
            if let Some(children) = get_array_attr(&entity.attributes, "children") {
                for child_id in children {
                    if !self.entities.contains_key(&child_id) {
                        return Err(JsonLinesError::MissingChild {
                            parent: id.clone(),
                            child: child_id,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    /// Get all entity IDs
    pub fn get_entity_ids(&self) -> Vec<&String> {
        self.entities.keys().collect()
    }
}

/// Builder for creating JSON Lines diagrams
pub struct JsonLinesBuilder {
    entities: Vec<JsonEntity>,
}

impl JsonLinesBuilder {
    pub fn new() -> Self {
        Self {
            entities: Vec::new(),
        }
    }

    /// Create a text entity
    pub fn text(&mut self, id: String, content: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a styled text entity
    pub fn text_styled(
        &mut self,
        id: String,
        content: &str,
        font_size: f64,
        color: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert("content".to_string(), Value::String(content.to_string()));
        attrs.insert(
            "font_size".to_string(),
            Value::Number(serde_json::Number::from_f64(font_size).unwrap()),
        );
        attrs.insert("color".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a box entity
    pub fn box_with(
        &mut self,
        id: String,
        child: String,
        padding: f64,
        background: &str,
    ) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(vec![Value::String(child)]),
        );
        attrs.insert(
            "padding".to_string(),
            Value::Number(serde_json::Number::from_f64(padding).unwrap()),
        );
        attrs.insert(
            "background".to_string(),
            Value::String(background.to_string()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "box".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a vertical stack
    pub fn vstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "vstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a horizontal stack
    pub fn hstack(&mut self, id: String, children: Vec<String>) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "children".to_string(),
            Value::Array(children.into_iter().map(Value::String).collect()),
        );

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "hstack".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a rectangle
    pub fn rect(&mut self, id: String, width: f64, height: f64, color: &str) -> String {
        let mut attrs = Map::new();
        attrs.insert(
            "width".to_string(),
            Value::Number(serde_json::Number::from_f64(width).unwrap()),
        );
        attrs.insert(
            "height".to_string(),
            Value::Number(serde_json::Number::from_f64(height).unwrap()),
        );
        attrs.insert("background".to_string(), Value::String(color.to_string()));

        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "rect".to_string(),
            attributes: attrs,
        });
        id
    }

    /// Create a custom component entity
    pub fn custom_component(
        &mut self,
        id: String,
        component_type: &str,
        attributes: Map<String, Value>,
    ) -> String {
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: component_type.to_string(),
            attributes,
        });
        id
    }

    /// Build and return the JSON Lines string
    pub fn build(&self) -> Result<String, serde_json::Error> {
        let mut lines = Vec::new();
        for entity in &self.entities {
            lines.push(serde_json::to_string(entity)?);
        }
        Ok(lines.join("\n"))
    }

    /// Write to a file
    pub fn write_to_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::create(file_path)?;
        for entity in &self.entities {
            writeln!(file, "{}", serde_json::to_string(entity)?)?;
        }
        Ok(())
    }

    /// Get the root entity ID (first entity)
    pub fn root_id(&self) -> Option<String> {
        self.entities.first().map(|e| e.id.clone())
    }
}

#[derive(Debug)]
pub enum JsonLinesError {
    ParseError { line: usize, message: String },
    EntityNotFound(String),
    MissingAttribute(String),
    InvalidStructure(String),
    UnknownEntityType(String),
    MissingChild { parent: String, child: String },
    NoEntities,
    IoError(String),
}

impl std::fmt::Display for JsonLinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsonLinesError::ParseError { line, message } => {
                write!(f, "Parse error on line {}: {}", line, message)
            }
            JsonLinesError::EntityNotFound(id) => write!(f, "Entity not found: {}", id),
            JsonLinesError::MissingAttribute(attr) => {
                write!(f, "Missing required attribute: {}", attr)
            }
            JsonLinesError::InvalidStructure(msg) => write!(f, "Invalid structure: {}", msg),
            JsonLinesError::UnknownEntityType(t) => write!(f, "Unknown entity type: {}", t),
            JsonLinesError::MissingChild { parent, child } => {
                write!(f, "Parent {} references missing child {}", parent, child)
            }
            JsonLinesError::NoEntities => write!(f, "No entities found"),
            JsonLinesError::IoError(msg) => write!(f, "IO error: {}", msg),
        }
    }
}

impl std::error::Error for JsonLinesError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::DiagramBuilder;
    use serde_json::json;

    #[test]
    fn test_simplified_json_lines_parsing() {
        let input = r#"
{"id":"root","type":"box","padding":10,"background":"white","children":["text1"]}
{"id":"text1","type":"text","content":"Hello World","font_size":16,"color":"blue"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        assert_eq!(root_id, "root");

        parser.validate().unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let _diagram = parser.build(&root_id, &mut builder).unwrap();
    }

    #[test]
    fn test_attribute_aliases() {
        // Test that multiple attribute names work for the same concept
        let input = r#"
{"id":"box1","type":"box","padding":5,"background_color":"red","children":["text1"]}
{"id":"text1","type":"text","text":"Using text instead of content","text_color":"white"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_custom_component_access() {
        // Test that custom components get all attributes
        fn test_component(
            attrs: &Map<String, Value>,
            _builder: &mut DiagramBuilder,
        ) -> Result<DiagramTreeNode, String> {
            // Should be able to access any attribute
            assert!(attrs.contains_key("custom_prop"));
            assert!(attrs.contains_key("width"));
            assert!(attrs.contains_key("background"));

            // Return a dummy node for testing
            Ok(DiagramTreeNode::new(
                EntityType::TextShape,
                "test_component".to_string(),
            ))
        }

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("test_comp", test_component);

        let input = r#"{"id":"test1","type":"test_comp","width":200,"background":"blue","custom_prop":"value"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_streaming_parse() {
        let lines = vec![
            r#"{"id":"e1","type":"text","content":"Hello"}"#.to_string(),
            r#"{"id":"e2","type":"text","content":"World"}"#.to_string(),
            r#"{"id":"e3","type":"hstack","children":["e1","e2"]}"#.to_string(),
        ];

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_lines(lines).unwrap();
        assert_eq!(root_id, "e1");
        parser.validate().unwrap();
    }

    #[test]
    fn test_builder_api() {
        let mut builder = JsonLinesBuilder::new();

        let title = builder.text_styled("title".to_string(), "Document Title", 18.0, "blue");
        let left_text = builder.text("left_text".to_string(), "Left Panel");
        let right_text = builder.text("right_text".to_string(), "Right Panel");

        let left_box = builder.box_with("left_box".to_string(), left_text, 10.0, "lightblue");
        let right_box = builder.box_with("right_box".to_string(), right_text, 10.0, "lightgreen");

        let content = builder.hstack("content".to_string(), vec![left_box, right_box]);
        let footer = builder.text_styled("footer".to_string(), "Footer", 12.0, "gray");

        let _root = builder.vstack("root".to_string(), vec![title, content, footer]);

        let jsonl = builder.build().unwrap();
        println!("Generated JSON Lines:\n{}", jsonl);

        // Parse it back to verify
        let mut parser = JsonLinesParser::new();
        parser.parse_string(&jsonl).unwrap();
        parser.validate().unwrap();
    }

    #[test]
    fn test_complex_attributes() {
        // Test points for polyline
        let input = r#"{"id":"poly1","type":"polyline","points":[[0,0],[10,10],[20,0]],"stroke_color":"red"}"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }

    #[test]
    fn test_size_behaviors() {
        // Test different size behavior specifications
        let input = r#"
{"id":"box1","type":"box","width":"content","height":100,"children":["text1"]}
{"id":"text1","type":"text","content":"Auto-sized"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();

        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        let diagram = parser.build(&root_id, &mut builder);

        assert!(diagram.is_ok());
    }
}

// Example of what an LLM might generate with the new simplified format
pub fn example_llm_generated_jsonl() -> &'static str {
    r#"{"id":"document","type":"box","padding":20,"background":"white","border_color":"gray","children":["layout"]}
{"id":"layout","type":"vstack","children":["header","body","footer"]}
{"id":"header","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"body","type":"hstack","children":["sidebar","main"]}
{"id":"sidebar","type":"box","padding":15,"background":"lightgray","children":["nav"]}
{"id":"nav","type":"vstack","children":["link1","link2","link3"]}
{"id":"link1","type":"text","content":"Home","color":"blue"}
{"id":"link2","type":"text","content":"About","color":"blue"}
{"id":"link3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":15,"background":"white","children":["content"]}
{"id":"content","type":"vstack","children":["article_title","article_body"]}
{"id":"article_title","type":"text","content":"Article Title","font_size":18}
{"id":"article_body","type":"text","content":"This is the main content of the article..."}
{"id":"footer","type":"text","content":"Copyright 2024","font_size":10,"color":"gray"}"#
}



#[cfg(test)]
mod transform_debug_tests {
    use super::*;
    use crate::DiagramBuilder;
    
    #[test]
    fn test_transform_parsing_debug() {
        println!("ðŸ§ª Testing transform parsing...");
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        // Create a simple JSON object with rotation
        let mut attributes = serde_json::Map::new();
        attributes.insert("rotation".to_string(), serde_json::Value::Number(serde_json::Number::from(45)));
        attributes.insert("width".to_string(), serde_json::Value::Number(serde_json::Number::from(60)));
        attributes.insert("height".to_string(), serde_json::Value::Number(serde_json::Number::from(40)));
        
        println!("ðŸ” Attributes: {:?}", attributes);
        
        // Test the function directly
        parse_transform_attributes(&attributes, &mut builder, "test_entity".to_string());
        
        // Check if the transform was applied
        let transform = builder.get_transform("test_entity".to_string());
        println!("ðŸ“ Result transform: {:?}", transform);
        
        // Check if it's not just identity
        let is_identity = transform.matrix[0] == 1.0 && 
                         transform.matrix[1] == 0.0 && 
                         transform.matrix[2] == 0.0 && 
                         transform.matrix[3] == 1.0 &&
                         transform.matrix[4] == 0.0 && 
                         transform.matrix[5] == 0.0;
        
        println!("â“ Is identity transform: {}", is_identity);
        assert!(!is_identity, "Transform should not be identity - rotation should be applied!");
    }
    
    #[test]
    fn test_full_parser_with_rotation() {
        println!("ðŸ§ª Testing full parser with rotation...");
        
        let input = r#"{"id":"test_rect","type":"rect","width":60,"height":40,"background":"red","rotation":45}"#;
        
        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as f32 * 8.0, 16.0));
        
        let diagram = parser.build(&root_id, &mut builder).unwrap();
        
        // Check the transform
        let transform = builder.get_transform("test_rect".to_string());
        println!("ðŸ“ Full parser result transform: {:?}", transform);
        
        let is_identity = transform.matrix[0] == 1.0 && 
                         transform.matrix[1] == 0.0 && 
                         transform.matrix[2] == 0.0 && 
                         transform.matrix[3] == 1.0 &&
                         transform.matrix[4] == 0.0 && 
                         transform.matrix[5] == 0.0;
        
        println!("â“ Full parser - Is identity transform: {}", is_identity);
        assert!(!is_identity, "Full parser should apply rotation!");
    }
}

// Also add this debug function to see what's happening during build_entity calls:
impl JsonLinesParser {
    // Add this method to your existing JsonLinesParser impl
    pub fn debug_build_entity(&mut self, entity_id: &str, builder: &mut DiagramBuilder) -> Result<DiagramTreeNode, JsonLinesError> {
        println!("ðŸ—ï¸ Building entity: {}", entity_id);
        
        let entity = self.entities.get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;
        
        println!("ðŸ—ï¸ Entity type: {}", entity.entity_type);
        println!("ðŸ—ï¸ Entity attributes: {:?}", entity.attributes.keys().collect::<Vec<_>>());
        
        // Check if rotation attribute exists
        if let Some(rotation_value) = entity.attributes.get("rotation") {
            println!("ðŸ”„ Found rotation attribute: {:?}", rotation_value);
        } else {
            println!("âŒ No rotation attribute found");
        }
        
        // Call the original build_entity
        self.build_entity(entity_id, builder)
    }
}
===/src/utils.rs===
use crate::components::*;

===/src/diagram_builder.rs===
use std::{collections::HashMap, sync::Arc};

/**
 * This object encapsulates diagram creation logic.
 * Usage:
 *```rust
 * let builder = DiagramBuilder::new();
 * let group = builder.new_group(
 *   builder.new_box(builder.new_text("Hello World!"), BoxOptions{fill_color: "white".to_string(), stroke_color: "black".to_string(), stroke_width: 1.0, padding: 10.0, round_corners: false, border_radius: 0.0}),
 * );
 *
 *
 *
 */
//use TextOptions
use crate::{components::*, transform::Transform, BoundingBox};

pub struct DiagramBuilder {
    pub measure_text: Option<fn(&str, &TextOptions) -> (Float, Float)>,
    pub entities: Vec<EntityID>,
    // Maps entity IDs to their positions in the container (used in free containers)
    pub container_relative_positions: HashMap<EntityID, Point>,
    pub sizes: HashMap<EntityID, Size>,
    // Maps entity IDS to their transforms for positioning, rotation, scaling, etc.
    pub transforms: HashMap<EntityID, Transform>,
    pub entityTypes: HashMap<EntityID, EntityType>,

    // Components
    boxes: HashMap<EntityID, ShapeBox>,
    rectangles: HashMap<EntityID, ShapeRect>,
    groups: HashMap<EntityID, ShapeGroup>,
    texts: HashMap<EntityID, ShapeText>,
    textlines: HashMap<EntityID, TextLine>,
    horizontal_stacks: HashMap<EntityID, HorizontalStack>,
    vertical_stacks: HashMap<EntityID, VerticalStack>,
    ellipses: HashMap<EntityID, ShapeEllipse>,
    lines: HashMap<EntityID, ShapeLine>,
    arrows: HashMap<EntityID, ShapeArrow>,
    tables: HashMap<EntityID, Table>,
    images: HashMap<EntityID, ShapeImage>,
    polylines: HashMap<EntityID, PolyLine>,
    free_containers: HashMap<EntityID, FreeContainer>,
    arcs: HashMap<EntityID, ShapeArc>,
    spacers: HashMap<EntityID, ShapeSpacer>,
    pub custom_components: CustomComponentRegistry,
}

// Stores the type of entity and the index of the entity in the corresponding vector
// Used when building the diagram tree.
#[derive(Debug, Clone)]
pub struct DiagramTreeNode {
    pub entity_type: EntityType,
    // Index of the entity in the corresponding vector
    pub entity_id: EntityID,
    pub children: Vec<Box<DiagramTreeNode>>,
}

impl DiagramTreeNode {
    pub fn new(entity_type: EntityType, id: EntityID) -> DiagramTreeNode {
        DiagramTreeNode {
            entity_type,
            entity_id: id,
            children: Vec::new(),
        }
    }

    fn add_child(&mut self, child: DiagramTreeNode) {
        self.children.push(Box::new(child));
    }
}

/* New architecture (data driven)
 * We have an array of entities, each entity is an id
 * The id has 64 bits, we can use 32 bits for the type and 32 bits for the index
 * To get the type: id >> 32
 * To get the index: id & 0xFFFFFFFF
 * We have a type enum with all the types
*/

impl DiagramBuilder {
    pub fn new() -> DiagramBuilder {
        DiagramBuilder {
            entityTypes: HashMap::<EntityID, EntityType>::new(),
            measure_text: Some(|_text, _text_options| (0.0, 0.0)),
            entities: Vec::new(),
            // store desired positions relative to the container
            container_relative_positions: HashMap::new(),
            sizes: HashMap::new(),
            transforms: HashMap::new(),
            boxes: HashMap::new(),
            rectangles: HashMap::new(),
            groups: HashMap::new(),
            texts: HashMap::new(),
            textlines: HashMap::new(),
            horizontal_stacks: HashMap::new(),
            vertical_stacks: HashMap::new(),
            ellipses: HashMap::new(),
            lines: HashMap::new(),
            arrows: HashMap::new(),
            tables: HashMap::new(),
            images: HashMap::new(),
            polylines: HashMap::new(),
            free_containers: HashMap::new(),
            arcs: HashMap::new(),
            spacers: HashMap::new(),
            custom_components: CustomComponentRegistry::new(),
        }
    }

    pub fn clear_cache(&mut self) {
        // Clear core entity data
        self.entities.clear();
        self.container_relative_positions.clear();
        self.sizes.clear();
        self.entityTypes.clear();

        // Clear all component hashmaps
        self.boxes.clear();
        self.rectangles.clear();
        self.groups.clear();
        self.texts.clear();
        self.textlines.clear();
        self.horizontal_stacks.clear();
        self.vertical_stacks.clear();
        self.ellipses.clear();
        self.lines.clear();
        self.arrows.clear();
        self.tables.clear();
        self.images.clear();
        self.polylines.clear();
        self.free_containers.clear();
        self.arcs.clear();

        // Note: We don't clear custom_components as those are reusable function definitions
        // Note: We don't clear measure_text function as it should persist across diagrams

        println!("DiagramBuilder cache cleared - all entities and components removed");
    }

    pub fn clear_entities_only(&mut self) {
        self.entities.clear();
        self.sizes.clear();
        self.entityTypes.clear();
        self.container_relative_positions.clear();
        println!("DiagramBuilder entities cleared (components preserved)");
    }

    /// Register a custom component with the builder
    pub fn register_custom_component<F>(&mut self, component_type: &str, factory: F)
    where
        F: Fn(
                &serde_json::Map<String, serde_json::Value>,
                &mut DiagramBuilder,
            ) -> Result<crate::diagram_builder::DiagramTreeNode, String>
            + Send
            + Sync
            + 'static,
    {
        self.custom_components.register(component_type, factory);
    }

    /// Check if a custom component is registered
    pub fn has_custom_component(&self, component_type: &str) -> bool {
        self.custom_components.has_component(component_type)
    }

    pub fn get_custom_component_types(&self) -> Vec<&String> {
        self.custom_components.get_registered_types()
    }

    pub fn create_custom_component(
        &mut self,
        component_type: &str,
        options: &serde_json::Map<String, serde_json::Value>,
    ) -> Result<DiagramTreeNode, String> {
        if !self.custom_components.has_component(component_type) {
            return Err(format!(
                "Custom component '{}' not registered",
                component_type
            ));
        }

        let factory = { self.custom_components.get(component_type).unwrap().clone() };

        factory(options, self)
    }

    /* Create a new entity of a given type
     * Returns the id of the new entity
     * We have another array with the positions of the entities
     * in the same index. So they are fast to access
     */
    pub fn new_entity(&mut self, id: EntityID, entity_type: EntityType) -> EntityID {
        println!("Creating new entity with id {}", id);
        self.entities.push(id.clone());
        self.sizes.insert(id.clone(), Size::new(0.0, 0.0));
        self.entityTypes.insert(id.clone(), entity_type.clone());
        if !self.transforms.contains_key(&id) {
            self.transforms.insert(id.clone(), Transform::identity());
        }
        id
    }

    //set the measure_text function
    pub fn set_measure_text_fn(&mut self, measure_text: fn(&str, &TextOptions) -> (Float, Float)) {
        println!("Setting measure text function");
        self.measure_text = Option::Some(measure_text);
    }

    // Replace position methods with transform methods
    pub fn get_transform(&self, entity_id: EntityID) -> Transform {
        self.transforms
            .get(&entity_id)
            .cloned()
            .unwrap_or_else(Transform::identity)
    }

    pub fn set_transform(&mut self, entity_id: EntityID, transform: Transform) {
        self.transforms.insert(entity_id, transform);
    }

    // Convenience methods for common operations
    pub fn get_position(&self, entity_id: EntityID) -> (Float, Float) {
        let transform = self.get_transform(entity_id);
        (transform.matrix[4], transform.matrix[5]) // e, f components
    }

    // pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
    //     let current = self.get_transform(entity_id.clone()).clone();
    //     let translation = Transform::translation(x, y);
    //     // Preserve existing transform but update translation
    //     let mut new_transform = current;
    //     new_transform.matrix[4] = x; // e
    //     new_transform.matrix[5] = y; // f
    //     self.set_transform(entity_id, new_transform);
    // }

    pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        let current = self.get_transform(entity_id.clone());
        println!(
            "ðŸ“ set_position called for {} - pos: ({}, {}) - before: {:?}",
            entity_id, x, y, current
        );

        // Preserve existing rotation/scale, just update translation
        let mut new_transform = current;
        new_transform.matrix[4] = x; // e - translation X
        new_transform.matrix[5] = y; // f - translation Y

        println!(
            "ðŸ“ set_position result for {} - after: {:?}",
            entity_id, new_transform
        );
        self.set_transform(entity_id, new_transform);
    }

    // Set the position relative to the container  (used in free containers)
    pub fn set_container_relative_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        self.container_relative_positions
            .insert(entity_id, Point::new(x, y));
    }

    pub fn get_container_relative_position(&self, entity_id: &EntityID) -> Point {
        self.container_relative_positions
            .get(entity_id)
            .cloned()
            .unwrap_or(Point::new(0.0, 0.0))
    }

    pub fn set_rotation(&mut self, entity_id: EntityID, angle_degrees: Float) {
        let pos = self.get_position(entity_id.clone());
        let size = self.get_size(entity_id.clone());

        // Rotate around center of element
        let center_x = size.0 / 2.0;
        let center_y = size.1 / 2.0;

        let translate_to_origin = Transform::translation(-center_x, -center_y);
        let rotation = Transform::rotation(angle_degrees);
        let translate_back = Transform::translation(center_x, center_y);
        let position = Transform::translation(pos.0, pos.1);

        // FIXED: Correct order - center operations first, then position
        let transform = translate_to_origin
            .combine(&rotation)
            .combine(&translate_back)
            .combine(&position);

        self.set_transform(entity_id, transform);
    }

    pub fn set_scale(&mut self, entity_id: EntityID, sx: Float, sy: Float) {
        let current = self.get_transform(entity_id.clone()).clone();
        let scale = Transform::scale(sx, sy);
        self.set_transform(entity_id, current.combine(&scale));
    }

    // Get effective bounding box considering transform
    pub fn get_effective_bounds(&self, entity_id: EntityID) -> BoundingBox {
        let transform = self.get_transform(entity_id.clone());
        let size = self.get_size(entity_id);
        transform.transform_rect(0.0, 0.0, size.0, size.1)
    }

    //get the size of an entity
    pub fn get_size(&self, entity_id: EntityID) -> (Float, Float) {
        let size = self.sizes.get(&entity_id).unwrap();
        (size.w, size.h)
    }

    pub fn set_size(&mut self, entity_id: EntityID, width: Float, height: Float) {
        let size = self.sizes.get_mut(&entity_id).unwrap();
        size.w = width;
        size.h = height;
    }

    pub fn new_spacer(&mut self, id: EntityID, options: SpacerOptions) -> DiagramTreeNode {
        let spacer_id = self.new_entity(id, EntityType::SpacerShape);
        let spacer = ShapeSpacer::new(spacer_id.clone(), options);
        self.spacers.insert(spacer_id.clone(), spacer);
        DiagramTreeNode::new(EntityType::SpacerShape, spacer_id)
    }

    /**
     * Architecture note:
     * the new_element methods should only create the necessary elements
     * without calculating the position and size.
     * That will be done in the layout layer.
     */

    // Wraps an element in a box
    pub fn new_box(
        &mut self,
        id: EntityID,
        child: DiagramTreeNode,
        options: BoxOptions,
    ) -> DiagramTreeNode {
        let box_id = self.new_entity(id.clone(), EntityType::BoxShape);

        let sbox = ShapeBox::new(box_id.clone(), child.entity_id.clone(), options);
        self.boxes.insert(box_id.clone(), sbox);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::BoxShape,
            entity_id: box_id.clone(),
            children: Vec::new(),
        };
        node.children.push(Box::new(child.clone()));
        node
    }

    // Add the new_arc method
    pub fn new_arc(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        start_angle: Float,
        end_angle: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let arc_id = self.new_entity(id, EntityType::ArcShape);
        let arc = ShapeArc::new(
            arc_id.clone(),
            center,
            radius,
            start_angle,
            end_angle,
            options,
        );
        self.arcs.insert(arc_id.clone(), arc);
        DiagramTreeNode::new(EntityType::ArcShape, arc_id)
    }

    // Add convenience methods for common arc types
    pub fn new_arc_degrees(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        start_degrees: Float,
        end_degrees: Float,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        self.new_arc(id, center, radius, start_degrees, end_degrees, options)
    }

    pub fn new_semicircle(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        facing_up: bool,
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = if facing_up {
            (0.0, 180.0) // Top semicircle
        } else {
            (180.0, 360.0) // Bottom semicircle
        };
        self.new_arc(id, center, radius, start, end, options)
    }

    pub fn new_quarter_circle(
        &mut self,
        id: EntityID,
        center: (Float, Float),
        radius: Float,
        quadrant: u8, // 1=top-right, 2=top-left, 3=bottom-left, 4=bottom-right
        options: ArcOptions,
    ) -> DiagramTreeNode {
        let (start, end) = match quadrant {
            1 => (0.0, 90.0),    // Top-right
            2 => (90.0, 180.0),  // Top-left
            3 => (180.0, 270.0), // Bottom-left
            4 => (270.0, 360.0), // Bottom-right
            _ => (0.0, 90.0),    // Default to top-right
        };
        self.new_arc(id, center, radius, start, end, options)
    }

    // Creates a new Vertical stack.
    pub fn new_vstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        horizontal_alignment: HorizontalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::VerticalStackShape);
        let mut vstack = VerticalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            horizontal_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::VerticalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            vstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.vertical_stacks.insert(stack_id.clone(), vstack);

        node
    }

    // Creates a new Vertical stack.
    pub fn new_hstack(
        &mut self,
        id: EntityID,
        children: Vec<DiagramTreeNode>,
        vertical_alignment: VerticalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(id.clone(), EntityType::HorizontalStackShape);
        let mut hstack = HorizontalStack {
            entity: stack_id.clone(),
            elements: Vec::new(),
            vertical_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::HorizontalStackShape,
            entity_id: stack_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            hstack.elements.push(child.entity_id.clone());
            node.add_child(child)
        }

        self.horizontal_stacks.insert(stack_id, hstack);

        node
    }

    pub fn new_rectangle(&mut self, id: EntityID, options: RectOptions) -> DiagramTreeNode {
        let rect_id = self.new_entity(id.clone(), EntityType::RectShape);
        let rect = ShapeRect::new(rect_id.clone(), options);
        self.rectangles.insert(rect_id.clone(), rect);
        DiagramTreeNode::new(EntityType::RectShape, rect_id.clone())
    }

    // Creates a new Text element
    // text: the text to display
    // options: the options for the text
    // ```rust
    // let text = session.new_text("Hello World", TextOptions::new());
    // ```
    pub fn new_text(&mut self, id: EntityID, text: &str, options: TextOptions) -> DiagramTreeNode {
        let text_id = self.new_entity(id, EntityType::TextShape);
        //create the lines
        let text_lines = textwrap::wrap(&text, options.line_width);
        let lines: Vec<EntityID> = text_lines
            .iter()
            .enumerate()
            .map(|(i, line)| {
                let line_id = format!("text-{}-line-{}", text_id.clone(), i); // Generate a new ID for each line using the index
                self.new_entity(line_id.clone(), EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id.clone(),
                    text: line.to_string(),
                };
                self.textlines.insert(line_id.clone(), text_line.clone());
                line_id
            })
            .collect();

        let text = ShapeText::new(text_id.clone(), text, options, &lines);
        self.texts.insert(text_id.clone(), text);
        DiagramTreeNode::new(EntityType::TextShape, text_id)
    }

    pub fn new_line(
        &mut self,
        id: EntityID,
        start: (Float, Float),
        end: (Float, Float),
        options: LineOptions,
    ) -> DiagramTreeNode {
        let line_id = self.new_entity(id, EntityType::LineShape);
        let line = ShapeLine::new(line_id.clone(), start, end, options);
        self.lines.insert(line_id.clone(), line);
        println!("Creating new line with id {}", line_id.clone());
        DiagramTreeNode::new(EntityType::LineShape, line_id)
    }

    pub fn new_elipse(
        &mut self,
        id: EntityID,
        radius: (Float, Float),
        options: EllipseOptions,
    ) -> DiagramTreeNode {
        let ellipse_id = self.new_entity(id, EntityType::EllipseShape);
        let ellipse = ShapeEllipse::new(ellipse_id.clone(),radius, options);
        self.ellipses.insert(ellipse_id.clone(), ellipse);
        DiagramTreeNode::new(EntityType::EllipseShape, ellipse_id.clone())
    }

    pub fn new_image(
        &mut self,
        id: EntityID,
        image_data: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::new(image_id.clone(), image_data.to_string(), size);
        self.images.insert(image_id.clone(), image);
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    pub fn new_image_from_file(
        &mut self,
        id: EntityID,
        file_path: &str,
        size: (SizeBehavior, SizeBehavior),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(id, EntityType::ImageShape);
        let image = ShapeImage::from_file(image_id.clone(), file_path.to_string(), size);
        self.images.insert(image_id.clone(), image.clone());
        DiagramTreeNode::new(EntityType::ImageShape, image_id.clone())
    }

    // Creates a new Group.
    pub fn new_group(&mut self, id: EntityID, children: Vec<DiagramTreeNode>) -> DiagramTreeNode {
        let group_id = self.new_entity(id, EntityType::GroupShape);
        let mut sgroup = ShapeGroup {
            entity: group_id.clone(),
            elements: Vec::new(),
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::GroupShape,
            entity_id: group_id.clone(),
            children: Vec::new(),
        };

        //set children
        for child in children {
            sgroup.elements.push(child.entity_id.clone());
            node.add_child(child.clone())
        }

        self.groups.insert(group_id, sgroup);

        node
    }

    pub fn new_table(
        &mut self,
        id: EntityID,
        cells: Vec<DiagramTreeNode>,
        cols: usize,
        options: TableOptions,
    ) -> DiagramTreeNode {
        let mut cell_ids = Vec::new();
        for cell in &cells {
            cell_ids.push(cell.entity_id.clone());
        }
        //create entities for the col and row lines
        let mut col_lines = Vec::new();
        for i in 0..cols {
            let line_id = format!("{}-col-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(line_id.clone(), (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id.clone(), line);
            col_lines.push(line_id.clone());
        }
        let num_rows = cells.len() / cols;
        let mut row_lines = Vec::new();
        for i in 0..num_rows + 1 {
            let line_id = format!("{}-row-line-{}", id.clone(), i);
            self.new_entity(line_id.clone(), EntityType::LineShape);
            let line = ShapeLine::new(line_id.clone(), (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id.clone(), line);
            row_lines.push(line_id.clone());
        }

        //Add a rectangle for the header row
        let header_id = format!("{}-header", id);
        self.new_entity(header_id.clone(), EntityType::RectShape);
        // Create the rectangle for the header row
        let header = self.new_rectangle(
            header_id,
            RectOptions {
                fill_color: Fill::Color(options.header_fill_color.clone()),
                stroke_color: String::from("black"),
                stroke_width: 1.0,
                ..Default::default()
            },
        );

        let table_id = format!("{}-table", id.clone());
        self.new_entity(table_id.clone(), EntityType::TableShape);
        let table = Table::new(
            table_id.clone(),
            cell_ids,
            col_lines.clone(),
            row_lines.clone(),
            cols,
            header.entity_id.clone(),
            options.clone(),
        );

        self.tables.insert(table_id.clone(), table);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::TableShape,
            entity_id: table_id.clone(),
            children: Vec::new(),
        };

        // Add the header before the cells, otherwise it can cover the cells
        node.add_child(DiagramTreeNode::new(
            EntityType::RectShape,
            header.entity_id.clone(),
        ));

        for child in cells {
            node.add_child(child)
        }

        //add the lines
        for line in col_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }
        for line in row_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }

        node
    }

    pub fn new_polyline(
        &mut self,
        id: EntityID,
        points: Vec<(Float, Float)>,
        options: LineOptions,
    ) -> DiagramTreeNode {
        self.new_entity(id.clone(), EntityType::PolyLine);
        let polyline = PolyLine::new(id.clone(), points, options);
        self.polylines.insert(id.clone(), polyline);
        DiagramTreeNode::new(EntityType::PolyLine, id.clone())
    }

    /// Creates a new FreeContainer with all children at once
    pub fn new_free_container(
        &mut self,
        id: EntityID,
        children_with_positions: Vec<(DiagramTreeNode, (Float, Float))>,
    ) -> DiagramTreeNode {
        let container_id = self.new_entity(id.clone(), EntityType::FreeContainer);

        // Create the free container
        let mut container = FreeContainer::new(container_id.clone());

        // Create the node for the tree
        let mut node = DiagramTreeNode {
            entity_type: EntityType::FreeContainer,
            entity_id: container_id.clone(),
            children: Vec::new(),
        };

        // Add all children with their positions
        for (child, position) in children_with_positions {
            container.add_child(child.entity_id.clone(), position);
            node.add_child(child);
        }

        // Store the container
        self.free_containers.insert(container_id.clone(), container);

        node
    }
}

// element list accessors
impl DiagramBuilder {
    pub fn get_text(&self, id: EntityID) -> &ShapeText {
        &self.texts[&id]
    }

    pub fn add_text(&mut self, id: EntityID, text: ShapeText) {
        self.texts.insert(id, text);
    }

    pub fn get_group(&self, id: EntityID) -> &ShapeGroup {
        &self.groups[&id]
    }

    pub fn get_horizontal_stack(&self, id: EntityID) -> &HorizontalStack {
        &self.horizontal_stacks[&id]
    }

    pub fn get_vertical_stack(&self, id: EntityID) -> &VerticalStack {
        &self.vertical_stacks[&id]
    }

    pub fn get_ellipse(&self, id: EntityID) -> &ShapeEllipse {
        &self.ellipses[&id]
    }

    pub fn get_line(&self, id: EntityID) -> &ShapeLine {
        &self.lines[&id]
    }

    pub fn get_rectangle(&self, id: EntityID) -> &ShapeRect {
        &self.rectangles[&id]
    }

    pub fn get_text_line(&self, id: EntityID) -> &TextLine {
        &self.textlines[&id]
    }
    pub fn add_text_line(&mut self, id: EntityID, text_line: TextLine) {
        self.textlines.insert(id, text_line);
    }
    pub fn get_text_line_mut(&mut self, id: EntityID) -> Option<&mut TextLine> {
        self.textlines.get_mut(&id)
    }

    pub fn get_arrow(&self, id: EntityID) -> &ShapeArrow {
        &self.arrows[&id]
    }

    pub fn get_table(&self, id: EntityID) -> &Table {
        &self.tables[&id]
    }

    pub fn get_image(&self, id: EntityID) -> &ShapeImage {
        &self.images[&id]
    }

    pub fn get_box(&self, id: EntityID) -> &ShapeBox {
        &self.boxes[&id]
    }

    pub fn get_polyline(&self, id: EntityID) -> &PolyLine {
        &self.polylines[&id]
    }

    pub fn get_free_container(&self, id: EntityID) -> &FreeContainer {
        &self.free_containers[&id]
    }

    pub fn get_free_container_mut(&mut self, id: EntityID) -> &mut FreeContainer {
        self.free_containers.get_mut(&id).unwrap()
    }

    pub fn get_arc(&self, id: EntityID) -> &ShapeArc {
        &self.arcs[&id]
    }

    pub fn get_spacer(&self, id: EntityID) -> &ShapeSpacer {
        &self.spacers[&id]
    }

    pub fn get_custom_component(
        &self,
        component_type: &str,
    ) -> Option<
        &Arc<
            dyn Fn(
                    &serde_json::Map<String, serde_json::Value>,
                    &mut DiagramBuilder,
                ) -> Result<DiagramTreeNode, String>
                + Send
                + Sync,
        >,
    > {
        self.custom_components.get(component_type)
    }
}

//test
#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_session() {
        let mut session = DiagramBuilder::new();

        session.set_measure_text_fn(|text, text_options| {
            let textW: Float = text.len() as Float * text_options.font_size as Float;

            (textW, text_options.font_size.into())
        });
        let (w, h) = session.measure_text.unwrap()(
            "hello",
            &TextOptions {
                font_size: 12.0,
                ..Default::default()
            },
        );
        assert_eq!(w, 60.0);
        assert_eq!(h, 12.0);
    }
}

//Component registration tests
#[cfg(test)]
mod component_registration_tests {
    use serde_json::{json, Map, Value};

    use super::*;

    /// Custom Component 1: Badge
    /// Creates a rounded pill-shaped element with text
    fn create_badge_component(
        attrs: &Map<String, Value>,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, String> {
        println!("ðŸ·ï¸  Creating badge component with attrs: {:?}", attrs);

        // Extract attributes
        let text = get_string_attr(attrs, "text", "Badge");
        let background = get_string_attr(attrs, "background", "blue");
        let color = get_string_attr(attrs, "color", "white");
        let font_size = get_float_attr(attrs, "font_size", 12.0);
        let padding = get_float_attr(attrs, "padding", 8.0);

        // Create text element
        let text_options = TextOptions {
            font_family: "Arial".to_string(),
            font_size,
            text_color: color,
            line_width: 200,
            line_spacing: 0.0,
        };
        let text_node = builder.new_text("text".to_string(), &text, text_options);

        // Wrap in rounded box
        let box_options = BoxOptions {
            fill_color: Fill::Color(background),
            stroke_color: "transparent".to_string(),
            stroke_width: 0.0,
            padding,
            border_radius: font_size,               // Make it pill-shaped
            width_behavior: SizeBehavior::Content,  // Auto width based on text
            height_behavior: SizeBehavior::Content, // Auto height based on text
        };
        let badge = builder.new_box("container".to_string(), text_node, box_options);

        println!("âœ… Badge '{}' created successfully", text);
        Ok(badge)
    }

    // Helper function to extract attributes (since we can't access CustomComponentRegistry helpers directly)
    fn get_string_attr(attrs: &Map<String, Value>, key: &str, default: &str) -> String {
        attrs
            .get(key)
            .and_then(|v| v.as_str())
            .unwrap_or(default)
            .to_string()
    }

    fn get_float_attr(attrs: &Map<String, Value>, key: &str, default: f64) -> Float {
        attrs.get(key).and_then(|v| v.as_f64()).unwrap_or(default) as Float
    }

    fn get_bool_attr(attrs: &Map<String, Value>, key: &str, default: bool) -> bool {
        attrs.get(key).and_then(|v| v.as_bool()).unwrap_or(default)
    }

    fn get_int_attr(attrs: &Map<String, Value>, key: &str, default: i64) -> i64 {
        attrs.get(key).and_then(|v| v.as_i64()).unwrap_or(default)
    }

    #[test]
    fn test_badge_component() {
        let mut builder = DiagramBuilder::new();
        builder.set_measure_text_fn(|text, _| (text.len() as Float * 8.0, 16.0));
        builder.register_custom_component("badge", create_badge_component);

        let attrs = json!({
            "text": "Test",
            "background": "blue"
        })
        .as_object()
        .unwrap()
        .clone();

        let result = builder.create_custom_component("badge", &attrs);
        assert!(result.is_ok());
        let badge_node = result.unwrap();
        assert_eq!(badge_node.entity_type, EntityType::BoxShape);
        assert!(builder.has_custom_component("badge"));
        let badge = builder.get_box(badge_node.entity_id);
        assert_eq!(
            badge.box_options.fill_color,
            Fill::Color("blue".to_string())
        );
    }

    #[test]
    fn test_all_components_registration() {
        let mut builder = DiagramBuilder::new();
        builder.register_custom_component("badge", create_badge_component);

        let types = builder.get_custom_component_types();
        assert_eq!(types.len(), 1);
        assert!(builder.has_custom_component("badge"));
    }
}

