===/Cargo.toml===
[package]
name = "volare_engine_layout"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.0"

===/target/CACHEDIR.TAG===
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by cargo.
# For information about cache directory tags see https://bford.info/cachedir/

===/target/debug/.fingerprint/layout-base-d68186a17e09bb62/lib-layout-base===
e1fb921afd0324c9
===/target/debug/.fingerprint/layout-base-d68186a17e09bb62/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/.fingerprint/layout-base-3046ca7ae66b4c03/test-lib-layout-base===
c2a4ddc523aefc46
===/target/debug/.fingerprint/layout-base-3046ca7ae66b4c03/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/.fingerprint/layout-base-eed9ca7d180c0e5c/lib-layout-base===
9111b90f7f500e00
===/target/debug/.fingerprint/layout-base-eed9ca7d180c0e5c/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/.fingerprint/layout-base-65ec7ba58964b4ee/test-lib-layout-base===
23f059a2e9751bb5
===/target/debug/.fingerprint/layout-base-65ec7ba58964b4ee/invoked.timestamp===
This file has an mtime of when this was started.
===/target/debug/deps/layout_base-65ec7ba58964b4ee.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-65ec7ba58964b4ee.rmeta: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-65ec7ba58964b4ee.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/target/debug/deps/layout_base-eed9ca7d180c0e5c.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-eed9ca7d180c0e5c.rmeta: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/liblayout_base-eed9ca7d180c0e5c.rlib: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-eed9ca7d180c0e5c.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/target/debug/deps/layout_base-3046ca7ae66b4c03.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-3046ca7ae66b4c03: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-3046ca7ae66b4c03.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/target/debug/deps/layout_base-d68186a17e09bb62.d===
/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-d68186a17e09bb62.rmeta: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

/Users/hugo/repos/github.com/volare/volare-visual-engine/volare-engine-layout/target/debug/deps/layout_base-d68186a17e09bb62.d: src/lib.rs src/diagram_layout.rs src/location.rs src/shape_box.rs src/bounding_box.rs src/shape_text.rs src/shape_group.rs src/session.rs

src/lib.rs:
src/diagram_layout.rs:
src/location.rs:
src/shape_box.rs:
src/bounding_box.rs:
src/shape_text.rs:
src/shape_group.rs:
src/session.rs:

===/Cargo.lock===
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "layout-base"
version = "0.1.0"

===/.gitignore===
/target
/Cargo.lock

===/.github/workflows/test-and-build.yml===
# test rust project and build

name: Test and Build

on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test
      - name: Build
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release





===/src/layout.rs===
/* Layout calculation for each type of entity */

use crate::components::Float;
use crate::{HorizontalAlignment, VerticalAlignment};
use crate::{
    diagram_builder::DiagramTreeNode, DiagramBuilder, EntityID, EntityType, FreeContainer,
    HorizontalStack, PolyLine, ShapeArrow, ShapeBox, ShapeEllipse, ShapeGroup, ShapeImage,
    ShapeLine, ShapeText, Table, VerticalStack,
};

/* The box layout includes the padding and the dimensions
of the wrapped element
The wrapped element position and size should be updated before calling this function.
The wrapped element position is relative to the box position.
*/
pub fn layout_box(session: &mut DiagramBuilder, shape_box: &ShapeBox) {
    println!("Box: {:?}", shape_box);
    //get the wrapped element dimensions
    let wrapped_elem_size = session.get_size(shape_box.wrapped_entity);
    println!("Box Wrapped elem size: {:?}", wrapped_elem_size);

    //print element dimensions
    println!(
        "Box: {}, {}, {}, {}",
        shape_box.entity, wrapped_elem_size.0, wrapped_elem_size.1, shape_box.box_options.padding
    );
    //set the box dimensions
    session.set_size(
        shape_box.entity,
        wrapped_elem_size.0 + shape_box.box_options.padding * 2.0,
        wrapped_elem_size.1 + shape_box.box_options.padding * 2.0,
    );
    //Update the wrapped element position
    session.set_position(
        shape_box.wrapped_entity,
        shape_box.box_options.padding,
        shape_box.box_options.padding,
    );
}

/**
 * Update the group size based on the size of the elements.
 * Group elements must be positioned before calling this function.
 * (Doesn't update the position of the elements)
 */
pub fn layout_group(session: &mut DiagramBuilder, shape_group: &ShapeGroup) {
    //update group dimensions
    let mut width = 0.0;
    let mut height = 0.0;
    for elem in shape_group.elements.iter() {
        let elem_size = session.get_size(*elem);
        if elem_size.0 > width {
            width = elem_size.0;
        }
        if elem_size.1 > height {
            height = elem_size.1;
        }
    }
    session.set_size(shape_group.entity, width, height);
}

pub fn layout_text(session: &mut DiagramBuilder, shape_text: &ShapeText) {
    // let (w, h) = session.measure_text.unwrap()(&shape_text.text, &shape_text.text_options);
    // session.set_size(shape_text.entity, w, h);
    /* for each line in lines, get the size and use it to position the next */
    {
        println!("Text: {:?}", shape_text);
        let mut y = 0.0;
        let mut max_line_width = 0.0;
        for line in shape_text.lines.iter() {
            println!("Line: {:?}", line);
            let textLine = session.get_text_line(*line);
            let line_size = session.measure_text.unwrap()(&textLine.text, &shape_text.text_options);
            if line_size.0 > max_line_width {
                max_line_width = line_size.0;
            }
            session.set_position(*line, 0.0, y);
            session.set_size(*line, line_size.0, line_size.1);
            y += line_size.1 + shape_text.text_options.line_spacing as Float;
        }
        y -= shape_text.text_options.line_spacing as Float; // Adjust for the last line spacing

        println!("max_line_width: {}", max_line_width);
        //set the size of the text element
        println!(
            "Setting size to text entity: {} - {} {}",
            shape_text.entity, max_line_width, y
        );
        session.set_size(shape_text.entity, max_line_width, y);
    }
}

/**
 * Updates the size of the line entity based on the start and end points
 */
pub fn layout_line(session: &mut DiagramBuilder, shape_line: &ShapeLine) {
    let start = shape_line.start;
    let end = shape_line.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_line.entity,
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_line.entity, x, y);
}

/**
 * Updates the size of the arrow entity based on the start and end points
 */
pub fn layout_arrow(session: &mut DiagramBuilder, shape_arrow: &ShapeArrow) {
    let start = shape_arrow.start;
    let end = shape_arrow.end;
    //the line x is the minimum of the start and end x
    let x = start.0.min(end.0);
    let y = start.1.min(end.1);

    session.set_size(
        shape_arrow.entity,
        (end.0 - start.0).abs(),
        (end.1 - start.1).abs(),
    );

    session.set_position(shape_arrow.entity, x, y);
}

/**
 * Updates the size of the ellipse entity based on the horizontal and vertical radius
 * radius.0 is the horizontal radius and radius.1 is the vertical radius
 * The position of the ellipse is the top left corner of the bounding box
 */
pub fn layout_ellipse(session: &mut DiagramBuilder, shape_ellipse: &ShapeEllipse) {
    let w = shape_ellipse.radius.0 * 2.0;
    let h = shape_ellipse.radius.1 * 2.0;
    session.set_size(shape_ellipse.entity, w, h);
}

pub fn layout_rect(session: &mut DiagramBuilder, entity: EntityID, width: Float, height: Float) {
    //set the size of the rect
    session.set_size(entity, width, height);
}

/**
 * Sets the image entity size to the preferred size
 */
pub fn layout_image(session: &mut DiagramBuilder, shape_image: &ShapeImage) {
    session.set_size(
        shape_image.entity,
        shape_image.preferred_size.0,
        shape_image.preferred_size.1,
    );
}

/**
 * Updates the position of the elements in the vertical stack
 * and the size of the vertical stack
 */
pub fn layout_vertical_stack(session: &mut DiagramBuilder, vertical_stack: &VerticalStack) {
    let mut y = 0.0;
    let mut width = 0.0;
    for elem in vertical_stack.elements.iter() {
        println!("DEBUG:::y: {}", y);
        let elem_size = session.get_size(*elem);
        session.set_position(*elem, 0.0, y);
        y += elem_size.1;
        if elem_size.0 > width {
            width = elem_size.0;
        }
    }
    session.set_size(vertical_stack.entity, width, y);

      // Second pass: only adjust x positions if alignment is specified
        for elem in vertical_stack.elements.iter() {
            let elem_size = session.get_size(*elem);
            let current_pos = session.get_position(*elem);
            let x = match vertical_stack.horizontal_alignment {
                HorizontalAlignment::Left => 0.0,
                HorizontalAlignment::Center => (width - elem_size.0) / 2.0,
                HorizontalAlignment::Right => width - elem_size.0,
            };
            session.set_position(*elem, x, current_pos.1); // Update x, keep y
        }
}

pub fn layout_horizontal_stack(session: &mut DiagramBuilder, horizontal_stack: &HorizontalStack) {
    let mut x = 0.0;
    let mut height = 0.0;
    for elem in horizontal_stack.elements.iter() {
        let elem_size = session.get_size(*elem);
        session.set_position(*elem, x, 0.0);
        x += elem_size.0;
        if elem_size.1 > height {
            height = elem_size.1;
        }
    }
    session.set_size(horizontal_stack.entity, x, height);

    // Second pass: only adjust y positions, keep existing x positions
        for elem in horizontal_stack.elements.iter() {
            let elem_size = session.get_size(*elem);
            let current_pos = session.get_position(*elem); // Get the x we already set
            let y = match horizontal_stack.vertical_alignment {
                VerticalAlignment::Top => 0.0,
                VerticalAlignment::Center => (height - elem_size.1) / 2.0,
                VerticalAlignment::Bottom => height - elem_size.1,
            };
            session.set_position(*elem, current_pos.0, y); // Keep x, update y
        }
}

/**
 * Calculates the layout for each of the cells according to table rules:
 * - Cells in the same column have the same width (eq to the max of widths)
 * - Cells in the same row have the same height (eq to the max of heights)
 * - Rows on top of each other
 * - Cols to the right of each other
 * - The sizes of the internal elements should be previously computed for this to work
 */
pub fn layout_table(session: &mut DiagramBuilder, table: &Table) {
    //we need to group elements by row and column, calculate their
    //natural sizes and then update their rows and columns
    let mut rows: Vec<Vec<EntityID>> = Vec::new();
    let mut cols: Vec<Vec<EntityID>> = Vec::new();
    let mut row_heights: Vec<Float> = Vec::new();
    let mut col_widths: Vec<Float> = Vec::new();

    // Add variables to store line positions
    let mut horizontal_line_positions: Vec<Float> = Vec::new();
    let mut vertical_line_positions: Vec<Float> = Vec::new();

    //initialize rows and cols
    for (i, elem) in table.cells.iter().enumerate() {
        let row = i / table.cols;
        let col = i % table.cols;
        //add the element to the row and col
        if row >= rows.len() {
            rows.push(Vec::new());
            row_heights.push(0.0);
        }
        if col >= cols.len() {
            cols.push(Vec::new());
            col_widths.push(0.0);
        }
        rows[row].push(*elem);
        cols[col].push(*elem);

        //update the row and col sizes
        let elem_size = session.get_size(*elem);
        if elem_size.0 > col_widths[col] {
            col_widths[col] = elem_size.0 + table.table_options.cell_padding as Float * 2.0;
        }
        if elem_size.1 > row_heights[row] {
            row_heights[row] = elem_size.1 + table.table_options.cell_padding as Float * 2.0;
        }
    }

    //print row heights and col widths
    println!("row heights: {:?}", row_heights);
    println!("col widths: {:?}", col_widths);

    //we already have each row and col and their sizes.
    //Now we have to update the position of each element
    //and the size of the table

    //iterate through rows and cols and update the position of each element
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        let mut y = 0.0;
        for (j, elem) in col.iter().enumerate() {
            session.set_position(
                *elem,
                x + table.table_options.cell_padding as Float,
                y + table.table_options.cell_padding as Float,
            );
            y += row_heights[j];
        }

        x += col_widths[i];
    }

    //Update the position of the horizontal lines
    let mut y = 0.0;
    for (i, row) in rows.iter().enumerate() {
        horizontal_line_positions.push(y);
        y += row_heights[i];
    }

    //Update the position of the vertical lines
    let mut x = 0.0;
    for (i, col) in cols.iter().enumerate() {
        vertical_line_positions.push(x);
        x += col_widths[i];
    }

    //update the size of the table
    let mut width = 0.0;
    let mut height = 0.0;

    for w in col_widths.iter() {
        width += w;
    }

    for h in row_heights.iter() {
        height += h;
    }

    //Update the size of the table header rect
    session.set_size(table.header_rect, width, row_heights[0]);

    //print the size of the table
    println!("Table size: {:?}", (width, height));

    session.set_size(table.entity, width, height);

    //We need to update the position of the horizontal lines and their size
    for (i, line) in table.row_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(*line);
        if i < horizontal_line_positions.len() {
            //set the y position of the horizontal line, x will be 0
            session.set_position(*line, 0.0, horizontal_line_positions[i]);
            //update the size, we only need to update the height and leave the width as it is (0 by default)
            session.set_size(*line, width, line_size.1);
        }
    }

    for (i, line) in table.col_lines.iter().enumerate() {
        //get the size of the line (should be 0,0 by default)
        let line_size = session.get_size(*line);
        if i < vertical_line_positions.len() {
            //set the x position of the vertical line, y will be 0
            session.set_position(*line, vertical_line_positions[i], 0.0);
            //update the size, we only need to update the width and leave the height as it is (0 by default)
            session.set_size(*line, line_size.0, height);
        }
    }
}

pub fn layout_polyline(session: &mut DiagramBuilder, polyline: &PolyLine) {
    let mut x = 0.0;
    let mut y = 0.0;
    let mut width = 0.0;
    let mut height = 0.0;
    for (i, point) in polyline.points.iter().enumerate() {
        if i == 0 {
            x = point.0;
            y = point.1;
        } else {
            if point.0 < x {
                width += x - point.0;
                x = point.0;
            }
            if point.1 < y {
                height += y - point.1;
                y = point.1;
            }
        }
    }
    session.set_size(polyline.entity, width, height);
}

/**
 * Layout for the FreeContainer
 * Children have absolute positions relative to the container
 * The container size is determined by the maximum extent of its children
 */
pub fn layout_free_container(session: &mut DiagramBuilder, container: &FreeContainer) {
    // We need to determine the size of the container based on the positions and sizes of its children
    let mut max_width = 0.0;
    let mut max_height = 0.0;

    // Iterate through all children and find the maximum extent
    for (child_id, position) in &container.children {
        // Get the child's size
        let child_size = session.get_size(*child_id);

        // Set the child's position relative to the container
        session.set_position(*child_id, position.0, position.1);

        // Calculate the right and bottom edges of this child
        let right = position.0 + child_size.0;
        let bottom = position.1 + child_size.1;

        // Update the maximum extent
        if right > max_width {
            max_width = right;
        }
        if bottom > max_height {
            max_height = bottom;
        }
    }

    // Add a small margin to ensure we have enough space
    let margin = 2.0;
    max_width += margin;
    max_height += margin;

    // Set the container's size
    session.set_size(container.entity, max_width, max_height);
}

pub struct BoundingBox {
    x: Float,
    y: Float,
    width: Float,
    height: Float,
}
//Calculate the layout for a tree of elements
pub fn layout_tree_node(session: &mut DiagramBuilder, root: &DiagramTreeNode) -> BoundingBox {
    //start with the bottom elements
    for child in &root.children {
        println!("Layout child: {:?}", child);
        layout_tree_node(session, child);
        //print size and position of the child

        let child_size = session.get_size(child.entity_id);
        let child_pos = session.get_position(child.entity_id);
        println!("Child size: {:?}", child_size);
        println!("Child pos: {:?}", child_pos);
    }

    //Once the children are laid out, we can layout the current element
    //use methods in the layout module
    match root.entity_type {
        EntityType::TextShape => {
            {
                //get the Shape text entity
                let text = session.get_text(root.entity_id).clone();
                layout_text(session, &text);
            }
        }
        EntityType::BoxShape => {
            //get the Shape box entity
            let box_shape = session.get_box(root.entity_id).clone();
            layout_box(session, &box_shape);
        }

        EntityType::RectShape => {
            //get the Rect entity
            let rect = session.get_rectangle(root.entity_id);
            layout_rect(
                session,
                root.entity_id,
                rect.rect_options.width,
                rect.rect_options.height,
            );
        }

        EntityType::LineShape => {
            //get the Shape line entity
            let line = session.get_line(root.entity_id).clone();
            layout_line(session, &line);
        }
        EntityType::ArrowShape => {
            //get the Shape arrow entity
            let arrow = session.get_arrow(root.entity_id).clone();
            layout_arrow(session, &arrow);
        }
        EntityType::EllipseShape => {
            //get the Shape ellipse entity
            let ellipse = session.get_ellipse(root.entity_id).clone();
            layout_ellipse(session, &ellipse);
        }
        EntityType::ImageShape => {
            //get the Shape image entity
            let image = session.get_image(root.entity_id).clone();
            layout_image(session, &image);
        }
        EntityType::VerticalStackShape => {
            //get the VerticalStack entity
            let vertical_stack = session.get_vertical_stack(root.entity_id).clone();
            layout_vertical_stack(session, &vertical_stack);
        }

        EntityType::HorizontalStackShape => {
            //get the HorizontalStack entity
            let horizontal_stack = session.get_horizontal_stack(root.entity_id).clone();
            layout_horizontal_stack(session, &horizontal_stack);
        }

        EntityType::TableShape => {
            //get the Table entity
            let table = session.get_table(root.entity_id).clone();
            layout_table(session, &table);
        }

        EntityType::GroupShape => {
            //get the Group entity
            let group = session.get_group(root.entity_id).clone();
            layout_group(session, &group);
        }

        EntityType::PolyLine => {
            let polyline = session.get_polyline(root.entity_id).clone();
            layout_polyline(session, &polyline);
        }
        EntityType::FreeContainer => {
            let container = session.get_free_container(root.entity_id).clone();
            layout_free_container(session, &container);
        }

        //if not recognized, show the name of it in the panic
        _ => panic!("Unknown entity type: {:?}", root.entity_type),
    }

    //Return the bounding box for the root element
    let size = session.get_size(root.entity_id);
    let position = session.get_position(root.entity_id);
    BoundingBox {
        x: position.0,
        y: position.1,
        width: size.0,
        height: size.1,
    }
}

//import textoptions defined in src/components/mod.rs
use crate::components::BoxOptions;
use crate::components::TextOptions;
//Test that a box with a text inside is correctly laid out
#[test]
fn test_layout_box_with_text() {
    let mut session = DiagramBuilder::new();
    session.set_measure_text_fn(|_, _| (10.0, 10.0));
    let text = session.new_text(
        "hello",
        TextOptions {
            font_size: 20.0,
            line_width: 200,
            ..Default::default()
        },
    );
    let box_options = BoxOptions {
        padding: 10.0,
        ..Default::default()
    };
    let box_shape = session.new_box(text.clone(), box_options.clone());

    //print box options
    println!("--box options: {:?}", box_options);

    //layout the box
    layout_tree_node(&mut session, &box_shape);

    let text_position = session.get_position(text.entity_id);
    let text_size = session.get_size(text.entity_id);

    let box_position = session.get_position(box_shape.entity_id);
    let box_size = session.get_size(box_shape.entity_id);
    //assert equal positions

    // assert the box size is greater than the text size
    println!("box size: {:?}", box_size);
    println!("text size: {:?}", text_size);
    // and the text size should not be zero
    assert!(text_size.0 > 0.0);
    assert_eq!(box_size.0, 30.0);
    assert!(box_size.1 > text_size.1);
}

===/src/lib.rs===

pub use crate::diagram_builder::{DiagramBuilder};
pub use crate::components::*;
pub use crate::layout::*;
pub use crate::utils::*;
pub use crate::renderer_base::*;

pub mod diagram_builder;
pub mod utils;
pub mod components;
pub mod layout;
pub mod renderer_base;
pub mod parser;


===/src/components/mod.rs===

pub mod table;

use core::fmt;
use std::any::Any;

pub use crate::components::table::*;
//new type EntityID that is a u64
pub type EntityID = usize;
pub type Float = f32;

//Export table and table options


pub trait Entity {
    fn get_id(&self) -> EntityID;
    fn get_type(&self) -> EntityType;
    //as_any
    fn as_any(&self) -> &dyn Any;
}

pub struct Point {
    pub x: Float,
    pub y: Float,
}

//impl clone
impl Clone for Point {
    fn clone(&self) -> Self {
        Point {
            x: self.x,
            y: self.y,
        }
    }
}

//impl new
impl Point {
    pub fn new(x: Float, y: Float) -> Self {
        Point { x, y }
    }
}

pub struct Size {
    pub w: Float,
    pub h: Float,
}

//impl clone
impl Clone for Size {
    fn clone(&self) -> Self {
        Size {
            w: self.w,
            h: self.h,
        }
    }
}

//impl new
impl Size {
    pub fn new(w: Float, h: Float) -> Self {
        Size { w, h }
    }
}

//Note: add new items to the end of the enum to avoid breaking the serialization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EntityType {
    BoxShape,
    RectShape,
    TextShape,
    LineShape,
    ArrowShape,
    EllipseShape,
    ImageShape,
    GroupShape,
    VerticalStackShape,
    HorizontalStackShape,
    TableShape,
    TextLine,
    PolyLine,
    FreeContainer
}

pub fn get_entity_type(entity_id: EntityID) -> EntityType {
    match (entity_id >> 32) as u32 {
        0 => EntityType::BoxShape,
        1 => EntityType::TextShape,
        2 => EntityType::LineShape,
        3 => EntityType::ArrowShape,
        4 => EntityType::EllipseShape,
        5 => EntityType::ImageShape,
        6 => EntityType::GroupShape,
        7 => EntityType::VerticalStackShape,
        8 => EntityType::HorizontalStackShape,
        9 => EntityType::TableShape,
        10 => EntityType::TextLine,
        11 => EntityType::PolyLine,
        12 => EntityType::FreeContainer,
        _ => panic!("Invalid entity type"),
    }
}


/**
 * Boxes show a rectangle around the wrapped entity
 */
#[derive(Debug)]
pub struct ShapeBox {
    pub entity: EntityID,
    //Each box wraps another entity
    pub wrapped_entity: EntityID,
    pub box_options: BoxOptions,
}

impl Clone for ShapeBox {
    fn clone(&self) -> Self {
        ShapeBox {
            entity: self.entity,
            wrapped_entity: self.wrapped_entity,
            box_options: self.box_options.clone(),
        }
    }
}

impl Entity for ShapeBox {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::BoxShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeBox {
    pub fn new(entity: EntityID, wrapped_entity: EntityID, box_options: BoxOptions) -> ShapeBox {
        ShapeBox {
            entity,            
            wrapped_entity,
            box_options,
        }
    }
}

#[derive(Debug)]
pub enum GradientStop {
    ColorStop { offset: Float, color: String },
    OpacityStop { offset: Float, opacity: Float },
}

#[derive(Debug)]
pub struct LinearGradient {
    pub x1: Float,
    pub y1: Float,
    pub x2: Float,
    pub y2: Float,
    pub stops: Vec<GradientStop>,
}

impl LinearGradient {
    pub fn new(x1: Float, y1: Float, x2: Float, y2: Float, stops: Vec<GradientStop>) -> Self {
        LinearGradient {
            x1,
            y1,
            x2,
            y2,
            stops,
        }
    }
}

impl Clone for GradientStop {
    fn clone(&self) -> Self {
        match self {
            GradientStop::ColorStop { offset, color } => GradientStop::ColorStop {
                offset: *offset,
                color: color.clone(),
            },
            GradientStop::OpacityStop { offset, opacity } => GradientStop::OpacityStop {
                offset: *offset,
                opacity: *opacity,
            },
        }
    }
}

#[derive(Debug)]
pub struct RadialGradient {
    pub cx: Float,
    pub cy: Float,
    pub r: Float,
    pub stops: Vec<GradientStop>,
}

impl Clone for RadialGradient {
    fn clone(&self) -> Self {
        RadialGradient {
            cx: self.cx,
            cy: self.cy,
            r: self.r,
            stops: self.stops.clone(),
        }
    }
}

impl Clone for LinearGradient {
    fn clone(&self) -> Self {
        LinearGradient {
            x1: self.x1,
            y1: self.y1,
            x2: self.x2,
            y2: self.y2,
            stops: self.stops.clone(),
        }
    }
}



#[derive(Debug)]
pub enum Fill {
    Color(String),
    LinearGradient(LinearGradient),
    RadialGradient(RadialGradient),
}

impl Clone for Fill {
    fn clone(&self) -> Self {
        match self {
            Fill::Color(color) => Fill::Color(color.clone()),
            Fill::LinearGradient(gradient) => Fill::LinearGradient(gradient.clone()),
            Fill::RadialGradient(gradient) => Fill::RadialGradient(gradient.clone()),
        }
    }
}
//default trait for fill
impl Default for Fill {
    fn default() -> Self {
        Fill::Color(String::from("white"))
    }
}

//display for fill
impl fmt::Display for Fill {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Fill::Color(color) => write!(f, "{}", color),
            Fill::LinearGradient(gradient) => write!(f, "{:?}", gradient),
            Fill::RadialGradient(gradient) => write!(f, "{:?}", gradient),
        }
    }
}

#[derive(Default, Debug)]
pub struct BoxOptions {
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub padding: Float,
    pub border_radius: Float,
}

impl Clone for BoxOptions {
    fn clone(&self) -> Self {
        BoxOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            padding: self.padding,
            border_radius: self.border_radius,

        }
    }
}

impl BoxOptions {
    pub fn new() -> BoxOptions {
        BoxOptions {
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            padding: 10.0,
            border_radius: 0.0,
        }
    }
}



/* A group of entities */

//RectOptions
#[derive(Default, Debug)]
pub struct RectOptions {
    pub width: Float,
    pub height: Float,
    pub fill_color: Fill,
    pub stroke_color: String,
    pub stroke_width: Float,
    pub border_radius: Float,
}

impl Clone for RectOptions {
    fn clone(&self) -> Self {
        RectOptions {
            width: self.width,
            height: self.height,
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            border_radius: self.border_radius,
        }
    }
}

impl RectOptions {
    pub fn new() -> RectOptions {
        RectOptions {
            width: 100.0,
            height: 100.0,
            fill_color: Fill::Color(String::from("white")),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            border_radius: 0.0,
        }
    }
}

pub struct ShapeRect {
    pub entity: EntityID,
    pub rect_options: RectOptions,
}

impl ShapeRect {
    pub fn new(entity: EntityID, rect_options: RectOptions) -> ShapeRect {
        ShapeRect {
            entity,
            rect_options,
        }
    }
}

impl Clone for ShapeRect {
    fn clone(&self) -> Self {
        ShapeRect {
            entity: self.entity,
            rect_options: self.rect_options.clone(),
        }
    }
}

impl Entity for ShapeRect {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::RectShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}


/* A group of entities */
pub struct ShapeGroup {
    pub entity: EntityID,
    pub elements: Vec<EntityID>,
}

impl Clone for ShapeGroup {
    fn clone(&self) -> Self {
        ShapeGroup {
            entity: self.entity,
            elements: self.elements.clone(),
        }
    }
}

impl Entity for ShapeGroup {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::GroupShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

// Represents a line after adding breaks
#[derive(Debug)]
pub struct TextLine {
    pub entity: EntityID,
    pub text: String,
}

impl Clone for TextLine {
    fn clone(&self) -> Self {
        TextLine {
            entity: self.entity,
            text: self.text.clone(),
        }
    }
}

impl Entity for TextLine {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
//add copy trait
#[derive(Debug)]
pub struct ShapeText {
    pub entity: EntityID,
    pub text: String,
    pub text_options: TextOptions,
    pub lines: Vec<EntityID>,
}

impl Clone for ShapeText {
    fn clone(&self) -> Self {
        ShapeText {
            entity: self.entity,
            text: self.text.clone(),
            text_options: self.text_options.clone(),
            lines: self.lines.clone(),
        }
    }
}


impl ShapeText {
    pub fn new(entity: EntityID, text: &str, text_options: TextOptions, lines: &[EntityID]) -> ShapeText {
        ShapeText {
            entity,
            text: text.to_string(),
            text_options,
            lines: lines.to_vec(),
        }
    }
}



impl Entity for ShapeText {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::TextShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

//struct with text options: font family, font size
#[derive(Default, Debug)]
pub struct TextOptions {
    pub font_family: String,
    pub font_size: f32,
    pub text_color: String,
    // (number of max characters per line)used to know when to insert breaks
    pub line_width: usize,
    pub line_spacing: f32, // spacing between lines
}

impl Clone for TextOptions {
    fn clone(&self) -> Self {
        TextOptions {
            font_family: self.font_family.clone(),
            font_size: self.font_size,
            text_color: self.text_color.clone(),
            line_width: self.line_width,
            line_spacing: self.line_spacing,
        }
    }
}

impl TextOptions {
    pub fn new() -> TextOptions {
        TextOptions {
            font_family: String::from("Roboto"),
            font_size: 12.0,
            text_color: String::from("black"),
            line_width: 20,
            line_spacing: 0.0,
        }
    }
}

pub enum HorizontalAlignment {
    Left,
    Center,
    Right,
}

impl Clone for HorizontalAlignment {
    fn clone(&self) -> Self {
        match self {
            HorizontalAlignment::Left => HorizontalAlignment::Left,
            HorizontalAlignment::Center => HorizontalAlignment::Center,
            HorizontalAlignment::Right => HorizontalAlignment::Right,
        }
    }
}   

pub struct VerticalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub horizontal_alignment: HorizontalAlignment
}

impl Clone for VerticalStack {
    fn clone(&self) -> Self {
        VerticalStack {
            entity: self.entity,
            elements: self.elements.clone(),
            horizontal_alignment: self.horizontal_alignment.clone()
        }
    }
}

impl Entity for VerticalStack {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::VerticalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
    
pub enum VerticalAlignment {
    Top,
    Center,
    Bottom,
}

impl Clone for VerticalAlignment {
    fn clone(&self) -> Self {
        match self {
            VerticalAlignment::Top => VerticalAlignment::Top,
            VerticalAlignment::Center => VerticalAlignment::Center,
            VerticalAlignment::Bottom => VerticalAlignment::Bottom,
        }
    }
}   
impl fmt::Display for VerticalAlignment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VerticalAlignment::Top => write!(f, "Top"),
            VerticalAlignment::Center => write!(f, "Center"),
            VerticalAlignment::Bottom => write!(f, "Bottom"),
        }
    }
}
//enum for horizontal stack

pub struct HorizontalStack {
    pub entity: EntityID,
    //List of entity ids
    pub elements: Vec<EntityID>,
    pub vertical_alignment: VerticalAlignment, // Optional vertical alignment (e.g., "top", "center", "bottom")
}

impl Clone for HorizontalStack {
    fn clone(&self) -> Self {
        HorizontalStack {
            entity: self.entity,
            elements: self.elements.clone(),
            vertical_alignment: self.vertical_alignment.clone(),
        }
    }
}

impl Entity for HorizontalStack {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::HorizontalStackShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

pub struct ShapeLine {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub line_options: LineOptions,
}

impl Clone for ShapeLine {
    fn clone(&self) -> Self {
        ShapeLine {
            entity: self.entity,
            start: self.start,
            end: self.end,
            line_options: self.line_options.clone(),
        }
    }
}

impl ShapeLine {
    pub fn new(line_id: EntityID, start: (Float, Float), end: (Float, Float), options: LineOptions) -> ShapeLine {
        ShapeLine {
            entity: line_id,
            start,
            end,
            line_options: options,
        }
    }
}


impl Entity for ShapeLine {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::LineShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct LineOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for LineOptions {
    fn clone(&self) -> Self {
        LineOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl LineOptions {
    pub fn new() -> LineOptions {
        LineOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}

pub struct PolyLine {
    pub entity: EntityID,
    pub points: Vec<(Float, Float)>,
    pub line_options: LineOptions,
}

impl PolyLine {
    pub fn new(entity: EntityID, points: Vec<(Float, Float)>, line_options: LineOptions) -> PolyLine {
        PolyLine {
            entity,
            points,
            line_options,
        }
    }
}

impl Entity for PolyLine {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::PolyLine
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl Clone for PolyLine {
    fn clone(&self) -> Self {
        PolyLine {
            entity: self.entity,
            points: self.points.clone(),
            line_options: self.line_options.clone(),
        }
    }
}

pub struct ShapeArrow {
    pub entity: EntityID,
    pub start: (Float, Float),
    pub end: (Float, Float),
    pub arrow_options: ArrowOptions,
}

impl Clone for ShapeArrow {
    fn clone(&self) -> Self {
        ShapeArrow {
            entity: self.entity,
            start: self.start,
            end: self.end,
            arrow_options: self.arrow_options.clone(),
        }
    }
}

impl Entity for ShapeArrow {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::ArrowShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct ArrowOptions {
    pub stroke_color: String,
    pub stroke_width: Float,
    pub arrow_size: Float,
}

impl Clone for ArrowOptions {
    fn clone(&self) -> Self {
        ArrowOptions {
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
            arrow_size: self.arrow_size,
        }
    }
}

impl ArrowOptions {
    pub fn new() -> ArrowOptions {
        ArrowOptions {
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            arrow_size: 10.0,
        }
    }
}

pub struct ShapeEllipse {
    pub entity: EntityID,
    pub center: (Float, Float),
    pub radius: (Float, Float),
    pub ellipse_options: EllipseOptions,
}

impl Clone for ShapeEllipse {
    fn clone(&self) -> Self {
        ShapeEllipse {
            entity: self.entity,
            center: self.center,
            radius: self.radius,
            ellipse_options: self.ellipse_options.clone(),
        }
    }
}

impl ShapeEllipse {
    pub fn new(entity: EntityID, center: (Float, Float), radius: (Float, Float), ellipse_options: EllipseOptions) -> ShapeEllipse {
        ShapeEllipse {
            entity,
            center,
            radius,
            ellipse_options,
        }
    }
}

impl Entity for ShapeEllipse {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::EllipseShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[derive(Default)]
pub struct EllipseOptions {
    //TODO: convert to Fill
    pub fill_color: String,
    pub stroke_color: String,
    pub stroke_width: Float,
}

impl Clone for EllipseOptions {
    fn clone(&self) -> Self {
        EllipseOptions {
            fill_color: self.fill_color.clone(),
            stroke_color: self.stroke_color.clone(),
            stroke_width: self.stroke_width,
        }
    }
}

impl EllipseOptions {
    pub fn new() -> EllipseOptions {
        EllipseOptions {
            fill_color: String::from("white"),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
        }
    }
}



pub struct ShapeImage {
    pub entity: EntityID,
    //base64 encoded image or empty if using file_path
    pub image: String,
    //path to image file on disk (optional)
    pub file_path: Option<String>,
    pub preferred_size: (Float, Float),
}

impl Clone for ShapeImage {
    fn clone(&self) -> Self {
        ShapeImage {
            entity: self.entity,
            image: self.image.clone(),
            file_path: self.file_path.clone(),
            preferred_size: self.preferred_size,
        }
    }
}

impl Entity for ShapeImage {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::ImageShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl ShapeImage {
    pub fn new(entity: EntityID, image: String, preferred_size: (Float, Float)) -> ShapeImage {
        ShapeImage {
            entity,
            image,
            file_path: None,
            preferred_size,
        }
    }
    
    pub fn from_file(entity: EntityID, file_path: String, preferred_size: (Float, Float)) -> ShapeImage {
        ShapeImage {
            entity,
            image: String::new(), // Empty as we're using file_path instead
            file_path: Some(file_path),
            preferred_size,
        }
    }
}

/// A container that allows children to be positioned with absolute coordinates
/// Children's positions are relative to the container's top-left corner
pub struct FreeContainer {
    pub entity: EntityID,
    pub children: Vec<(EntityID, (Float, Float))>, // Each child has a position relative to the container
    pub background_color: Option<String>,      // Optional background color
    pub border_color: Option<String>,          // Optional border color
    pub border_width: Float,                    // Border width (0 for no border)
}

impl Clone for FreeContainer {
    fn clone(&self) -> Self {
        FreeContainer {
            entity: self.entity,
            children: self.children.clone(),
            background_color: self.background_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
        }
    }
}

impl Entity for FreeContainer {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::FreeContainer
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

impl FreeContainer {
    /// Create a new empty FreeContainer
    pub fn new(entity: EntityID) -> Self {
        FreeContainer {
            entity,
            children: Vec::new(),
            background_color: None,
            border_color: None,
            border_width: 0.0,
        }
    }
    
    /// Add a child to the container at the specified position
    pub fn add_child(&mut self, child_id: EntityID, position: (Float, Float)) {
        self.children.push((child_id, position));
    }
    
    /// Add multiple children at once with their positions
    pub fn with_children(mut self, children_with_positions: Vec<(EntityID, (Float, Float))>) -> Self {
        self.children.extend(children_with_positions);
        self
    }
    
    /// Set background color
    pub fn with_background_color(mut self, color: &str) -> Self {
        self.background_color = Some(color.to_string());
        self
    }
    
    /// Set border properties
    pub fn with_border(mut self, color: &str, width: Float) -> Self {
        self.border_color = Some(color.to_string());
        self.border_width = width;
        self
    }
}

===/src/components/table.rs===

//use EntityID
use crate::components::*;


pub struct TableOptions {
    pub fill_color: String,
    pub header_fill_color: String,
    pub border_color: String,
    pub border_width: usize,
    pub cell_padding: usize,
}

/* A table contains a list of rows, each row has a cell 
* which is a group that contains other elements.

Tables are defined with an array of cells and the number of columns
*/
pub struct Table {
    pub entity: EntityID,
    pub cols: usize, 
    pub cells: Vec<EntityID>,
    pub col_lines: Vec<EntityID>,
    pub row_lines: Vec<EntityID>,
    pub header_rect: EntityID,
    pub table_options: TableOptions,
}

//new


impl Clone for Table {
    fn clone(&self) -> Self {
        Table {
            entity: self.entity,
            cols: self.cols,
            cells: self.cells.clone(),
            col_lines: self.col_lines.clone(),
            row_lines: self.row_lines.clone(),
            table_options: self.table_options.clone(),
            header_rect: self.header_rect,
        }
    }
}

//constructor that receives only the table options
impl Table {
    pub fn new(entity: EntityID,cells: Vec<EntityID>, col_lines: Vec<EntityID>, row_lines: Vec<EntityID>, cols: usize, header_rect: EntityID, table_options: TableOptions) -> Table {
        Table {
            entity,
            cols,
            cells,
            col_lines,
            row_lines ,
            header_rect, 
            table_options,
        }
    }
}

impl Entity for Table {
    fn get_id(&self) -> EntityID {
        self.entity
    }

    fn get_type(&self) -> EntityType {
        EntityType::TableShape
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}




//defaults
impl Default for TableOptions {
    fn default() -> Self {
        TableOptions {
            fill_color: String::from("white"),
            border_color: String::from("black"),
            header_fill_color: String::from("lightgray"),
            border_width: 1,
            cell_padding: 20,
        }
    }
}

impl Clone for TableOptions {
    fn clone(&self) -> Self {
        TableOptions {
            fill_color: self.fill_color.clone(),
            header_fill_color: self.header_fill_color.clone(),
            border_color: self.border_color.clone(),
            border_width: self.border_width,
            cell_padding: self.cell_padding,
        }
    }
}

===/src/renderer_base.rs===
use std::{error::Error, fmt, io::Write};

use crate::{DiagramBuilder, diagram_builder::DiagramTreeNode};

#[derive(Debug)]
pub struct RendererError {
    message: String,
}

impl RendererError {
    pub fn new(message: &str) -> RendererError {
        RendererError {
            message: message.to_string(),
        }
    }
}

impl fmt::Display for RendererError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for RendererError {}

pub trait Renderer<W: Write> {
    fn render(
        &self,
        session: &DiagramBuilder,
        diagram_node: &DiagramTreeNode,
        stream: &mut W,
    ) -> Result<(), RendererError>;
}

===/src/parser.rs===
use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

use crate::{components::*, DiagramBuilder, diagram_builder::*};

/// A JSON Lines entity representing a single diagram element
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonEntity {
    pub id: String,
    #[serde(rename = "type")]
    pub entity_type: String,

    // Common attributes (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub children: Option<Vec<String>>,

    // Text-specific attributes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub font_size: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub font_family: Option<String>,

    // Box/Rectangle attributes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub padding: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub background: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub border_color: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub border_width: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub border_radius: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<Float>,

    // Position attributes (for free containers)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub y: Option<Float>,

    // Image attributes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub src: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_path: Option<String>,

    // Table attributes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cols: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub header_fill_color: Option<String>,

    // Line/Polyline attributes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stroke_color: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stroke_width: Option<Float>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_point: Option<(Float, Float)>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_point: Option<(Float, Float)>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub points: Option<Vec<(Float, Float)>>,

    // Ellipse attributes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub center: Option<(Float, Float)>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub radius: Option<(Float, Float)>,

    // Catch-all for any other attributes
    #[serde(flatten)]
    pub extra: Map<String, Value>,
}

/// Parser for JSON Lines diagram format
pub struct JsonLinesParser {
    entities: HashMap<String, JsonEntity>,
}

impl JsonLinesParser {
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
        }
    }

    /// Parse from a string containing JSON Lines
    pub fn parse_string(&mut self, input: &str) -> Result<String, JsonLinesError> {
        let mut root_id = None;

        for (line_num, line) in input.lines().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from a file
    pub fn parse_file(&mut self, file_path: &str) -> Result<String, JsonLinesError> {
        let file = File::open(file_path).map_err(|e| JsonLinesError::IoError(e.to_string()))?;
        let reader = BufReader::new(file);
        let mut root_id = None;

        for (line_num, line_result) in reader.lines().enumerate() {
            let line = line_result.map_err(|e| JsonLinesError::IoError(e.to_string()))?;
            let line = line.trim();

            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(&line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Parse from an iterator of lines (useful for streaming)
    pub fn parse_lines<I>(&mut self, lines: I) -> Result<String, JsonLinesError>
    where
        I: IntoIterator<Item = String>,
    {
        let mut root_id = None;

        for (line_num, line) in lines.into_iter().enumerate() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            match serde_json::from_str::<JsonEntity>(line) {
                Ok(entity) => {
                    if root_id.is_none() {
                        root_id = Some(entity.id.clone());
                    }
                    self.entities.insert(entity.id.clone(), entity);
                }
                Err(e) => {
                    return Err(JsonLinesError::ParseError {
                        line: line_num + 1,
                        message: e.to_string(),
                    });
                }
            }
        }

        root_id.ok_or(JsonLinesError::NoEntities)
    }

    /// Build the diagram tree from parsed entities
    pub fn build(
        &self,
        root_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        self.build_entity(root_id, builder)
    }

    fn build_entity(
        &self,
        entity_id: &str,
        builder: &mut DiagramBuilder,
    ) -> Result<DiagramTreeNode, JsonLinesError> {
        let entity = self
            .entities
            .get(entity_id)
            .ok_or_else(|| JsonLinesError::EntityNotFound(entity_id.to_string()))?;

        match entity.entity_type.as_str() {
            "text" => {
                let content = entity
                    .content
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("content".to_string()))?;

                let options = TextOptions {
                    font_size: entity.font_size.unwrap_or(12.0),
                    text_color: entity.color.clone().unwrap_or_else(|| "black".to_string()),
                    font_family: entity
                        .font_family
                        .clone()
                        .unwrap_or_else(|| "Arial".to_string()),
                    ..Default::default()
                };

                Ok(builder.new_text(content, options))
            }

            "box" => {
                let children = entity
                    .children
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                if children.len() != 1 {
                    return Err(JsonLinesError::InvalidStructure(
                        "Box must have exactly one child".to_string(),
                    ));
                }

                let child = self.build_entity(&children[0], builder)?;
                let options = BoxOptions {
                    padding: entity.padding.unwrap_or(0.0),
                    fill_color: entity
                        .background
                        .as_ref()
                        .map(|bg| Fill::Color(bg.clone()))
                        .unwrap_or(Fill::Color("white".to_string())),
                    stroke_color: entity
                        .border_color
                        .clone()
                        .unwrap_or_else(|| "black".to_string()),
                    stroke_width: entity.border_width.unwrap_or(1.0),
                    border_radius: entity.border_radius.unwrap_or(0.0),
                };

                Ok(builder.new_box(child, options))
            }

            "vstack" => {
                
                let halign = entity
                    .extra
                    .get("h-align")
                    .and_then(|v| v.as_str())
                    .and_then(|s| match s {
                        "left" => Some(HorizontalAlignment::Left),
                        "center" => Some(HorizontalAlignment::Center),
                        "right" => Some(HorizontalAlignment::Right),
                        _ => None,
                    })
                    .unwrap_or(HorizontalAlignment::Center);

                let children = entity
                    .children
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                Ok(builder.new_vstack(child_nodes?, halign))
            }

            "hstack" => {
                let valign = entity
                    .extra
                    .get("v-align")
                    .and_then(|v| v.as_str())
                    .and_then(|s| match s {
                        "top" => Some(VerticalAlignment::Top),
                        "center" => Some(VerticalAlignment::Center),
                        "bottom" => Some(VerticalAlignment::Bottom),
                        _ => None,
                    })
                    .unwrap_or(VerticalAlignment::Center);
                let children = entity
                    .children
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                Ok(builder.new_hstack(child_nodes?,valign ))
            }

            "group" => {
                let children = entity
                    .children
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                Ok(builder.new_group(child_nodes?))
            }

            "rect" => {
                let options = RectOptions {
                    width: entity.width.unwrap_or(100.0),
                    height: entity.height.unwrap_or(100.0),
                    fill_color: entity
                        .background
                        .as_ref()
                        .map(|bg| Fill::Color(bg.clone()))
                        .unwrap_or(Fill::Color("white".to_string())),
                    stroke_color: entity
                        .border_color
                        .clone()
                        .unwrap_or_else(|| "black".to_string()),
                    stroke_width: entity.border_width.unwrap_or(1.0),
                    ..Default::default()
                };

                Ok(builder.new_rectangle(options))
            }

            "line" => {
                let options = LineOptions {
                    stroke_color: entity
                        .stroke_color
                        .clone()
                        .unwrap_or_else(|| "black".to_string()),
                    stroke_width: entity.stroke_width.unwrap_or(1.0),
                    ..Default::default()
                };

                Ok(builder.new_line(entity.start_point.unwrap_or((0.0, 0.0)), entity.end_point.unwrap_or((0.0, 0.0)), options))
            }

            "ellipse" => {
                let center = entity.center.unwrap_or((50.0, 50.0));
                let radius = entity.radius.unwrap_or((25.0, 25.0));
                let options = EllipseOptions {
                    fill_color: entity
                        .background.clone()
                        .unwrap_or_else(|| "white".to_string()),
                    stroke_color: entity
                        .border_color
                        .clone()
                        .unwrap_or_else(|| "black".to_string()),
                    stroke_width: entity.border_width.unwrap_or(1.0),
                    ..Default::default()
                };

                Ok(builder.new_elipse(center, radius, options))
            }

            "image" => {
                let size = (
                    entity.width.unwrap_or(100.0),
                    entity.height.unwrap_or(100.0),
                );

                if let Some(src) = &entity.src {
                    Ok(builder.new_image(src, size))
                } else if let Some(file_path) = &entity.file_path {
                    Ok(builder.new_image_from_file(file_path, size))
                } else {
                    Err(JsonLinesError::MissingAttribute(
                        "src or file_path".to_string(),
                    ))
                }
            }

            "table" => {
                let children = entity
                    .children
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;
                let cols = entity
                    .cols
                    .ok_or_else(|| JsonLinesError::MissingAttribute("cols".to_string()))?;

                let child_nodes: Result<Vec<_>, _> = children
                    .iter()
                    .map(|child_id| self.build_entity(child_id, builder))
                    .collect();

                let options = TableOptions {
                    header_fill_color: entity
                        .header_fill_color
                        .clone()
                        .unwrap_or_else(|| "lightgray".to_string()),
                    ..Default::default()
                };

                Ok(builder.new_table(child_nodes?, cols, options))
            }

            "polyline" => {
                let points = entity
                    .points
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("points".to_string()))?;

                let options = LineOptions {
                    stroke_color: entity
                        .stroke_color
                        .clone()
                        .unwrap_or_else(|| "black".to_string()),
                    stroke_width: entity.stroke_width.unwrap_or(1.0),
                    ..Default::default()
                };

                Ok(builder.new_polyline(points.clone(), options))
            }

            "free_container" => {
                let children = entity
                    .children
                    .as_ref()
                    .ok_or_else(|| JsonLinesError::MissingAttribute("children".to_string()))?;

                let mut positioned_children = Vec::new();
                for child_id in children {
                    let child_entity = self
                        .entities
                        .get(child_id)
                        .ok_or_else(|| JsonLinesError::EntityNotFound(child_id.clone()))?;

                    let child_node = self.build_entity(child_id, builder)?;
                    let position = (child_entity.x.unwrap_or(0.0), child_entity.y.unwrap_or(0.0));
                    positioned_children.push((child_node, position));
                }

                Ok(builder.new_free_container_with_children(positioned_children))
            }

            _ => Err(JsonLinesError::UnknownEntityType(
                entity.entity_type.clone(),
            )),
        }
    }

    /// Validate that all child references exist
    pub fn validate(&self) -> Result<(), JsonLinesError> {
        for (id, entity) in &self.entities {
            if let Some(children) = &entity.children {
                for child_id in children {
                    if !self.entities.contains_key(child_id) {
                        return Err(JsonLinesError::MissingChild {
                            parent: id.clone(),
                            child: child_id.clone(),
                        });
                    }
                }
            }
        }
        Ok(())
    }

    /// Get all entity IDs
    pub fn get_entity_ids(&self) -> Vec<&String> {
        self.entities.keys().collect()
    }
}

/// Builder for creating JSON Lines diagrams
pub struct JsonLinesBuilder {
    entities: Vec<JsonEntity>,
    id_counter: usize,
}

impl JsonLinesBuilder {
    pub fn new() -> Self {
        Self {
            entities: Vec::new(),
            id_counter: 0,
        }
    }

    pub fn next_id(&mut self) -> String {
        self.id_counter += 1;
        format!("e{}", self.id_counter)
    }

    pub fn text(&mut self, content: &str) -> String {
        let id = self.next_id();
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            content: Some(content.to_string()),
            ..Default::default()
        });
        id
    }

    pub fn text_styled(&mut self, content: &str, font_size: Float, color: &str) -> String {
        let id = self.next_id();
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "text".to_string(),
            content: Some(content.to_string()),
            font_size: Some(font_size),
            color: Some(color.to_string()),
            ..Default::default()
        });
        id
    }

    pub fn box_with(&mut self, child: String, padding: Float, background: &str) -> String {
        let id = self.next_id();
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "box".to_string(),
            children: Some(vec![child]),
            padding: Some(padding),
            background: Some(background.to_string()),
            ..Default::default()
        });
        id
    }

    pub fn vstack(&mut self, children: Vec<String>) -> String {
        let id = self.next_id();
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "vstack".to_string(),
            children: Some(children),
            ..Default::default()
        });
        id
    }

    pub fn hstack(&mut self, children: Vec<String>) -> String {
        let id = self.next_id();
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "hstack".to_string(),
            children: Some(children),
            ..Default::default()
        });
        id
    }

    pub fn rect(&mut self, width: Float, height: Float, color: &str) -> String {
        let id = self.next_id();
        self.entities.push(JsonEntity {
            id: id.clone(),
            entity_type: "rect".to_string(),
            width: Some(width),
            height: Some(height),
            background: Some(color.to_string()),
            ..Default::default()
        });
        id
    }

    /// Build and return the JSON Lines string
    pub fn build(&self) -> Result<String, serde_json::Error> {
        let mut lines = Vec::new();
        for entity in &self.entities {
            lines.push(serde_json::to_string(entity)?);
        }
        Ok(lines.join("\n"))
    }

    /// Write to a file
    pub fn write_to_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::create(file_path)?;
        for entity in &self.entities {
            writeln!(file, "{}", serde_json::to_string(entity)?)?;
        }
        Ok(())
    }

    /// Get the root entity ID (first entity)
    pub fn root_id(&self) -> Option<String> {
        self.entities.first().map(|e| e.id.clone())
    }
}

impl Default for JsonEntity {
    fn default() -> Self {
        Self {
            id: String::new(),
            entity_type: String::new(),
            children: None,
            content: None,
            font_size: None,
            color: None,
            font_family: None,
            padding: None,
            background: None,
            border_color: None,
            border_width: None,
            border_radius: None,
            width: None,
            height: None,
            x: None,
            y: None,
            src: None,
            file_path: None,
            cols: None,
            header_fill_color: None,
            stroke_color: None,
            stroke_width: None,
            start_point: None,
            end_point: None,
            points: None,
            center: None,
            radius: None,
            extra: Map::new(),
        }
    }
}

#[derive(Debug)]
pub enum JsonLinesError {
    ParseError { line: usize, message: String },
    EntityNotFound(String),
    MissingAttribute(String),
    InvalidStructure(String),
    UnknownEntityType(String),
    MissingChild { parent: String, child: String },
    NoEntities,
    IoError(String),
}

impl std::fmt::Display for JsonLinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsonLinesError::ParseError { line, message } => {
                write!(f, "Parse error on line {}: {}", line, message)
            }
            JsonLinesError::EntityNotFound(id) => write!(f, "Entity not found: {}", id),
            JsonLinesError::MissingAttribute(attr) => {
                write!(f, "Missing required attribute: {}", attr)
            }
            JsonLinesError::InvalidStructure(msg) => write!(f, "Invalid structure: {}", msg),
            JsonLinesError::UnknownEntityType(t) => write!(f, "Unknown entity type: {}", t),
            JsonLinesError::MissingChild { parent, child } => {
                write!(f, "Parent {} references missing child {}", parent, child)
            }
            JsonLinesError::NoEntities => write!(f, "No entities found"),
            JsonLinesError::IoError(msg) => write!(f, "IO error: {}", msg),
        }
    }
}

impl std::error::Error for JsonLinesError {}

#[cfg(test)]
mod tests {
    use crate::DiagramBuilder;

    use super::*;

    #[test]
    fn test_json_lines_parsing() {
        let input = r#"
{"id":"root","type":"box","padding":10,"background":"white","children":["text1"]}
{"id":"text1","type":"text","content":"Hello World","font_size":16,"color":"blue"}
"#;

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(input).unwrap();
        assert_eq!(root_id, "root");

        parser.validate().unwrap();

        let mut builder = DiagramBuilder::new();
        let _diagram = parser.build(&root_id, &mut builder).unwrap();
    }

    #[test]
    fn test_builder_api() {
        let mut builder = JsonLinesBuilder::new();

        let title = builder.text_styled("Document Title", 18.0, "blue");
        let left_text = builder.text("Left Panel");
        let right_text = builder.text("Right Panel");

        let left_box = builder.box_with(left_text, 10.0, "lightblue");
        let right_box = builder.box_with(right_text, 10.0, "lightgreen");

        let content = builder.hstack(vec![left_box, right_box]);
        let footer = builder.text_styled("Footer", 12.0, "gray");

        let _root = builder.vstack(vec![title, content, footer]);

        let jsonl = builder.build().unwrap();
        println!("Generated JSON Lines:\n{}", jsonl);

        // Parse it back to verify
        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_string(&jsonl).unwrap();
        parser.validate().unwrap();
    }

    #[test]
    fn test_streaming_parse() {
        let lines = vec![
            r#"{"id":"e1","type":"text","content":"Hello"}"#.to_string(),
            r#"{"id":"e2","type":"text","content":"World"}"#.to_string(),
            r#"{"id":"e3","type":"hstack","children":["e1","e2"]}"#.to_string(),
        ];

        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_lines(lines).unwrap();
        assert_eq!(root_id, "e1");
        parser.validate().unwrap();
    }

    #[test]
    fn test_file_operations() {
        let mut builder = JsonLinesBuilder::new();
        let text = builder.text("Test");
        let root = builder.box_with(text, 5.0, "white");

        // Write to file
        builder.write_to_file("test_diagram.jsonl").unwrap();

        // Read back
        let mut parser = JsonLinesParser::new();
        let root_id = parser.parse_file("test_diagram.jsonl").unwrap();
        parser.validate().unwrap();

        // Clean up
        std::fs::remove_file("test_diagram.jsonl").ok();
    }
}

// Example of what an LLM might generate
pub fn example_llm_generated_jsonl() -> &'static str {
    r#"{"id":"document","type":"box","padding":20,"background":"white","border_color":"gray","children":["layout"]}
{"id":"layout","type":"vstack","children":["header","body","footer"]}
{"id":"header","type":"text","content":"My Document","font_size":24,"color":"darkblue"}
{"id":"body","type":"hstack","children":["sidebar","main"]}
{"id":"sidebar","type":"box","padding":15,"background":"lightgray","children":["nav"]}
{"id":"nav","type":"vstack","children":["link1","link2","link3"]}
{"id":"link1","type":"text","content":"Home","color":"blue"}
{"id":"link2","type":"text","content":"About","color":"blue"}
{"id":"link3","type":"text","content":"Contact","color":"blue"}
{"id":"main","type":"box","padding":15,"background":"white","children":["content"]}
{"id":"content","type":"vstack","children":["article_title","article_body"]}
{"id":"article_title","type":"text","content":"Article Title","font_size":18}
{"id":"article_body","type":"text","content":"This is the main content of the article..."}
{"id":"footer","type":"text","content":"Copyright 2024","font_size":10,"color":"gray"}"#
}

===/src/utils.rs===
use crate::components::*;
// Returns the entity type given its id.
pub fn get_entity_type_from_id(entity_id: EntityID) -> EntityType {
    match (entity_id >> 32) as u8 {
        0 => EntityType::GroupShape,
        1 => EntityType::HorizontalStackShape,
        2 => EntityType::VerticalStackShape,
        3 => EntityType::TextShape,
        4 => EntityType::LineShape,
        5 => EntityType::ArrowShape,
        _ => EntityType::GroupShape,
    }
}
===/src/diagram_builder.rs===
use std::collections::HashMap;

/**
 * This object encapsulates diagram creation logic.
 * Usage:
 *```rust
 * let builder = DiagramBuilder::new();
 * let group = builder.new_group(
 *   builder.new_box(builder.new_text("Hello World!"), BoxOptions{fill_color: "white".to_string(), stroke_color: "black".to_string(), stroke_width: 1.0, padding: 10.0, round_corners: false, border_radius: 0.0}),
 * );
 *
 *
 *
 */
//use TextOptions
use crate::components::*;

pub struct DiagramBuilder {
    pub measure_text: Option<fn(&str, &TextOptions) -> (Float, Float)>,
    pub entities: Vec<EntityID>,
    pub positions: HashMap<EntityID, Point>,
    pub sizes: HashMap<EntityID, Size>,
    entity_id_counter: usize,

    // Components
    boxes: HashMap<EntityID, ShapeBox>,
    rectangles: HashMap<EntityID, ShapeRect>,
    groups: HashMap<EntityID, ShapeGroup>,
    texts: HashMap<EntityID, ShapeText>,
    textlines: HashMap<EntityID, TextLine>,
    horizontal_stacks: HashMap<EntityID, HorizontalStack>,
    vertical_stacks: HashMap<EntityID, VerticalStack>,
    ellipses: HashMap<EntityID, ShapeEllipse>,
    lines: HashMap<EntityID, ShapeLine>,
    arrows: HashMap<EntityID, ShapeArrow>,
    tables: HashMap<EntityID, Table>,
    images: HashMap<EntityID, ShapeImage>,
    polylines: HashMap<EntityID, PolyLine>,
    free_containers: HashMap<EntityID, FreeContainer>,
}

// Stores the type of entity and the index of the entity in the corresponding vector
// Used when building the diagram tree.
#[derive(Debug, Clone)]
pub struct DiagramTreeNode {
    pub entity_type: EntityType,
    // Index of the entity in the corresponding vector
    pub entity_id: EntityID,
    pub children: Vec<Box<DiagramTreeNode>>,
}

impl DiagramTreeNode {
    fn new(entity_type: EntityType, id: EntityID) -> DiagramTreeNode {
        DiagramTreeNode {
            entity_type,
            entity_id: id,
            children: Vec::new(),
        }
    }

    fn add_child(&mut self, child: DiagramTreeNode) {
        self.children.push(Box::new(child));
    }
}

/* New architecture (data driven)
 * We have an array of entities, each entity is an id
 * The id has 64 bits, we can use 32 bits for the type and 32 bits for the index
 * To get the type: id >> 32
 * To get the index: id & 0xFFFFFFFF
 * We have a type enum with all the types
*/

impl DiagramBuilder {
    pub fn new() -> DiagramBuilder {
        DiagramBuilder {
            entity_id_counter: 0,
            measure_text: Some(|_text, _text_options| (0.0, 0.0)),
            entities: Vec::new(),
            positions: HashMap::new(),
            sizes: HashMap::new(),
            boxes: HashMap::new(),
            rectangles: HashMap::new(),
            groups: HashMap::new(),
            texts: HashMap::new(),
            textlines: HashMap::new(),
            horizontal_stacks: HashMap::new(),
            vertical_stacks: HashMap::new(),
            ellipses: HashMap::new(),
            lines: HashMap::new(),
            arrows: HashMap::new(),
            tables: HashMap::new(),
            images: HashMap::new(),
            polylines: HashMap::new(),
            free_containers: HashMap::new(),
        }
    }

    /* Create a new entity of a given type
     * Returns the id of the new entity
     * We have another array with the positions of the entities
     * in the same index. So they are fast to access
     */
    pub fn new_entity(&mut self, entity_type: EntityType) -> EntityID {
        self.entity_id_counter += 1;
        let id = self.entity_id_counter;
        println!("Creating new entity with id {}", id);
        self.entities.push(id);
        self.positions.insert(id, Point::new(0.0, 0.0));
        self.sizes.insert(id, Size::new(0.0, 0.0));
        id
    }

    pub fn clear_cache(&mut self) {
        //clear entities vector
        self.entities = Vec::new();
        self.positions = HashMap::new();
        self.sizes = HashMap::new();
    }

    //set the measure_text function
    pub fn set_measure_text_fn(&mut self, measure_text: fn(&str, &TextOptions) -> (Float, Float)) {
        println!("Setting measure text function");
        self.measure_text = Option::Some(measure_text);
    }

    //get the position of an entity
    pub fn get_position(&self, entity_id: EntityID) -> (Float, Float) {
        let pos = self.positions.get(&entity_id).unwrap();
        (pos.x, pos.y)
    }

    pub fn set_position(&mut self, entity_id: EntityID, x: Float, y: Float) {
        println!("Setting position of entity {} to ({}, {})", entity_id, x, y);
        let pos = self.positions.get_mut(&entity_id).unwrap();
        pos.x = x;
        pos.y = y;
    }

    //get the size of an entity
    pub fn get_size(&self, entity_id: EntityID) -> (Float, Float) {
        let size = self.sizes.get(&entity_id).unwrap();
        (size.w, size.h)
    }

    pub fn set_size(&mut self, entity_id: EntityID, width: Float, height: Float) {
        let size = self.sizes.get_mut(&entity_id).unwrap();
        size.w = width;
        size.h = height;
    }

    /**
     * Architecture note:
     * the new_element methods should only create the necessary elements
     * without calculating the position and size.
     * That will be done in the layout layer.
     */

    // Wraps an element in a box
    pub fn new_box(&mut self, child: DiagramTreeNode, options: BoxOptions) -> DiagramTreeNode {
        let box_id = self.new_entity(EntityType::BoxShape);

        let sbox = ShapeBox::new(box_id, child.entity_id, options);
        self.boxes.insert(box_id, sbox);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::BoxShape,
            entity_id: box_id,
            children: Vec::new(),
        };
        node.children.push(Box::new(child.clone()));
        node
    }

    // Creates a new Vertical stack.
    pub fn new_vstack(&mut self,
         children: Vec<DiagramTreeNode>,
        horizontal_alignment: HorizontalAlignment,
        ) -> DiagramTreeNode {
        let stack_id = self.new_entity(EntityType::VerticalStackShape);
        let mut vstack = VerticalStack {
            entity: stack_id,
            elements: Vec::new(),
            horizontal_alignment
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::VerticalStackShape,
            entity_id: stack_id,
            children: Vec::new(),
        };

        //set children
        for child in children {
            vstack.elements.push(child.entity_id);
            node.add_child(child)
        }

        self.vertical_stacks.insert(stack_id, vstack);

        node
    }

    // Creates a new Vertical stack.
    pub fn new_hstack(
        &mut self,
        children: Vec<DiagramTreeNode>,
        vertical_alignment: VerticalAlignment,
    ) -> DiagramTreeNode {
        let stack_id = self.new_entity(EntityType::HorizontalStackShape);
        let mut hstack = HorizontalStack {
            entity: stack_id,
            elements: Vec::new(),
            vertical_alignment,
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::HorizontalStackShape,
            entity_id: stack_id,
            children: Vec::new(),
        };

        //set children
        for child in children {
            hstack.elements.push(child.entity_id);
            node.add_child(child)
        }

        self.horizontal_stacks.insert(stack_id, hstack);

        node
    }

    pub fn new_rectangle(&mut self, options: RectOptions) -> DiagramTreeNode {
        let rect_id = self.new_entity(EntityType::RectShape);
        let rect = ShapeRect::new(rect_id, options);
        self.rectangles.insert(rect_id, rect);
        DiagramTreeNode::new(EntityType::RectShape, rect_id)
    }

    // Creates a new Text element
    // text: the text to display
    // options: the options for the text
    // ```rust
    // let text = session.new_text("Hello World", TextOptions::new());
    // ```
    pub fn new_text(&mut self, text: &str, options: TextOptions) -> DiagramTreeNode {
        let text_id = self.new_entity(EntityType::TextShape);
        //create the lines
        let text_lines = textwrap::wrap(&text, options.line_width);
        let lines: Vec<EntityID> = text_lines
            .iter()
            .map(|line| {
                let line_id = self.new_entity(EntityType::TextLine);
                let text_line = TextLine {
                    entity: line_id,
                    text: line.to_string(),
                };
                self.textlines.insert(line_id, text_line);
                line_id
            })
            .collect();

        let text = ShapeText::new(text_id, text, options, &lines);
        self.texts.insert(text_id, text);
        DiagramTreeNode::new(EntityType::TextShape, text_id)
    }

    pub fn new_line(
        &mut self,
        start: (Float, Float),
        end: (Float, Float),
        options: LineOptions,
    ) -> DiagramTreeNode {
        let line_id = self.new_entity(EntityType::LineShape);
        let line = ShapeLine::new(line_id, start, end, options);
        self.lines.insert(line_id, line);
        println!("Creating new line with id {}", line_id);
        DiagramTreeNode::new(EntityType::LineShape, line_id)
    }

    pub fn new_elipse(
        &mut self,
        center: (Float, Float),
        radius: (Float, Float),
        options: EllipseOptions,
    ) -> DiagramTreeNode {
        let ellipse_id = self.new_entity(EntityType::EllipseShape);
        let ellipse = ShapeEllipse::new(ellipse_id, center, radius, options);
        self.ellipses.insert(ellipse_id, ellipse);
        DiagramTreeNode::new(EntityType::EllipseShape, ellipse_id)
    }

    pub fn new_image(
        &mut self,
        image_data: &str,
        preferred_size: (Float, Float),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(EntityType::ImageShape);
        let image = ShapeImage::new(image_id, image_data.to_string(), preferred_size);
        self.images.insert(image_id, image);
        DiagramTreeNode::new(EntityType::ImageShape, image_id)
    }

    pub fn new_image_from_file(
        &mut self,
        file_path: &str,
        preferred_size: (Float, Float),
    ) -> DiagramTreeNode {
        let image_id = self.new_entity(EntityType::ImageShape);
        let image = ShapeImage::from_file(image_id, file_path.to_string(), preferred_size);
        self.images.insert(image_id, image);
        DiagramTreeNode::new(EntityType::ImageShape, image_id)
    }

    // Creates a new Group.
    pub fn new_group(&mut self, children: Vec<DiagramTreeNode>) -> DiagramTreeNode {
        let group_id = self.new_entity(EntityType::GroupShape);
        let mut sgroup = ShapeGroup {
            entity: group_id,
            elements: Vec::new(),
        };
        let mut node = DiagramTreeNode {
            entity_type: EntityType::GroupShape,
            entity_id: group_id,
            children: Vec::new(),
        };

        //set children
        for child in children {
            sgroup.elements.push(child.entity_id);
            node.add_child(child)
        }

        self.groups.insert(group_id, sgroup);

        node
    }

    pub fn new_table(
        &mut self,
        cells: Vec<DiagramTreeNode>,
        cols: usize,
        options: TableOptions,
    ) -> DiagramTreeNode {
        let mut cell_ids = Vec::new();
        for cell in &cells {
            cell_ids.push(cell.entity_id);
        }
        //create entities for the col and row lines
        let mut col_lines = Vec::new();
        for i in 0..cols {
            let line_id = self.new_entity(EntityType::LineShape);
            let line = ShapeLine::new(line_id, (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id, line);
            col_lines.push(line_id);
        }
        let num_rows = cells.len() / cols;
        let mut row_lines = Vec::new();
        for i in 0..num_rows + 1 {
            let line_id = self.new_entity(EntityType::LineShape);
            let line = ShapeLine::new(line_id, (0.0, 0.0), (0.0, 0.0), LineOptions::new());
            self.lines.insert(line_id, line);
            row_lines.push(line_id);
        }

        //Add a rectangle for the header row
        let header = self.new_rectangle(RectOptions {
            fill_color: Fill::Color(options.header_fill_color.clone()),
            stroke_color: String::from("black"),
            stroke_width: 1.0,
            ..Default::default()
        });

        let table_id = self.new_entity(EntityType::TableShape);
        let table = Table::new(
            table_id,
            cell_ids,
            col_lines.clone(),
            row_lines.clone(),
            cols,
            header.entity_id,
            options.clone(),
        );

        self.tables.insert(table_id, table);
        let mut node = DiagramTreeNode {
            entity_type: EntityType::TableShape,
            entity_id: table_id,
            children: Vec::new(),
        };

        // Add the header before the cells, otherwise it can cover the cells
        node.add_child(DiagramTreeNode::new(
            EntityType::RectShape,
            header.entity_id,
        ));

        for child in cells {
            node.add_child(child)
        }

        //add the lines
        for line in col_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }
        for line in row_lines {
            node.add_child(DiagramTreeNode::new(EntityType::LineShape, line));
        }

        node
    }

    pub fn new_polyline(
        &mut self,
        points: Vec<(Float, Float)>,
        options: LineOptions,
    ) -> DiagramTreeNode {
        let polyline_id = self.new_entity(EntityType::PolyLine);
        let polyline = PolyLine::new(polyline_id, points, options);
        self.polylines.insert(polyline_id, polyline);
        DiagramTreeNode::new(EntityType::PolyLine, polyline_id)
    }

    /// Creates a new FreeContainer that allows absolute positioning of children
    /// The container will size itself based on the positions and sizes of its children
    pub fn new_free_container(&mut self) -> DiagramTreeNode {
        let container_id = self.new_entity(EntityType::FreeContainer);
        let container = FreeContainer::new(container_id);
        self.free_containers.insert(container_id, container);
        DiagramTreeNode::new(EntityType::FreeContainer, container_id)
    }

    /// Creates a new FreeContainer with all children at once
    pub fn new_free_container_with_children(
        &mut self,
        children_with_positions: Vec<(DiagramTreeNode, (Float, Float))>,
    ) -> DiagramTreeNode {
        let container_id = self.new_entity(EntityType::FreeContainer);

        // Create the free container
        let mut container = FreeContainer::new(container_id);

        // Create the node for the tree
        let mut node = DiagramTreeNode {
            entity_type: EntityType::FreeContainer,
            entity_id: container_id,
            children: Vec::new(),
        };

        // Add all children with their positions
        for (child, position) in children_with_positions {
            container.add_child(child.entity_id, position);
            node.add_child(child);
        }

        // Store the container
        self.free_containers.insert(container_id, container);

        node
    }

    /// Add a child to a FreeContainer at the specified position
    /// The position is relative to the container's top-left corner
    pub fn add_to_free_container(
        &mut self,
        container_id: EntityID,
        child: DiagramTreeNode,
        position: (Float, Float),
    ) -> DiagramTreeNode {
        // Get the free container
        let container = self.free_containers.get_mut(&container_id).unwrap();

        // Add the child to the container with its position
        container.add_child(child.entity_id, position);

        // Create a new tree node for the container with the child
        let mut node = DiagramTreeNode {
            entity_type: EntityType::FreeContainer,
            entity_id: container_id,
            children: Vec::new(),
        };

        // Add the child node
        node.add_child(child);

        node
    }

    // Enhanced API convenience methods

    /// Create a new HStackBuilder for fluent horizontal stack creation
    pub fn hstack(&mut self) -> HStackBuilder {
        HStackBuilder::new(self)
    }

    /// Create a new BoxBuilder for fluent box creation
    pub fn box_with(&mut self, child: DiagramTreeNode) -> BoxBuilder {
        BoxBuilder::new(self, child)
    }
}

// element list accessors
impl DiagramBuilder {
    pub fn get_text(&self, id: EntityID) -> &ShapeText {
        &self.texts[&id]
    }

    pub fn get_group(&self, id: EntityID) -> &ShapeGroup {
        &self.groups[&id]
    }

    pub fn get_horizontal_stack(&self, id: EntityID) -> &HorizontalStack {
        &self.horizontal_stacks[&id]
    }

    pub fn get_vertical_stack(&self, id: EntityID) -> &VerticalStack {
        &self.vertical_stacks[&id]
    }

    pub fn get_ellipse(&self, id: EntityID) -> &ShapeEllipse {
        &self.ellipses[&id]
    }

    pub fn get_line(&self, id: EntityID) -> &ShapeLine {
        &self.lines[&id]
    }

    pub fn get_rectangle(&self, id: EntityID) -> &ShapeRect {
        &self.rectangles[&id]
    }

    pub fn get_text_line(&self, id: EntityID) -> &TextLine {
        &self.textlines[&id]
    }

    pub fn get_arrow(&self, id: EntityID) -> &ShapeArrow {
        &self.arrows[&id]
    }

    pub fn get_table(&self, id: EntityID) -> &Table {
        &self.tables[&id]
    }

    pub fn get_image(&self, id: EntityID) -> &ShapeImage {
        &self.images[&id]
    }

    pub fn get_box(&self, id: EntityID) -> &ShapeBox {
        &self.boxes[&id]
    }

    pub fn get_polyline(&self, id: EntityID) -> &PolyLine {
        &self.polylines[&id]
    }

    pub fn get_free_container(&self, id: EntityID) -> &FreeContainer {
        &self.free_containers[&id]
    }

    pub fn get_free_container_mut(&mut self, id: EntityID) -> &mut FreeContainer {
        self.free_containers.get_mut(&id).unwrap()
    }
}

// Enhanced API Builder Structs

/// Builder for creating horizontal stacks with fluent syntax
pub struct HStackBuilder<'a> {
    builder: &'a mut DiagramBuilder,
    children: Vec<DiagramTreeNode>,
}

impl<'a> HStackBuilder<'a> {
    fn new(builder: &'a mut DiagramBuilder) -> Self {
        HStackBuilder {
            builder,
            children: Vec::new(),
        }
    }

    /// Add a child element to the horizontal stack
    pub fn add(mut self, child: DiagramTreeNode) -> Self {
        self.children.push(child);
        self
    }

    /// Add a text element to the horizontal stack
    pub fn add_text(mut self, text: &str, options: TextOptions) -> Self {
        let text_node = self.builder.new_text(text, options);
        self.children.push(text_node);
        self
    }

    /// Add a text element with default options to the horizontal stack
    pub fn add_text_default(mut self, text: &str) -> Self {
        let text_node = self.builder.new_text(text, TextOptions::default());
        self.children.push(text_node);
        self
    }

    /// Build the horizontal stack
    pub fn build(self) -> DiagramTreeNode {
        self.builder.new_hstack(self.children, VerticalAlignment::Center)
    }
}

/// Builder for creating boxes with fluent syntax
pub struct BoxBuilder<'a> {
    builder: &'a mut DiagramBuilder,
    child: DiagramTreeNode,
    options: BoxOptions,
}

impl<'a> BoxBuilder<'a> {
    fn new(builder: &'a mut DiagramBuilder, child: DiagramTreeNode) -> Self {
        BoxBuilder {
            builder,
            child,
            options: BoxOptions::default(),
        }
    }

    /// Set the padding for the box
    pub fn padding(mut self, padding: Float) -> Self {
        self.options.padding = padding;
        self
    }

    /// Set the background color for the box
    pub fn background(mut self, color: &str) -> Self {
        self.options.fill_color = Fill::Color(color.to_string());
        self
    }

    /// Set the border color for the box
    pub fn border_color(mut self, color: &str) -> Self {
        self.options.stroke_color = color.to_string();
        self
    }

    /// Set the border width for the box
    pub fn border_width(mut self, width: Float) -> Self {
        self.options.stroke_width = width;
        self
    }

    /// Set the border radius for the box
    pub fn border_radius(mut self, radius: Float) -> Self {
        self.options.border_radius = radius;
        self
    }

    /// Build the box
    pub fn build(self) -> DiagramTreeNode {
        self.builder.new_box(self.child, self.options)
    }
}

//test
#[cfg(test)]
mod tests {
    use crate::get_entity_type_from_id;

    use super::*;

    #[test]
    fn test_session() {
        let mut session = DiagramBuilder::new();

        session.set_measure_text_fn(|text, text_options| {
            let textW: Float = text.len() as Float * text_options.font_size as Float;

            (textW, text_options.font_size.into())
        });
        let (w, h) = session.measure_text.unwrap()(
            "hello",
            &TextOptions {
                font_size: 12.0,
                ..Default::default()
            },
        );
        assert_eq!(w, 60.0);
        assert_eq!(h, 12.0);
    }
}

