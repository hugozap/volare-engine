===/Cargo.toml===
[package]
name = "custom_components"
version = "0.1.0"
edition = "2021"

[dependencies]
volare_engine_layout = { path = "../volare_engine_layout" }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.2"
uuid = { version = "1.0", features = ["v4", "js"] }

[lib]
name = "custom_components"
path = "src/lib.rs"
===/src/lib.rs===
//components/src/lib.rs
// Main library file for Volare Engine custom components

// Re-export the main engine for convenience
pub use volare_engine_layout::*;

// Component modules
pub mod document;
// You can add more component domains here as you create them:
// pub mod business_process;
// pub mod technical_diagrams;
// pub mod educational;
// pub mod data_viz;

// Convenience function to register ALL component sets at once
/// Register all available component sets with a DiagramBuilder
/// This is a convenience function that registers components from all domains
pub fn register_all_components(builder: &mut DiagramBuilder) {
   
    document::register_document_components(builder);
    println!("All component libraries registered successfully!");
}

===/src/document/mod.rs===
// src/components/documents/mod.rs
// Document components with consistent styling through predefined constants

use std::fmt::format;

use crate::diagram_builder::{DiagramBuilder, DiagramTreeNode};
use crate::document::style::{
    BG_ACCENT, BG_PRIMARY, DOCUMENT_WIDTH_DEFAULT, FONT_SANS, FONT_WEIGHT_BOLD_LIGHT, FONT_WEIGHT_BOLD_MAX, FONT_WEIGHT_BOLD_MD, LINE_HEIGHT_NORMAL, LINE_HEIGHT_RELAXED, LINE_HEIGHT_TIGHT, PADDING_NORMAL, PRIMARY_TEXT, SECONDARY_TEXT, SPACE_3XL, SPACE_SM, SPACE_XS, TEXT_2XL, TEXT_3XL, TEXT_BASE, TEXT_LG, TEXT_XL, TEXT_XS, WIDTH_FULL, WIDTH_LG, WIDTH_MD, WIDTH_PROPERTY, WIDTH_SM, WIDTH_XL
};
use crate::document::theme::BODY_COLOR;
use crate::parser::{
    get_array_attr, get_bool_attr, get_float_attr, get_int_attr, get_string_attr, JsonLinesParser,
};
use crate::*;
use serde_json::{from_value, Map, Value};
use uuid::fmt::Simple;
use uuid::uuid;

/// Document Style Constants
/// These constants define a consistent design system for document components
pub mod style {
    use crate::Float;

    // === COLOR PALETTE ===

    // Primary Colors
    pub const PRIMARY_TEXT: &str = "#212529"; // Dark gray for main text
    pub const SECONDARY_TEXT: &str = "#495057"; // Medium gray for headings
    pub const MUTED_TEXT: &str = "#6c757d"; // Light gray for metadata
    pub const ACCENT_TEXT: &str = "#0d6efd"; // Blue for links/accents

    // Background Colors
    pub const BG_PRIMARY: &str = "white"; // Main content background
    pub const BG_SECONDARY: &str = "#f8f9fa"; // Header/sidebar background
    pub const BG_MUTED: &str = "#f1f3f4"; // Footer/disabled background
    pub const BG_ACCENT: &str = "#e3f2fd"; // Highlight background

    // Border Colors
    pub const BORDER_LIGHT_COLOR: &str = "#dee2e6"; // Light borders
    pub const BORDER_MEDIUM_COLOR: &str = "#adb5bd"; // Medium borders
    pub const BORDER_STRONG_COLOR: &str = "#6c757d"; // Strong borders

    // Status Colors
    pub const SUCCESS: &str = "#198754";
    pub const WARNING: &str = "#ffc107";
    pub const DANGER: &str = "#dc3545";
    pub const INFO: &str = "#0dcaf0";

    // === TYPOGRAPHY ===

    // Font Families
    pub const FONT_SERIF: &str = "Georgia"; // For titles and headers
    pub const FONT_SANS: &str = "Arial"; // For body text
    pub const FONT_MONO: &str = "Consolas"; // For code

    // Font Sizes
    pub const TEXT_XS: Float = 10.0; // Footer text, captions
    pub const TEXT_SM: Float = 12.0; // Small text, metadata
    pub const TEXT_BASE: Float = 14.0; // Body text
    pub const TEXT_LG: Float = 16.0; // Large body text
    pub const TEXT_XL: Float = 18.0; // Section headings
    pub const TEXT_2XL: Float = 24.0; // Page titles
    pub const TEXT_3XL: Float = 32.0; // Main titles

    // Title font weights

    pub const FONT_WEIGHT_NORMAL: u32 = 400;
    pub const FONT_WEIGHT_BOLD_MAX: u32 = 900;
    pub const FONT_WEIGHT_BOLD_MD: u32 = 700;
    pub const FONT_WEIGHT_BOLD_LIGHT: u32 = 600;

    // Line Heights (as spacing multipliers)
    pub const LINE_HEIGHT_TIGHT: Float = 1.2;
    pub const LINE_HEIGHT_NORMAL: Float = 1.5;
    pub const LINE_HEIGHT_RELAXED: Float = 2.0;

    // === SPACING ===

    // Base spacing unit (all other spacing is multiples of this)
    pub const SPACE_UNIT: Float = 8.0;

    // Spacing Scale
    pub const SPACE_XS: Float = SPACE_UNIT * 0.5; // 4px
    pub const SPACE_SM: Float = SPACE_UNIT * 1.0; // 8px
    pub const SPACE_MD: Float = SPACE_UNIT * 2.0; // 16px
    pub const SPACE_LG: Float = SPACE_UNIT * 3.0; // 24px
    pub const SPACE_XL: Float = SPACE_UNIT * 4.0; // 32px
    pub const SPACE_2XL: Float = SPACE_UNIT * 6.0; // 48px
    pub const SPACE_3XL: Float = SPACE_UNIT * 8.0; // 64px

    // Component-specific spacing
    pub const PADDING_TIGHT: Float = SPACE_SM; // 8px
    pub const PADDING_NORMAL: Float = SPACE_MD; // 16px
    pub const PADDING_RELAXED: Float = SPACE_LG; // 24px
    pub const PADDING_LOOSE: Float = SPACE_XL; // 32px

    // === DIMENSIONS ===

    // Standard widths
    pub const WIDTH_SM: Float = 480.0; // Small documents
    pub const WIDTH_MD: Float = 640.0; // Medium documents
    pub const WIDTH_LG: Float = 800.0; // Large documents
    pub const WIDTH_XL: Float = 1024.0; // Extra large documents
    pub const WIDTH_FULL: Float = 1200.0; // Full width documents
    pub const WIDTH_PROPERTY: Float = 85.0; // For property field names/values

    // Border radius
    pub const RADIUS_SM: Float = 4.0;
    pub const RADIUS_MD: Float = 8.0;
    pub const RADIUS_LG: Float = 12.0;
    pub const RADIUS_PILL: Float = 9999.0; // For pill-shaped elements

    // Border widths
    pub const BORDER_THIN: Float = 1.0;
    pub const BORDER_MEDIUM: Float = 2.0;
    pub const BORDER_THICK: Float = 4.0;

    // === LINE WIDTHS (for text wrapping) ===
    pub const LINE_WIDTH_NARROW: usize = 300; // Narrow columns
    pub const LINE_WIDTH_NORMAL: usize = 500; // Standard paragraphs
    pub const LINE_WIDTH_WIDE: usize = 700; // Wide content
    pub const LINE_WIDTH_FULL: usize = 900; // Full width text

    // === COMPONENT PRESETS ===

    // Document container presets
    pub const DOCUMENT_WIDTH_DEFAULT: Float = WIDTH_LG;
    pub const DOCUMENT_PADDING_DEFAULT: Float = PADDING_LOOSE;
    pub const DOCUMENT_BORDER_RADIUS: Float = RADIUS_MD;

    // Header presets
    pub const HEADER_PADDING: Float = PADDING_RELAXED;
    pub const HEADER_TITLE_SIZE: Float = TEXT_2XL;
    pub const HEADER_SUBTITLE_SIZE: Float = TEXT_BASE;

    // Content presets
    pub const CONTENT_PADDING: Float = PADDING_LOOSE;
    pub const CONTENT_LINE_WIDTH: usize = LINE_WIDTH_WIDE;

    // Footer presets
    pub const FOOTER_PADDING: Float = PADDING_NORMAL;
    pub const FOOTER_TEXT_SIZE: Float = TEXT_XS;
}

/// Theme Constants
/// Higher-level semantic constants for different component themes
pub mod theme {
    use super::style::*;

    // Document theme
    pub const DOCUMENT_HEADER_BG: &str = BG_SECONDARY;
    pub const DOCUMENT_CONTENT_BG: &str = BG_PRIMARY;
    pub const DOCUMENT_FOOTER_BG: &str = BG_MUTED;
    pub const DOCUMENT_BORDER: &str = BORDER_LIGHT_COLOR;

    // Text themes
    pub const TITLE_COLOR: &str = PRIMARY_TEXT;
    pub const SUBTITLE_COLOR: &str = SECONDARY_TEXT;
    pub const BODY_COLOR: &str = PRIMARY_TEXT;
    pub const META_COLOR: &str = MUTED_TEXT;
    pub const LINK_COLOR: &str = ACCENT_TEXT;

    // Component themes
    pub const CARD_BG: &str = BG_PRIMARY;
    pub const CARD_BORDER: &str = BORDER_LIGHT_COLOR;
    pub const CARD_SHADOW: bool = true;

    pub const ALERT_SUCCESS_BG: &str = "#d1e7dd";
    pub const ALERT_SUCCESS_BORDER: &str = SUCCESS;
    pub const ALERT_WARNING_BG: &str = "#fff3cd";
    pub const ALERT_WARNING_BORDER: &str = WARNING;
    pub const ALERT_DANGER_BG: &str = "#f8d7da";
    pub const ALERT_DANGER_BORDER: &str = DANGER;
}

pub fn create_document_container(
    id: &str,
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
    parser: &JsonLinesParser,
) -> Result<DiagramTreeNode, String> {
    let mut children = Vec::new();
    let header_id = get_string_attr(attrs, &["header_id"], "");
    let content_id = get_string_attr(attrs, &["content_id"], "");
    let footer_id = get_string_attr(attrs, &["footer_id"], "");

    eprintln!("Building header: {}", header_id);
    // let newparser = JsonLinesParser::new();
    if let Ok(header_child) = parser.build(&header_id, builder) {
        let mut header_options = BoxOptions::new();
        header_options.padding = PADDING_NORMAL;
        header_options.fill_color = Fill::Color(BG_PRIMARY.to_string());
        header_options.stroke_width = 0.0;
        header_options.stroke_color = BG_PRIMARY.to_string();

        let header_container = builder.new_box(
            format!("{}_header_container", &id),
            header_child,
            header_options,
        );

        children.push(header_container);
    }

    if let Ok(content_child) = parser.build(&content_id, builder) {
        let mut content_options = BoxOptions::new();
        content_options.padding = PADDING_NORMAL;
        content_options.fill_color = Fill::Color(BG_PRIMARY.to_string());
        content_options.stroke_width = 0.0;
        content_options.stroke_color = BG_PRIMARY.to_string();

        let content_container = builder.new_box(
            format!("{}_content_container", &id),
            content_child,
            content_options,
        );
        children.push(content_container);
    }

    if let Ok(footer_child) = parser.build(&footer_id, builder) {
        let mut footer_options = BoxOptions::new();
        footer_options.padding = PADDING_NORMAL;
        footer_options.fill_color = Fill::Color(BG_PRIMARY.to_string());
        footer_options.stroke_width = 0.0;
        footer_options.stroke_color = BG_PRIMARY.to_string();

        let footer_container = builder.new_box(
            format!("{}_footer_container", &id),
            footer_child,
            footer_options,
        );
        children.push(footer_container);
    }

    let vstack = builder.new_vstack(id.to_string(), children, HorizontalAlignment::Left);

    return Ok(vstack);
}

/**
 * Element for presenting text with different variants
 *
 * variants:
 * default: Standard content blocks
 * large: Hero sections or main headings
 * small: Compact spaces or secondary information
 * subtle: Labels or supporting content
 * emphasized: Important callouts or quotes
 *
 * width attribute: |sm|md|lg|xl|full|<number>
 */
pub fn create_document_text(
    id: &str,
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
    parser: &JsonLinesParser,
) -> Result<DiagramTreeNode, String> {
    attrs.clone().iter().for_each(|(k, v)| {
        println!("k,v: {},{}", k, v);
    });
    let variant = get_string_attr(attrs, &["variant"], "default");
    let content = get_string_attr(attrs, &["text", "content"], "");
    let container_width = get_width(attrs, &["width"], WIDTH_MD);

    document_text(id, builder, variant, content, container_width)
}

pub fn document_text(
    id: &str,
    builder: &mut DiagramBuilder,
    variant: String,
    content: String,
    container_width: f32,
) -> Result<DiagramTreeNode, String> {
    let toptions = match variant.as_str() {
        "xlarge" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_XL,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED*TEXT_XL,
            ..TextOptions::default()
        },
        "large" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_LG,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED*TEXT_LG,
            ..TextOptions::default()
        },

        "small" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_XS,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_TIGHT*TEXT_XS,
            ..TextOptions::default()
        },

        "subtle" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_XS,
            text_color: SECONDARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_TIGHT*TEXT_XS,
            ..TextOptions::default()
        },

        _ => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_BASE,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_NORMAL*TEXT_BASE,
            ..TextOptions::default()
        },
    };

    let text = builder.new_text(format!("{}_text", id.clone()), content.as_str(), toptions);
    let w_size = SizeBehavior::Fixed(container_width);
    let coptions = BoxOptions {
        fill_color: Fill::Color("transparent".to_string()),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding: 0.0,
        border_radius: 0.0,
        width_behavior: w_size,
        height_behavior: SizeBehavior::Content,
        horizontal_alignment: HorizontalAlignment::Left,
    };
    let container = builder.new_box(format!("{}_text_container", id), text, coptions);
    Ok(container)
}

/**
 * Custom component for creating Titles
 */
pub fn create_document_title(
    id: &str,
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
    parser: &JsonLinesParser,
) -> Result<DiagramTreeNode, String> {
    let variant = get_string_attr(attrs, &["variant"], "default");
    let content = get_string_attr(attrs, &["text", "content"], "");
    let container_width = get_width(attrs, &["width"], WIDTH_MD);
    let toptions = match variant.as_str() {
        "h1" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_3XL,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED*TEXT_3XL,
            font_weight: FONT_WEIGHT_BOLD_MAX,
            ..TextOptions::default()
        },
        "h2" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_2XL,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED*TEXT_2XL,
            font_weight: FONT_WEIGHT_BOLD_MAX,
            ..TextOptions::default()
        },

        "h3" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_XL,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED*TEXT_XL,
            font_weight: FONT_WEIGHT_BOLD_MD,
            ..TextOptions::default()
        },

        "h4" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_LG,
            text_color: SECONDARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED*TEXT_LG,
            font_weight: FONT_WEIGHT_BOLD_LIGHT,
            ..TextOptions::default()
        },

        _ => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_2XL,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_NORMAL*TEXT_2XL,
            font_weight: FONT_WEIGHT_BOLD_LIGHT,
            ..TextOptions::default()
        },
    };

    let text = builder.new_text(format!("{}_text", id), content.as_str(), toptions);
    let w_size = SizeBehavior::Fixed(container_width);
    let coptions = BoxOptions {
        fill_color: Fill::Color("transparent".to_string()),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding: 0.0,
        border_radius: 0.0,
        width_behavior: w_size,
        height_behavior: SizeBehavior::Content,
        horizontal_alignment: HorizontalAlignment::Left,
    };
    let spacer = builder.new_spacer(
        format!("{}_spacer", id),
        SpacerOptions {
            width: 0.0,
            height: SPACE_XS,
            direction: SpacerDirection::Vertical,
        },
    );
    let t_container = builder.new_box(format!("{}_text_container", id), text.clone(), coptions);
    let container = builder.new_vstack(
        format!("_container"),
        vec![t_container, spacer],
        HorizontalAlignment::Left,
    );
    Ok(container)
}

/**
 * Component useful for presenting a list of name/value property list
 */
pub fn create_properties(
    id: &str,
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
    parser: &JsonLinesParser,
) -> Result<DiagramTreeNode, String> {
    let properties = get_properties(attrs, &["properties", "items"]);
    let table_opts = TableOptions {
        cell_padding: SPACE_SM,
        with_header: false,
        border_color: BODY_COLOR.to_string(),
        border_width: 1,
        fill_color: BG_ACCENT.to_string(),
        ..Default::default()
    };

    // Crear las celdas a partir de las propiedades Vec<(String,String)>
    let cell_values: Vec<String> = properties.into_iter().flat_map(|(a, b)| [a, b]).collect();


    let cell_texts: Vec<DiagramTreeNode> = cell_values
        .into_iter()
        .map(|value| {
            // TODO: variant debe ser enum
            // TODO: en vez de uuid derivar el id del nombre de la propiedad si es posible
            // TODO: usar width diferente para nombre y value
            document_text(format!("{}_prop_{}",id, uuid::Uuid::new_v4()).as_str(), builder, "small".into(), value, WIDTH_PROPERTY)
        })
        .filter_map(|v| v.ok())
        .collect();

    let table = builder.new_table(format!("{}_table", id), cell_texts, 2, table_opts);
    Ok(table)
}

/**
 * Used for the property panels, each item is expected to have two values, name and value
 * e.g items=[["name","value"], ["name", "value"]...]
 */
pub fn get_properties(attrs: &Map<String, Value>, keys: &[&str]) -> Vec<(String, String)> {
    let mut items = Vec::<(String, String)>::new();
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(arr) = value.as_array() {
                for item_arr_val in arr {
                    if let Some(item_arr) = item_arr_val.as_array() {
                        if item_arr.len() == 2 {
                            let name_elem = &item_arr[0];
                            let value_elem = &item_arr[1];
                            let name = name_elem.as_str().unwrap();
                            let value = value_elem.as_str().unwrap();
                            items.push((name.to_owned(), value.to_owned()));
                        }
                    }
                }
            }
        }
    }
    items
}

// Helper function for extracting a text width from names or pixel value
// |sm|md|lg|xl|full|<number>
pub fn get_width(attrs: &Map<String, Value>, keys: &[&str], default: Float) -> Float {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(s) = value.as_str() {
                return if s.is_empty() {
                    default
                } else {
                    match s {
                        "sm" => WIDTH_SM,
                        "md" => WIDTH_MD,
                        "lg" => WIDTH_LG,
                        "xl" => WIDTH_XL,
                        "full" => WIDTH_FULL,
                        _ => {
                            if let Ok(val) = s.parse::<f32>() {
                                val
                            } else {
                                WIDTH_MD
                            }
                        }
                    }
                };
            }
        }
    }
    default
}

/// Register document components with a DiagramBuilder
pub fn register_document_components(builder: &mut DiagramBuilder) {
    builder.register_custom_component("document", create_document_container);
    builder.register_custom_component("document.text", create_document_text);
    builder.register_custom_component("document.title", create_document_title);
    builder.register_custom_component("document.properties", create_properties);
    println!("ðŸ“„ Document component registered: 'document'");
}

