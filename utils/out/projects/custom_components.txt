===/Cargo.toml===
[package]
name = "custom_components"
version = "0.1.0"
edition = "2021"

[dependencies]
volare_engine_layout = { path = "../volare_engine_layout" }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
textwrap = "0.16.2"
uuid = { version = "1.0", features = ["v4", "js"] }

[lib]
name = "custom_components"
path = "src/lib.rs"
===/src/lib.rs===
//components/src/lib.rs
// Main library file for Volare Engine custom components

// Re-export the main engine for convenience
pub use volare_engine_layout::*;

// Component modules
pub mod document;
// You can add more component domains here as you create them:
// pub mod business_process;
// pub mod technical_diagrams;
// pub mod educational;
// pub mod data_viz;

// Convenience function to register ALL component sets at once
/// Register all available component sets with a DiagramBuilder
/// This is a convenience function that registers components from all domains
pub fn register_all_components(builder: &mut DiagramBuilder) {
   
    document::register_document_components(builder);
    println!("All component libraries registered successfully!");
}

===/src/document/mod.rs===
// src/components/documents/mod.rs
// Document components with consistent styling through predefined constants

use crate::diagram_builder::{DiagramBuilder, DiagramTreeNode};
use crate::document::style::{
    BG_PRIMARY, DOCUMENT_WIDTH_DEFAULT, FONT_SANS, LINE_HEIGHT_NORMAL, LINE_HEIGHT_RELAXED, LINE_HEIGHT_TIGHT, PADDING_NORMAL, PRIMARY_TEXT, SECONDARY_TEXT, TEXT_BASE, TEXT_LG, TEXT_XS, WIDTH_FULL, WIDTH_LG, WIDTH_MD, WIDTH_SM, WIDTH_XL
};
use crate::document::theme::BODY_COLOR;
use crate::parser::{
    get_array_attr, get_bool_attr, get_float_attr, get_int_attr, get_string_attr, JsonLinesParser,
};
use crate::*;
use serde_json::{Map, Value};
use uuid::fmt::Simple;

/// Document Style Constants
/// These constants define a consistent design system for document components
pub mod style {
    use crate::Float;

    // === COLOR PALETTE ===

    // Primary Colors
    pub const PRIMARY_TEXT: &str = "#212529"; // Dark gray for main text
    pub const SECONDARY_TEXT: &str = "#495057"; // Medium gray for headings
    pub const MUTED_TEXT: &str = "#6c757d"; // Light gray for metadata
    pub const ACCENT_TEXT: &str = "#0d6efd"; // Blue for links/accents

    // Background Colors
    pub const BG_PRIMARY: &str = "white"; // Main content background
    pub const BG_SECONDARY: &str = "#f8f9fa"; // Header/sidebar background
    pub const BG_MUTED: &str = "#f1f3f4"; // Footer/disabled background
    pub const BG_ACCENT: &str = "#e3f2fd"; // Highlight background

    // Border Colors
    pub const BORDER_LIGHT_COLOR: &str = "#dee2e6"; // Light borders
    pub const BORDER_MEDIUM_COLOR: &str = "#adb5bd"; // Medium borders
    pub const BORDER_STRONG_COLOR: &str = "#6c757d"; // Strong borders

    // Status Colors
    pub const SUCCESS: &str = "#198754";
    pub const WARNING: &str = "#ffc107";
    pub const DANGER: &str = "#dc3545";
    pub const INFO: &str = "#0dcaf0";

    // === TYPOGRAPHY ===

    // Font Families
    pub const FONT_SERIF: &str = "Georgia"; // For titles and headers
    pub const FONT_SANS: &str = "Arial"; // For body text
    pub const FONT_MONO: &str = "Consolas"; // For code

    // Font Sizes
    pub const TEXT_XS: Float = 10.0; // Footer text, captions
    pub const TEXT_SM: Float = 12.0; // Small text, metadata
    pub const TEXT_BASE: Float = 14.0; // Body text
    pub const TEXT_LG: Float = 16.0; // Large body text
    pub const TEXT_XL: Float = 18.0; // Section headings
    pub const TEXT_2XL: Float = 24.0; // Page titles
    pub const TEXT_3XL: Float = 32.0; // Main titles

    // Line Heights (as spacing multipliers)
    pub const LINE_HEIGHT_TIGHT: Float = 1.2;
    pub const LINE_HEIGHT_NORMAL: Float = 1.5;
    pub const LINE_HEIGHT_RELAXED: Float = 1.8;

    // === SPACING ===

    // Base spacing unit (all other spacing is multiples of this)
    pub const SPACE_UNIT: Float = 8.0;

    // Spacing Scale
    pub const SPACE_XS: Float = SPACE_UNIT * 0.5; // 4px
    pub const SPACE_SM: Float = SPACE_UNIT * 1.0; // 8px
    pub const SPACE_MD: Float = SPACE_UNIT * 2.0; // 16px
    pub const SPACE_LG: Float = SPACE_UNIT * 3.0; // 24px
    pub const SPACE_XL: Float = SPACE_UNIT * 4.0; // 32px
    pub const SPACE_2XL: Float = SPACE_UNIT * 6.0; // 48px
    pub const SPACE_3XL: Float = SPACE_UNIT * 8.0; // 64px

    // Component-specific spacing
    pub const PADDING_TIGHT: Float = SPACE_SM; // 8px
    pub const PADDING_NORMAL: Float = SPACE_MD; // 16px
    pub const PADDING_RELAXED: Float = SPACE_LG; // 24px
    pub const PADDING_LOOSE: Float = SPACE_XL; // 32px

    // === DIMENSIONS ===

    // Standard widths
    pub const WIDTH_SM: Float = 480.0; // Small documents
    pub const WIDTH_MD: Float = 640.0; // Medium documents
    pub const WIDTH_LG: Float = 800.0; // Large documents
    pub const WIDTH_XL: Float = 1024.0; // Extra large documents
    pub const WIDTH_FULL: Float = 1200.0; // Full width documents

    // Border radius
    pub const RADIUS_SM: Float = 4.0;
    pub const RADIUS_MD: Float = 8.0;
    pub const RADIUS_LG: Float = 12.0;
    pub const RADIUS_PILL: Float = 9999.0; // For pill-shaped elements

    // Border widths
    pub const BORDER_THIN: Float = 1.0;
    pub const BORDER_MEDIUM: Float = 2.0;
    pub const BORDER_THICK: Float = 4.0;

    // === LINE WIDTHS (for text wrapping) ===
    pub const LINE_WIDTH_NARROW: usize = 300; // Narrow columns
    pub const LINE_WIDTH_NORMAL: usize = 500; // Standard paragraphs
    pub const LINE_WIDTH_WIDE: usize = 700; // Wide content
    pub const LINE_WIDTH_FULL: usize = 900; // Full width text

    // === COMPONENT PRESETS ===

    // Document container presets
    pub const DOCUMENT_WIDTH_DEFAULT: Float = WIDTH_LG;
    pub const DOCUMENT_PADDING_DEFAULT: Float = PADDING_LOOSE;
    pub const DOCUMENT_BORDER_RADIUS: Float = RADIUS_MD;

    // Header presets
    pub const HEADER_PADDING: Float = PADDING_RELAXED;
    pub const HEADER_TITLE_SIZE: Float = TEXT_2XL;
    pub const HEADER_SUBTITLE_SIZE: Float = TEXT_BASE;

    // Content presets
    pub const CONTENT_PADDING: Float = PADDING_LOOSE;
    pub const CONTENT_LINE_WIDTH: usize = LINE_WIDTH_WIDE;

    // Footer presets
    pub const FOOTER_PADDING: Float = PADDING_NORMAL;
    pub const FOOTER_TEXT_SIZE: Float = TEXT_XS;
}

/// Theme Constants
/// Higher-level semantic constants for different component themes
pub mod theme {
    use super::style::*;

    // Document theme
    pub const DOCUMENT_HEADER_BG: &str = BG_SECONDARY;
    pub const DOCUMENT_CONTENT_BG: &str = BG_PRIMARY;
    pub const DOCUMENT_FOOTER_BG: &str = BG_MUTED;
    pub const DOCUMENT_BORDER: &str = BORDER_LIGHT_COLOR;

    // Text themes
    pub const TITLE_COLOR: &str = PRIMARY_TEXT;
    pub const SUBTITLE_COLOR: &str = SECONDARY_TEXT;
    pub const BODY_COLOR: &str = PRIMARY_TEXT;
    pub const META_COLOR: &str = MUTED_TEXT;
    pub const LINK_COLOR: &str = ACCENT_TEXT;

    // Component themes
    pub const CARD_BG: &str = BG_PRIMARY;
    pub const CARD_BORDER: &str = BORDER_LIGHT_COLOR;
    pub const CARD_SHADOW: bool = true;

    pub const ALERT_SUCCESS_BG: &str = "#d1e7dd";
    pub const ALERT_SUCCESS_BORDER: &str = SUCCESS;
    pub const ALERT_WARNING_BG: &str = "#fff3cd";
    pub const ALERT_WARNING_BORDER: &str = WARNING;
    pub const ALERT_DANGER_BG: &str = "#f8d7da";
    pub const ALERT_DANGER_BORDER: &str = DANGER;
}

pub fn create_document_container(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
    parser: &JsonLinesParser,
) -> Result<DiagramTreeNode, String> {
    let id = get_string_attr(attrs, &["id"], "");
    let mut children = Vec::new();
    let header_id = get_string_attr(attrs, &["header_id"], "");
    let content_id = get_string_attr(attrs, &["content_id"], "");
    let footer_id = get_string_attr(attrs, &["footer_id"], "");

    eprintln!("Building header: {}", header_id);
    // let newparser = JsonLinesParser::new();
    if let Ok(header_child) = parser.build(&header_id, builder) {
        let mut header_options = BoxOptions::new();
        header_options.padding = PADDING_NORMAL;
        header_options.fill_color = Fill::Color(BG_PRIMARY.to_string());
        header_options.stroke_width = 0.0;
        header_options.stroke_color = BG_PRIMARY.to_string();

        let header_container = builder.new_box(
            format!("{}_header_container", &id),
            header_child,
            header_options,
        );

        children.push(header_container);
    }

    if let Ok(content_child) = parser.build(&content_id, builder) {
        let mut content_options = BoxOptions::new();
        content_options.padding = PADDING_NORMAL;
        content_options.fill_color = Fill::Color(BG_PRIMARY.to_string());
        content_options.stroke_width = 0.0;
        content_options.stroke_color = BG_PRIMARY.to_string();

        let content_container = builder.new_box(
            format!("{}_content_container", &id),
            content_child,
            content_options,
        );
        children.push(content_container);
    }

    if let Ok(footer_child) = parser.build(&footer_id, builder) {
        let mut footer_options = BoxOptions::new();
        footer_options.padding = PADDING_NORMAL;
        footer_options.fill_color = Fill::Color(BG_PRIMARY.to_string());
        footer_options.stroke_width = 0.0;
        footer_options.stroke_color = BG_PRIMARY.to_string();

        let footer_container = builder.new_box(
            format!("{}_footer_container", &id),
            footer_child,
            footer_options,
        );
        children.push(footer_container);
    }

    let vstack = builder.new_vstack(
        id.to_string(),
        children,
        HorizontalAlignment::Left,
    );

    return Ok(vstack);
}

/**
 * Element for presenting text with different variants
 *
 * variants:
 * default: Standard content blocks
 * large: Hero sections or main headings
 * small: Compact spaces or secondary information
 * subtle: Labels or supporting content
 * emphasized: Important callouts or quotes
 *
 * width attribute: |sm|md|lg|xl|full|<number>
 */
pub fn create_document_text(
    attrs: &Map<String, Value>,
    builder: &mut DiagramBuilder,
    parser: &JsonLinesParser,
) -> Result<DiagramTreeNode, String> {
    let id = get_string_attr(attrs, &["id"], "");
    let variant = get_string_attr(attrs, &["variant"], "default");
    let content = get_string_attr(attrs, &["text", "content"], "");
    let container_width = get_width(attrs, &["width"], WIDTH_MD);

    let toptions = match variant.as_str() {
        "large" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_LG,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_RELAXED,
            ..TextOptions::default()
        },

        "small" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_XS,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_TIGHT,
            ..TextOptions::default()
        },

        "subtle" => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_XS,
            text_color: SECONDARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_TIGHT,
            ..TextOptions::default()
        },

        _ => TextOptions {
            font_family: FONT_SANS.to_string(),
            font_size: TEXT_BASE,
            text_color: PRIMARY_TEXT.to_string(),
            line_spacing: LINE_HEIGHT_NORMAL,
            ..TextOptions::default()
        },
    };

    let text = builder.new_text(format!("{}_text", id.clone()), content.as_str(), toptions);
    let w_size = SizeBehavior::Fixed(container_width);
    let coptions = BoxOptions {
        fill_color: Fill::Color("transparent".to_string()),
        stroke_color: "transparent".to_string(),
        stroke_width: 0.0,
        padding: 0.0,
        border_radius: 0.0,
        width_behavior: w_size,
        height_behavior: SizeBehavior::Content,
    };
    let container = builder.new_box(format!("{}_text_container", id), text, coptions);
    Ok(container)
}


// Helper function for extracting a text width from names or pixel value
// |sm|md|lg|xl|full|<number>
pub fn get_width(attrs: &Map<String, Value>, keys: &[&str], default: Float) -> Float {
    for key in keys {
        if let Some(value) = attrs.get(*key) {
            if let Some(s) = value.as_str() {
                return if s.is_empty(){
                    default
                } else {
                    match s {
                        "sm" => {
                            WIDTH_SM
                        }
                        "md" => {
                            WIDTH_MD
                        }
                        "lg" => {
                            WIDTH_LG
                        }
                         "xl" => {
                            WIDTH_XL
                        }
                         "full" => {
                            WIDTH_FULL
                        }
                        _ => {
                            if let Ok(val) = s.parse::<f32>() {
                                val
                            } else {
                                WIDTH_MD
                            }
                        }
                    }
                };
            }
        }
    }
    default
}

/// Register document components with a DiagramBuilder
pub fn register_document_components(builder: &mut DiagramBuilder) {
    builder.register_custom_component("document", create_document_container);
    builder.register_custom_component("document.text", create_document_text);
    println!("ðŸ“„ Document component registered: 'document'");
}

